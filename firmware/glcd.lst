   1               		.file	"glcd.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  12               		.text
  13               	.Ltext0:
 126               	.global	get_font
 128               	get_font:
 129               		.stabd	46,0,0
   0:glcd.c        **** /*! \file glcd.c \brief Graphic LCD API functions. */
   1:glcd.c        **** //*****************************************************************************
   2:glcd.c        **** //
   3:glcd.c        **** // File Name	: 'glcd.c'
   4:glcd.c        **** // Title		: Graphic LCD API functions
   5:glcd.c        **** // Author		: Pascal Stang - Copyright (C) 2002
   6:glcd.c        **** // Date			: 5/30/2002
   7:glcd.c        **** // Revised		: 5/30/2002
   8:glcd.c        **** // Version		: 0.5
   9:glcd.c        **** // Target MCU	: Atmel AVR
  10:glcd.c        **** // Editor Tabs	: 4
  11:glcd.c        **** //
  12:glcd.c        **** // NOTE: This code is currently below version 1.0, and therefore is considered
  13:glcd.c        **** // to be lacking in some functionality or documentation, or may not be fully
  14:glcd.c        **** // tested.  Nonetheless, you can expect most functions to work.
  15:glcd.c        **** //
  16:glcd.c        **** // This code is distributed under the GNU Public License
  17:glcd.c        **** //		which can be found at http://www.gnu.org/licenses/gpl.txt
  18:glcd.c        **** //
  19:glcd.c        **** //*****************************************************************************
  20:glcd.c        **** 
  21:glcd.c        **** #ifndef WIN32
  22:glcd.c        **** // AVR specific includes
  23:glcd.c        **** 	#include <avr/io.h>
  24:glcd.c        **** 	#include <avr/pgmspace.h>
  25:glcd.c        **** 	#include <avr/eeprom.h>
  26:glcd.c        **** #endif
  27:glcd.c        **** 
  28:glcd.c        **** #include "glcd.h"
  29:glcd.c        **** 
  30:glcd.c        **** // include hardware support
  31:glcd.c        **** #include "ks0108.h"
  32:glcd.c        **** // include fonts
  33:glcd.c        **** #include "font5x7.h"
  34:glcd.c        **** #include "fontgr.h"
  35:glcd.c        **** 
  36:glcd.c        **** #include "util.h"
  37:glcd.c        **** 
  38:glcd.c        **** 
  39:glcd.c        **** 
  40:glcd.c        **** 
  41:glcd.c        **** // graphic routines
  42:glcd.c        **** 
  43:glcd.c        **** // set dot
  44:glcd.c        **** void glcdSetDot(u08 x, u08 y)
  45:glcd.c        **** {
  46:glcd.c        **** 	unsigned char temp;
  47:glcd.c        **** 
  48:glcd.c        **** 	//putstring("->addr "); uart_putw_dec(x);
  49:glcd.c        **** 	//putstring(", "); uart_putw_dec(y/8);
  50:glcd.c        **** 	//putstring_nl(")");
  51:glcd.c        **** 
  52:glcd.c        **** 	glcdSetAddress(x, y/8);
  53:glcd.c        **** 	temp = glcdDataRead();	// dummy read
  54:glcd.c        **** 	temp = glcdDataRead();	// read back current value
  55:glcd.c        **** 	glcdSetAddress(x, y/8);
  56:glcd.c        **** 	glcdDataWrite(temp | (1 << (y % 8)));
  57:glcd.c        **** 	glcdStartLine(0);
  58:glcd.c        **** }
  59:glcd.c        **** /*
  60:glcd.c        **** // clear dot
  61:glcd.c        **** void glcdClearDot(u08 x, u08 y)
  62:glcd.c        **** {
  63:glcd.c        **** 	unsigned char temp;
  64:glcd.c        **** 
  65:glcd.c        **** 	glcdSetAddress(x, y/8);
  66:glcd.c        **** 	temp = glcdDataRead();	// dummy read
  67:glcd.c        **** 	temp = glcdDataRead();	// read back current value
  68:glcd.c        **** 	glcdSetAddress(x, y/8);
  69:glcd.c        **** 	glcdDataWrite(temp & ~(1 << (y % 8)));
  70:glcd.c        **** 
  71:glcd.c        **** 	glcdStartLine(0);
  72:glcd.c        **** }
  73:glcd.c        **** 
  74:glcd.c        **** // draw line
  75:glcd.c        **** void glcdLine(u08 x1, u08 y1, u08 x2, u08 y2)
  76:glcd.c        **** {
  77:glcd.c        **** };
  78:glcd.c        **** 
  79:glcd.c        **** // draw rectangle
  80:glcd.c        **** void glcdRectangle(u08 x, u08 y, u08 w, u08 h)
  81:glcd.c        **** {
  82:glcd.c        ****   /*
  83:glcd.c        ****   unsigned char j;
  84:glcd.c        **** 
  85:glcd.c        ****   for (j = 0; j < a; j++) {
  86:glcd.c        ****    glcdSetDot(x, y + j);
  87:glcd.c        ****    glcdSetDot(x + b - 1, y + j);
  88:glcd.c        ****    }
  89:glcd.c        **** 
  90:glcd.c        ****   for (j = 0; j < b; j++)	{
  91:glcd.c        ****     glcdSetDot(x + j, y);
  92:glcd.c        ****     glcdSetDot(x + j, y + a - 1);
  93:glcd.c        ****   }
  94:glcd.c        **** */
  95:glcd.c        ****   // optimized!
  96:glcd.c        ****   /*
  97:glcd.c        ****   glcdFillRectangle(x, y, 1, h, ON);
  98:glcd.c        ****   glcdFillRectangle(x+w-1, y, 1, h, ON);
  99:glcd.c        ****   glcdFillRectangle(x, y, w, 1, ON);
 100:glcd.c        ****   glcdFillRectangle(x, y+h-1, w, 1, ON);
 101:glcd.c        **** }*/
 102:glcd.c        **** 
 103:glcd.c        **** 
 104:glcd.c        **** // draw filled rectangle
 105:glcd.c        **** void glcdFillRectangle(u08 x, u08 y, u08 a, u08 b, u08 color)
 106:glcd.c        **** {
 107:glcd.c        ****   unsigned char i, j, temp;
 108:glcd.c        ****   signed char k;
 109:glcd.c        **** 
 110:glcd.c        ****   /*
 111:glcd.c        ****   unsigned char bitsleft;
 112:glcd.c        **** // slow :(
 113:glcd.c        ****   for (i = 0; i < a; i++) {
 114:glcd.c        ****     if ( (x+i) > GLCD_XPIXELS )
 115:glcd.c        ****       break;
 116:glcd.c        ****     for (j = 0; j < b; j++) {
 117:glcd.c        ****       if ( (y+j) > GLCD_YPIXELS )
 118:glcd.c        **** 	break;
 119:glcd.c        ****       if (color == ON) {
 120:glcd.c        **** 	glcdSetDot(x + i, y + j);
 121:glcd.c        ****       } else {
 122:glcd.c        **** 	glcdClearDot(x + i, y + j);
 123:glcd.c        ****       }
 124:glcd.c        ****     }
 125:glcd.c        ****   }
 126:glcd.c        ****   */
 127:glcd.c        **** 
 128:glcd.c        ****   // fast! :)
 129:glcd.c        ****   /*
 130:glcd.c        ****   for (i=0; i < a; i++) {
 131:glcd.c        ****     glcdSetAddress(x+i, y/8);
 132:glcd.c        ****     bitsleft = b;
 133:glcd.c        ****     j = 0;
 134:glcd.c        ****     // first byte is strange
 135:glcd.c        ****     if ((bitsleft % 8) || (y%8)) {
 136:glcd.c        ****       temp = glcdDataRead();	// dummy read
 137:glcd.c        ****       temp = glcdDataRead();	// read back current value
 138:glcd.c        ****       // not on a perfect boundary
 139:glcd.c        ****       for (k=(y%8); k < 8; k++) {
 140:glcd.c        **** 	if (bitsleft) {
 141:glcd.c        **** 	  if (color == ON)
 142:glcd.c        **** 	    temp |= _BV(k);
 143:glcd.c        **** 	  else
 144:glcd.c        **** 	    temp &= ~_BV(k);
 145:glcd.c        **** 	  bitsleft--;
 146:glcd.c        **** 	}
 147:glcd.c        ****       }
 148:glcd.c        ****       glcdSetAddress(x+i, (y+j)/8);
 149:glcd.c        ****       glcdDataWrite(temp);
 150:glcd.c        ****       j = 8;
 151:glcd.c        ****     }
 152:glcd.c        ****     
 153:glcd.c        ****     for(; bitsleft >= 8; bitsleft-=8) {
 154:glcd.c        ****       glcdSetAddress(x+i, (y+j)/8);
 155:glcd.c        ****       if (color == ON) {
 156:glcd.c        **** 	glcdDataWrite(0xFF);  
 157:glcd.c        ****       } else {
 158:glcd.c        **** 	glcdDataWrite(0x00);
 159:glcd.c        ****       }
 160:glcd.c        ****       j+=8;
 161:glcd.c        ****     }
 162:glcd.c        ****     // do the remainder
 163:glcd.c        ****     if (bitsleft) {
 164:glcd.c        ****       glcdSetAddress(x+i, (y+j)/8);
 165:glcd.c        ****       temp = glcdDataRead();	// dummy read
 166:glcd.c        ****       temp = glcdDataRead();	// read back current value
 167:glcd.c        ****       if (color == ON)
 168:glcd.c        **** 	temp |= (1 << ((y+b)%8)) - 1;
 169:glcd.c        ****       else
 170:glcd.c        **** 	temp &= ~ ((1 << (y+b)%8) - 1);
 171:glcd.c        ****       
 172:glcd.c        ****       glcdSetAddress(x+i, (y+j)/8);
 173:glcd.c        ****       glcdDataWrite(temp);
 174:glcd.c        ****     }
 175:glcd.c        ****   }
 176:glcd.c        ****   */
 177:glcd.c        **** 
 178:glcd.c        ****   // fastest!
 179:glcd.c        ****   if (y%8) {
 180:glcd.c        ****     for (i=0; i<a; i++) {
 181:glcd.c        ****       glcdSetAddress(x+i, y/8);
 182:glcd.c        ****       temp = glcdDataRead();	// dummy read
 183:glcd.c        ****       temp = glcdDataRead();	// read back current value
 184:glcd.c        ****       // not on a perfect boundary
 185:glcd.c        ****       for (k=(y%8); k < (y%8)+b && (k<8); k++) {
 186:glcd.c        **** 	if (color == ON)
 187:glcd.c        **** 	  temp |= _BV(k);
 188:glcd.c        **** 	else
 189:glcd.c        **** 	  temp &= ~_BV(k);
 190:glcd.c        ****       }
 191:glcd.c        ****       glcdSetAddress(x+i, y/8);
 192:glcd.c        ****       glcdDataWrite(temp);
 193:glcd.c        ****     } 
 194:glcd.c        ****     // we did top section so remove it
 195:glcd.c        **** 
 196:glcd.c        ****     if (b > 8-(y%8))
 197:glcd.c        ****       b -= 8-(y%8);
 198:glcd.c        ****     else 
 199:glcd.c        ****       b = 0;
 200:glcd.c        ****     y -= (y%8);
 201:glcd.c        ****     y+=8;
 202:glcd.c        ****   }
 203:glcd.c        ****   // skip to next section
 204:glcd.c        ****   for (j=(y/8); j < (y+b)/8; j++) {
 205:glcd.c        ****     glcdSetAddress(x, j);
 206:glcd.c        ****     for (i=0; i<a; i++) {
 207:glcd.c        ****       if (color == ON)
 208:glcd.c        **** 	glcdDataWrite(0xFF);
 209:glcd.c        ****       else
 210:glcd.c        **** 	glcdDataWrite(0x00);
 211:glcd.c        ****     }
 212:glcd.c        ****   }
 213:glcd.c        ****   b = b%8;
 214:glcd.c        ****   // do remainder
 215:glcd.c        ****   if (b) {
 216:glcd.c        ****     for (i=0; i<a; i++) {
 217:glcd.c        ****       glcdSetAddress(x+i, j);
 218:glcd.c        ****       temp = glcdDataRead();	// dummy read
 219:glcd.c        ****       temp = glcdDataRead();	// read back current value
 220:glcd.c        ****       // not on a perfect boundary
 221:glcd.c        ****       for (k=0; k < b; k++) {
 222:glcd.c        **** 	if (color == ON)
 223:glcd.c        **** 	  temp |= _BV(k);
 224:glcd.c        **** 	else
 225:glcd.c        **** 	  temp &= ~_BV(k);
 226:glcd.c        ****       }
 227:glcd.c        ****       glcdSetAddress(x+i, j);
 228:glcd.c        ****       glcdDataWrite(temp);
 229:glcd.c        ****     }
 230:glcd.c        ****   }
 231:glcd.c        ****   glcdStartLine(0);
 232:glcd.c        **** }
 233:glcd.c        **** 
 234:glcd.c        **** /*
 235:glcd.c        **** // draw circle
 236:glcd.c        **** void glcdCircle(u08 xcenter, u08 ycenter, u08 radius, u08 color)
 237:glcd.c        **** {
 238:glcd.c        ****   int tswitch, y, x = 0;
 239:glcd.c        ****   unsigned char d;
 240:glcd.c        **** 
 241:glcd.c        ****   d = ycenter - xcenter;
 242:glcd.c        ****   y = radius;
 243:glcd.c        ****   tswitch = 3 - 2 * radius;
 244:glcd.c        ****   while (x <= y) {
 245:glcd.c        ****     if (color == ON) {
 246:glcd.c        ****       glcdSetDot(xcenter + x, ycenter + y);     glcdSetDot(xcenter + x, ycenter - y);
 247:glcd.c        ****       glcdSetDot(xcenter - x, ycenter + y);     glcdSetDot(xcenter - x, ycenter - y);
 248:glcd.c        ****       glcdSetDot(ycenter + y - d, ycenter + x); glcdSetDot(ycenter + y - d, ycenter - x);
 249:glcd.c        ****       glcdSetDot(ycenter - y - d, ycenter + x); glcdSetDot(ycenter - y - d, ycenter - x);
 250:glcd.c        ****     } else {
 251:glcd.c        ****       glcdClearDot(xcenter + x, ycenter + y);     glcdClearDot(xcenter + x, ycenter - y);
 252:glcd.c        ****       glcdClearDot(xcenter - x, ycenter + y);     glcdClearDot(xcenter - x, ycenter - y);
 253:glcd.c        ****       glcdClearDot(ycenter + y - d, ycenter + x); glcdClearDot(ycenter + y - d, ycenter - x);
 254:glcd.c        ****       glcdClearDot(ycenter - y - d, ycenter + x); glcdClearDot(ycenter - y - d, ycenter - x);
 255:glcd.c        ****     }
 256:glcd.c        ****     if (tswitch < 0) tswitch += (4 * x + 6);
 257:glcd.c        ****     else {
 258:glcd.c        ****       tswitch += (4 * (x - y) + 10);
 259:glcd.c        ****       y--;
 260:glcd.c        ****     }
 261:glcd.c        ****     x++;
 262:glcd.c        ****   }
 263:glcd.c        **** }*/
 264:glcd.c        **** 
 265:glcd.c        **** 
 266:glcd.c        **** // draw circle
 267:glcd.c        **** void glcdFillCircle(u08 xcenter, u08 ycenter, u08 radius, u08 color)
 268:glcd.c        **** {
 269:glcd.c        ****   int tswitch, y, x = 0;
 270:glcd.c        ****   unsigned char d;
 271:glcd.c        **** 
 272:glcd.c        ****   d = ycenter - xcenter;
 273:glcd.c        ****   y = radius;
 274:glcd.c        ****   tswitch = 3 - 2 * radius;
 275:glcd.c        ****   while (x <= y) {
 276:glcd.c        ****     glcdFillRectangle(xcenter + x, ycenter - y, 1, y*2, color);
 277:glcd.c        ****     glcdFillRectangle(xcenter - x, ycenter - y, 1, y*2, color);
 278:glcd.c        ****     glcdFillRectangle(ycenter + y - d, ycenter - x, 1, x*2, color);
 279:glcd.c        ****     glcdFillRectangle(ycenter - y - d, ycenter - x, 1, x*2, color);   
 280:glcd.c        ****     if (tswitch < 0) tswitch += (4 * x + 6);
 281:glcd.c        ****     else {
 282:glcd.c        ****       tswitch += (4 * (x - y) + 10);
 283:glcd.c        ****       y--;
 284:glcd.c        ****     }
 285:glcd.c        ****     x++;
 286:glcd.c        ****   }
 287:glcd.c        **** }
 288:glcd.c        **** 
 289:glcd.c        **** // text routines
 290:glcd.c        **** 
 291:glcd.c        **** // write a character at the current position
 292:glcd.c        **** void glcdWriteChar(unsigned char c, uint8_t inverted)
 293:glcd.c        **** {
 294:glcd.c        **** 	u08 i = 0, j;
 295:glcd.c        **** 
 296:glcd.c        **** 	for(i=0; i<5; i++)
 297:glcd.c        **** 	{
 298:glcd.c        **** 	  j = get_font(((c - 0x20) * 5) + i);
 299:glcd.c        **** 	  if (inverted)
 300:glcd.c        **** 	    j = ~j;
 301:glcd.c        **** 	  glcdDataWrite(j);
 302:glcd.c        **** 	}
 303:glcd.c        **** 
 304:glcd.c        **** 	// write a spacer line
 305:glcd.c        **** 	if (inverted) 
 306:glcd.c        **** 	  glcdDataWrite(0xFF);
 307:glcd.c        **** 	else 
 308:glcd.c        **** 	  glcdDataWrite(0x00);
 309:glcd.c        **** 	// unless we're at the end of the display
 310:glcd.c        **** 	//if(xx == 128)
 311:glcd.c        **** 	//	xx = 0;
 312:glcd.c        **** 	//else 
 313:glcd.c        **** 	//	glcdWriteData(0x00);
 314:glcd.c        **** 
 315:glcd.c        **** 	//cbi(GLCD_Control, GLCD_CS1);
 316:glcd.c        **** 	//cbi(GLCD_Control, GLCD_CS2);
 317:glcd.c        **** 	glcdStartLine(0);
 318:glcd.c        **** }
 319:glcd.c        **** 
 320:glcd.c        **** void glcdWriteCharGr(u08 grCharIdx, uint8_t inverted)
 321:glcd.c        **** {
 322:glcd.c        **** 	u08 idx;
 323:glcd.c        **** 	u08 grLength;
 324:glcd.c        **** 	u08 grStartIdx = 0;
 325:glcd.c        ****         u08 line;
 326:glcd.c        **** 
 327:glcd.c        **** 	// get starting index of graphic bitmap
 328:glcd.c        **** 	for(idx=0; idx<grCharIdx; idx++)
 329:glcd.c        **** 	{
 330:glcd.c        **** 		// add this graphic's length to the startIdx
 331:glcd.c        **** 		// to get the startIdx of the next one
 332:glcd.c        **** 		// 2010-03-03 BUG Dataman/CRJONES There's a bug here:  Have to add 1 for the byte-cout.
 333:glcd.c        **** 		// grStartIdx += pgm_read_byte(FontGr+grStartIdx);
 334:glcd.c        **** 		grStartIdx += pgm_read_byte(&FontGr[grStartIdx])+1;
 335:glcd.c        **** 		
 336:glcd.c        **** 	}
 337:glcd.c        **** 	grLength = pgm_read_byte(&FontGr[grStartIdx]);
 338:glcd.c        **** 
 339:glcd.c        **** 	// write the lines of the desired graphic to the display
 340:glcd.c        **** 	for(idx=0; idx<grLength; idx++)
 341:glcd.c        **** 	{
 342:glcd.c        **** 		// write the line
 343:glcd.c        ****                 line = pgm_read_byte(&FontGr[(grStartIdx+1)+idx]);
 344:glcd.c        ****                 if (inverted == INVERTED) line = 255-line;
 345:glcd.c        **** 		glcdDataWrite(line);
 346:glcd.c        **** 	}
 347:glcd.c        **** }
 348:glcd.c        **** 
 349:glcd.c        **** void glcdPutStr_ram(char *data, uint8_t inverted)
 350:glcd.c        **** {
 351:glcd.c        ****   while (*data) {
 352:glcd.c        ****     glcdWriteChar(*data, inverted);
 353:glcd.c        ****     data++;
 354:glcd.c        ****   }
 355:glcd.c        **** }
 356:glcd.c        **** 
 357:glcd.c        **** void glcdPutStr_rom(const char *data, uint8_t inverted)
 358:glcd.c        **** {
 359:glcd.c        **** 	uint8_t i,j;
 360:glcd.c        **** 
 361:glcd.c        **** 	for (i=0; pgm_read_byte(&data[i]); i++) {
 362:glcd.c        **** 		glcdWriteChar(pgm_read_byte(&data[i]),inverted);
 363:glcd.c        **** 	}
 364:glcd.c        **** }
 365:glcd.c        **** 
 366:glcd.c        **** uint8_t get_font(uint16_t addr)
 367:glcd.c        **** {
 131               	.LM0:
 132               	.LFBB1:
 133               	/* prologue: function */
 134               	/* frame size = 0 */
 368:glcd.c        **** 	return eeprom_read_byte(&Font5x7[addr]);
 136               	.LM1:
 137 0000 8050      		subi r24,lo8(-(Font5x7))
 138 0002 9040      		sbci r25,hi8(-(Font5x7))
 139 0004 0E94 0000 		call __eerd_byte_m328p
 140               	/* epilogue start */
 369:glcd.c        **** }
 142               	.LM2:
 143 0008 0895      		ret
 145               	.Lscope1:
 147               		.stabd	78,0,0
 151               	.global	glcdWriteCharGr
 153               	glcdWriteCharGr:
 154               		.stabd	46,0,0
 322:glcd.c        **** {
 156               	.LM3:
 157               	.LFBB2:
 158 000a FF92      		push r15
 159 000c 0F93      		push r16
 160 000e 1F93      		push r17
 161 0010 CF93      		push r28
 162 0012 DF93      		push r29
 163               	/* prologue: function */
 164               	/* frame size = 0 */
 165 0014 482F      		mov r20,r24
 166 0016 F62E      		mov r15,r22
 322:glcd.c        **** {
 168               	.LM4:
 169 0018 30E0      		ldi r19,lo8(0)
 170 001a 20E0      		ldi r18,lo8(0)
 171 001c 00C0      		rjmp .L4
 172               	.L5:
 173               	.LBB4:
 335:glcd.c        **** 		grStartIdx += pgm_read_byte(&FontGr[grStartIdx])+1;
 175               	.LM5:
 176 001e 8050      		subi r24,lo8(-(FontGr))
 177 0020 9040      		sbci r25,hi8(-(FontGr))
 178 0022 FC01      		movw r30,r24
 179               	/* #APP */
 180               	 ;  335 "glcd.c" 1
 181 0024 8491      		lpm r24, Z
 182               		
 183               	 ;  0 "" 2
 184               	/* #NOAPP */
 185               	.LBE4:
 186 0026 8F5F      		subi r24,lo8(-(1))
 187 0028 280F      		add r18,r24
 329:glcd.c        **** 	for(idx=0; idx<grCharIdx; idx++)
 189               	.LM6:
 190 002a 3F5F      		subi r19,lo8(-(1))
 191               	.L4:
 192 002c 822F      		mov r24,r18
 193 002e 90E0      		ldi r25,lo8(0)
 194 0030 3417      		cp r19,r20
 195 0032 00F0      		brlo .L5
 196               	.LBB5:
 338:glcd.c        **** 	grLength = pgm_read_byte(&FontGr[grStartIdx]);
 198               	.LM7:
 199 0034 FC01      		movw r30,r24
 200 0036 E050      		subi r30,lo8(-(FontGr))
 201 0038 F040      		sbci r31,hi8(-(FontGr))
 202               	/* #APP */
 203               	 ;  338 "glcd.c" 1
 204 003a 0491      		lpm r16, Z
 205               		
 206               	 ;  0 "" 2
 207               	/* #NOAPP */
 208 003c EC01      		movw r28,r24
 209 003e C050      		subi r28,lo8(-(FontGr+1))
 210 0040 D040      		sbci r29,hi8(-(FontGr+1))
 211 0042 10E0      		ldi r17,lo8(0)
 212 0044 00C0      		rjmp .L6
 213               	.L9:
 214               	.LBE5:
 215               	.LBB6:
 344:glcd.c        ****                 line = pgm_read_byte(&FontGr[(grStartIdx+1)+idx]);
 217               	.LM8:
 218 0046 FE01      		movw r30,r28
 219               	/* #APP */
 220               	 ;  344 "glcd.c" 1
 221 0048 8491      		lpm r24, Z
 222               		
 223               	 ;  0 "" 2
 224               	/* #NOAPP */
 225               	.LBE6:
 345:glcd.c        ****                 if (inverted == INVERTED) line = 255-line;
 227               	.LM9:
 228 004a F1E0      		ldi r31,lo8(1)
 229 004c FF16      		cp r15,r31
 230 004e 01F4      		brne .L8
 231 0050 8095      		com r24
 232               	.L8:
 346:glcd.c        **** 		glcdDataWrite(line);
 234               	.LM10:
 235 0052 0E94 0000 		call glcdDataWrite
 341:glcd.c        **** 	for(idx=0; idx<grLength; idx++)
 237               	.LM11:
 238 0056 1F5F      		subi r17,lo8(-(1))
 239 0058 2196      		adiw r28,1
 240               	.L6:
 241 005a 1017      		cp r17,r16
 242 005c 00F0      		brlo .L9
 243               	/* epilogue start */
 348:glcd.c        **** }
 245               	.LM12:
 246 005e DF91      		pop r29
 247 0060 CF91      		pop r28
 248 0062 1F91      		pop r17
 249 0064 0F91      		pop r16
 250 0066 FF90      		pop r15
 251 0068 0895      		ret
 267               	.Lscope2:
 269               		.stabd	78,0,0
 273               	.global	glcdWriteChar
 275               	glcdWriteChar:
 276               		.stabd	46,0,0
 294:glcd.c        **** {
 278               	.LM13:
 279               	.LFBB3:
 280 006a FF92      		push r15
 281 006c 0F93      		push r16
 282 006e 1F93      		push r17
 283 0070 CF93      		push r28
 284 0072 DF93      		push r29
 285               	/* prologue: function */
 286               	/* frame size = 0 */
 287 0074 F62E      		mov r15,r22
 299:glcd.c        **** 	  j = get_font(((c - 0x20) * 5) + i);
 289               	.LM14:
 290 0076 95E0      		ldi r25,lo8(5)
 291 0078 899F      		mul r24,r25
 292 007a C001      		movw r24,r0
 293 007c 1124      		clr r1
 294 007e EC01      		movw r28,r24
 295 0080 C050      		subi r28,lo8(-(Font5x7-160))
 296 0082 D040      		sbci r29,hi8(-(Font5x7-160))
 297:glcd.c        **** 	for(i=0; i<5; i++)
 298               	.LM15:
 299 0084 8C01      		movw r16,r24
 300 0086 0050      		subi r16,lo8(-(Font5x7-155))
 301 0088 1040      		sbci r17,hi8(-(Font5x7-155))
 302               	.L13:
 303               	.LBB7:
 369:glcd.c        **** 	return eeprom_read_byte(&Font5x7[addr]);
 305               	.LM16:
 306 008a CE01      		movw r24,r28
 307 008c 0E94 0000 		call __eerd_byte_m328p
 308               	.LBE7:
 300:glcd.c        **** 	  if (inverted)
 310               	.LM17:
 311 0090 F110      		cpse r15,__zero_reg__
 301:glcd.c        **** 	    j = ~j;
 313               	.LM18:
 314 0092 8095      		com r24
 315               	.L12:
 302:glcd.c        **** 	  glcdDataWrite(j);
 317               	.LM19:
 318 0094 0E94 0000 		call glcdDataWrite
 319 0098 2196      		adiw r28,1
 297:glcd.c        **** 	for(i=0; i<5; i++)
 321               	.LM20:
 322 009a C017      		cp r28,r16
 323 009c D107      		cpc r29,r17
 324 009e 01F4      		brne .L13
 306:glcd.c        **** 	if (inverted) 
 326               	.LM21:
 327 00a0 FF20      		tst r15
 328 00a2 01F0      		breq .L14
 307:glcd.c        **** 	  glcdDataWrite(0xFF);
 330               	.LM22:
 331 00a4 8FEF      		ldi r24,lo8(-1)
 332 00a6 00C0      		rjmp .L18
 333               	.L14:
 309:glcd.c        **** 	  glcdDataWrite(0x00);
 335               	.LM23:
 336 00a8 80E0      		ldi r24,lo8(0)
 337               	.L18:
 338 00aa 0E94 0000 		call glcdDataWrite
 318:glcd.c        **** 	glcdStartLine(0);
 340               	.LM24:
 341 00ae 80E0      		ldi r24,lo8(0)
 342 00b0 0E94 0000 		call glcdStartLine
 343               	/* epilogue start */
 319:glcd.c        **** }
 345               	.LM25:
 346 00b4 DF91      		pop r29
 347 00b6 CF91      		pop r28
 348 00b8 1F91      		pop r17
 349 00ba 0F91      		pop r16
 350 00bc FF90      		pop r15
 351 00be 0895      		ret
 356               	.Lscope3:
 358               		.stabd	78,0,0
 362               	.global	glcdPutStr_rom
 364               	glcdPutStr_rom:
 365               		.stabd	46,0,0
 359:glcd.c        **** {
 367               	.LM26:
 368               	.LFBB4:
 369 00c0 0F93      		push r16
 370 00c2 1F93      		push r17
 371 00c4 CF93      		push r28
 372 00c6 DF93      		push r29
 373               	/* prologue: function */
 374               	/* frame size = 0 */
 375 00c8 EC01      		movw r28,r24
 376 00ca 062F      		mov r16,r22
 359:glcd.c        **** {
 378               	.LM27:
 379 00cc 10E0      		ldi r17,lo8(0)
 380 00ce 00C0      		rjmp .L20
 381               	.L21:
 363:glcd.c        **** 		glcdWriteChar(pgm_read_byte(&data[i]),inverted);
 383               	.LM28:
 384 00d0 602F      		mov r22,r16
 385 00d2 0E94 0000 		call glcdWriteChar
 362:glcd.c        **** 	for (i=0; pgm_read_byte(&data[i]); i++) {
 387               	.LM29:
 388 00d6 1F5F      		subi r17,lo8(-(1))
 389               	.L20:
 390               	.LBB8:
 391 00d8 FE01      		movw r30,r28
 392 00da E10F      		add r30,r17
 393 00dc F11D      		adc r31,__zero_reg__
 394               	/* #APP */
 395               	 ;  362 "glcd.c" 1
 396 00de 8491      		lpm r24, Z
 397               		
 398               	 ;  0 "" 2
 399               	/* #NOAPP */
 400               	.LBE8:
 401 00e0 8823      		tst r24
 402 00e2 01F4      		brne .L21
 403               	/* epilogue start */
 365:glcd.c        **** }
 405               	.LM30:
 406 00e4 DF91      		pop r29
 407 00e6 CF91      		pop r28
 408 00e8 1F91      		pop r17
 409 00ea 0F91      		pop r16
 410 00ec 0895      		ret
 419               	.Lscope4:
 421               		.stabd	78,0,0
 425               	.global	glcdPutStr_ram
 427               	glcdPutStr_ram:
 428               		.stabd	46,0,0
 351:glcd.c        **** {
 430               	.LM31:
 431               	.LFBB5:
 432 00ee 1F93      		push r17
 433 00f0 CF93      		push r28
 434 00f2 DF93      		push r29
 435               	/* prologue: function */
 436               	/* frame size = 0 */
 437 00f4 EC01      		movw r28,r24
 438 00f6 162F      		mov r17,r22
 439 00f8 00C0      		rjmp .L24
 440               	.L25:
 353:glcd.c        ****     glcdWriteChar(*data, inverted);
 442               	.LM32:
 443 00fa 612F      		mov r22,r17
 444 00fc 0E94 0000 		call glcdWriteChar
 354:glcd.c        ****     data++;
 446               	.LM33:
 447 0100 2196      		adiw r28,1
 448               	.L24:
 352:glcd.c        ****   while (*data) {
 450               	.LM34:
 451 0102 8881      		ld r24,Y
 452 0104 8823      		tst r24
 453 0106 01F4      		brne .L25
 454               	/* epilogue start */
 356:glcd.c        **** }
 456               	.LM35:
 457 0108 DF91      		pop r29
 458 010a CF91      		pop r28
 459 010c 1F91      		pop r17
 460 010e 0895      		ret
 462               	.Lscope5:
 464               		.stabd	78,0,0
 471               	.global	glcdFillRectangle
 473               	glcdFillRectangle:
 474               		.stabd	46,0,0
 107:glcd.c        **** {
 476               	.LM36:
 477               	.LFBB6:
 478 0110 2F92      		push r2
 479 0112 3F92      		push r3
 480 0114 4F92      		push r4
 481 0116 5F92      		push r5
 482 0118 6F92      		push r6
 483 011a 7F92      		push r7
 484 011c 8F92      		push r8
 485 011e 9F92      		push r9
 486 0120 AF92      		push r10
 487 0122 BF92      		push r11
 488 0124 CF92      		push r12
 489 0126 DF92      		push r13
 490 0128 EF92      		push r14
 491 012a FF92      		push r15
 492 012c 0F93      		push r16
 493 012e 1F93      		push r17
 494 0130 CF93      		push r28
 495 0132 DF93      		push r29
 496               	/* prologue: function */
 497               	/* frame size = 0 */
 498 0134 282E      		mov r2,r24
 499 0136 162F      		mov r17,r22
 500 0138 342E      		mov r3,r20
 501 013a F22E      		mov r15,r18
 502 013c 402E      		mov r4,r16
 180:glcd.c        ****   if (y%8) {
 504               	.LM37:
 505 013e C62F      		mov r28,r22
 506 0140 D0E0      		ldi r29,lo8(0)
 507 0142 C770      		andi r28,lo8(7)
 508 0144 D070      		andi r29,hi8(7)
 509 0146 2097      		sbiw r28,0
 510 0148 01F4      		brne .+2
 511 014a 00C0      		rjmp .L28
 182:glcd.c        ****       glcdSetAddress(x+i, y/8);
 513               	.LM38:
 514 014c 562E      		mov r5,r22
 515 014e 5694      		lsr r5
 516 0150 5694      		lsr r5
 517 0152 5694      		lsr r5
 518 0154 EE24      		clr r14
 186:glcd.c        ****       for (k=(y%8); k < (y%8)+b && (k<8); k++) {
 520               	.LM39:
 521 0156 37E0      		ldi r19,lo8(7)
 522 0158 C32E      		mov r12,r19
 523 015a C622      		and r12,r22
 190:glcd.c        **** 	  temp &= ~_BV(k);
 525               	.LM40:
 526 015c 8C2C      		mov r8,r12
 527 015e 9924      		clr r9
 528 0160 87FC      		sbrc r8,7
 529 0162 9094      		com r9
 186:glcd.c        ****       for (k=(y%8); k < (y%8)+b && (k<8); k++) {
 531               	.LM41:
 532 0164 5E01      		movw r10,r28
 533 0166 A20E      		add r10,r18
 534 0168 B11C      		adc r11,__zero_reg__
 190:glcd.c        **** 	  temp &= ~_BV(k);
 536               	.LM42:
 537 016a 21E0      		ldi r18,lo8(1)
 538 016c 622E      		mov r6,r18
 539 016e 712C      		mov r7,__zero_reg__
 540 0170 00C0      		rjmp .L29
 541               	.L35:
 182:glcd.c        ****       glcdSetAddress(x+i, y/8);
 543               	.LM43:
 544 0172 DE2C      		mov r13,r14
 545 0174 D20C      		add r13,r2
 546 0176 8D2D      		mov r24,r13
 547 0178 652D      		mov r22,r5
 548 017a 0E94 0000 		call glcdSetAddress
 183:glcd.c        ****       temp = glcdDataRead();	// dummy read
 550               	.LM44:
 551 017e 0E94 0000 		call glcdDataRead
 184:glcd.c        ****       temp = glcdDataRead();	// read back current value
 553               	.LM45:
 554 0182 0E94 0000 		call glcdDataRead
 555 0186 082F      		mov r16,r24
 186:glcd.c        ****       for (k=(y%8); k < (y%8)+b && (k<8); k++) {
 557               	.LM46:
 558 0188 40E0      		ldi r20,lo8(0)
 559 018a 50E0      		ldi r21,hi8(0)
 560 018c 00C0      		rjmp .L30
 561               	.L34:
 187:glcd.c        **** 	if (color == ON)
 563               	.LM47:
 564 018e 81E0      		ldi r24,lo8(1)
 565 0190 4816      		cp r4,r24
 566 0192 01F4      		brne .L31
 188:glcd.c        **** 	  temp |= _BV(k);
 568               	.LM48:
 569 0194 C301      		movw r24,r6
 570 0196 00C0      		rjmp 2f
 571 0198 880F      	1:	lsl r24
 572 019a 991F      		rol r25
 573 019c 2A95      	2:	dec r18
 574 019e 02F4      		brpl 1b
 575 01a0 082B      		or r16,r24
 576 01a2 00C0      		rjmp .L32
 577               	.L31:
 190:glcd.c        **** 	  temp &= ~_BV(k);
 579               	.LM49:
 580 01a4 C301      		movw r24,r6
 581 01a6 00C0      		rjmp 2f
 582 01a8 880F      	1:	lsl r24
 583 01aa 991F      		rol r25
 584 01ac 2A95      	2:	dec r18
 585 01ae 02F4      		brpl 1b
 586 01b0 8095      		com r24
 587 01b2 0823      		and r16,r24
 588               	.L32:
 589 01b4 4F5F      		subi r20,lo8(-(1))
 590 01b6 5F4F      		sbci r21,hi8(-(1))
 591               	.L30:
 592 01b8 9A01      		movw r18,r20
 593 01ba 280D      		add r18,r8
 594 01bc 391D      		adc r19,r9
 186:glcd.c        ****       for (k=(y%8); k < (y%8)+b && (k<8); k++) {
 596               	.LM50:
 597 01be 2A15      		cp r18,r10
 598 01c0 3B05      		cpc r19,r11
 599 01c2 04F4      		brge .L33
 600 01c4 8C2D      		mov r24,r12
 601 01c6 840F      		add r24,r20
 602 01c8 8830      		cpi r24,lo8(8)
 603 01ca 01F4      		brne .L34
 604               	.L33:
 192:glcd.c        ****       glcdSetAddress(x+i, y/8);
 606               	.LM51:
 607 01cc 8D2D      		mov r24,r13
 608 01ce 652D      		mov r22,r5
 609 01d0 0E94 0000 		call glcdSetAddress
 193:glcd.c        ****       glcdDataWrite(temp);
 611               	.LM52:
 612 01d4 802F      		mov r24,r16
 613 01d6 0E94 0000 		call glcdDataWrite
 181:glcd.c        ****     for (i=0; i<a; i++) {
 615               	.LM53:
 616 01da E394      		inc r14
 617               	.L29:
 618 01dc E314      		cp r14,r3
 619 01de 00F0      		brlo .L35
 197:glcd.c        ****     if (b > 8-(y%8))
 621               	.LM54:
 622 01e0 2F2D      		mov r18,r15
 623 01e2 30E0      		ldi r19,lo8(0)
 624 01e4 88E0      		ldi r24,lo8(8)
 625 01e6 90E0      		ldi r25,hi8(8)
 626 01e8 8C1B      		sub r24,r28
 627 01ea 9D0B      		sbc r25,r29
 628 01ec 8217      		cp r24,r18
 629 01ee 9307      		cpc r25,r19
 630 01f0 04F0      		brlt .L36
 631 01f2 FF24      		clr r15
 632 01f4 00C0      		rjmp .L37
 633               	.L36:
 198:glcd.c        ****       b -= 8-(y%8);
 635               	.LM55:
 636 01f6 812F      		mov r24,r17
 637 01f8 8770      		andi r24,lo8(7)
 638 01fa 8850      		subi r24,lo8(-(-8))
 639 01fc F80E      		add r15,r24
 640               	.L37:
 201:glcd.c        ****     y -= (y%8);
 642               	.LM56:
 643 01fe 187F      		andi r17,lo8(-8)
 202:glcd.c        ****     y+=8;
 645               	.LM57:
 646 0200 185F      		subi r17,lo8(-(8))
 647               	.L28:
 205:glcd.c        ****   for (j=(y/8); j < (y+b)/8; j++) {
 649               	.LM58:
 650 0202 E12E      		mov r14,r17
 651 0204 E694      		lsr r14
 652 0206 E694      		lsr r14
 653 0208 E694      		lsr r14
 654 020a C12F      		mov r28,r17
 655 020c D0E0      		ldi r29,lo8(0)
 656 020e CF0D      		add r28,r15
 657 0210 D11D      		adc r29,__zero_reg__
 658 0212 93E0      		ldi r25,3
 659 0214 D595      	1:	asr r29
 660 0216 C795      		ror r28
 661 0218 9A95      		dec r25
 662 021a 01F4      		brne 1b
 663 021c 00C0      		rjmp .L38
 664               	.L43:
 206:glcd.c        ****     glcdSetAddress(x, j);
 666               	.LM59:
 667 021e 822D      		mov r24,r2
 668 0220 6E2D      		mov r22,r14
 669 0222 0E94 0000 		call glcdSetAddress
 670 0226 10E0      		ldi r17,lo8(0)
 671 0228 00C0      		rjmp .L39
 672               	.L42:
 208:glcd.c        ****       if (color == ON)
 674               	.LM60:
 675 022a 81E0      		ldi r24,lo8(1)
 676 022c 4816      		cp r4,r24
 677 022e 01F4      		brne .L40
 209:glcd.c        **** 	glcdDataWrite(0xFF);
 679               	.LM61:
 680 0230 8FEF      		ldi r24,lo8(-1)
 681 0232 00C0      		rjmp .L52
 682               	.L40:
 211:glcd.c        **** 	glcdDataWrite(0x00);
 684               	.LM62:
 685 0234 80E0      		ldi r24,lo8(0)
 686               	.L52:
 687 0236 0E94 0000 		call glcdDataWrite
 207:glcd.c        ****     for (i=0; i<a; i++) {
 689               	.LM63:
 690 023a 1F5F      		subi r17,lo8(-(1))
 691               	.L39:
 692 023c 1315      		cp r17,r3
 693 023e 00F0      		brlo .L42
 205:glcd.c        ****   for (j=(y/8); j < (y+b)/8; j++) {
 695               	.LM64:
 696 0240 E394      		inc r14
 697               	.L38:
 698 0242 8E2D      		mov r24,r14
 699 0244 90E0      		ldi r25,lo8(0)
 700 0246 8C17      		cp r24,r28
 701 0248 9D07      		cpc r25,r29
 702 024a 04F0      		brlt .L43
 214:glcd.c        ****   b = b%8;
 704               	.LM65:
 705 024c 2F2D      		mov r18,r15
 706 024e 2770      		andi r18,lo8(7)
 216:glcd.c        ****   if (b) {
 708               	.LM66:
 709 0250 01F0      		breq .L44
 710 0252 00E0      		ldi r16,lo8(0)
 222:glcd.c        ****       for (k=0; k < b; k++) {
 712               	.LM67:
 713 0254 C22F      		mov r28,r18
 714 0256 D0E0      		ldi r29,lo8(0)
 226:glcd.c        **** 	  temp &= ~_BV(k);
 716               	.LM68:
 717 0258 81E0      		ldi r24,lo8(1)
 718 025a A82E      		mov r10,r24
 719 025c B12C      		mov r11,__zero_reg__
 720 025e 00C0      		rjmp .L45
 721               	.L50:
 216:glcd.c        ****   if (b) {
 723               	.LM69:
 724 0260 F02E      		mov r15,r16
 725 0262 F20C      		add r15,r2
 218:glcd.c        ****       glcdSetAddress(x+i, j);
 727               	.LM70:
 728 0264 8F2D      		mov r24,r15
 729 0266 6E2D      		mov r22,r14
 730 0268 0E94 0000 		call glcdSetAddress
 219:glcd.c        ****       temp = glcdDataRead();	// dummy read
 732               	.LM71:
 733 026c 0E94 0000 		call glcdDataRead
 220:glcd.c        ****       temp = glcdDataRead();	// read back current value
 735               	.LM72:
 736 0270 0E94 0000 		call glcdDataRead
 737 0274 182F      		mov r17,r24
 738 0276 20E0      		ldi r18,lo8(0)
 739 0278 30E0      		ldi r19,hi8(0)
 740 027a 00C0      		rjmp .L46
 741               	.L49:
 223:glcd.c        **** 	if (color == ON)
 743               	.LM73:
 744 027c 81E0      		ldi r24,lo8(1)
 745 027e 4816      		cp r4,r24
 746 0280 01F4      		brne .L47
 224:glcd.c        **** 	  temp |= _BV(k);
 748               	.LM74:
 749 0282 C501      		movw r24,r10
 750 0284 022E      		mov r0,r18
 751 0286 00C0      		rjmp 2f
 752 0288 880F      	1:	lsl r24
 753 028a 991F      		rol r25
 754 028c 0A94      	2:	dec r0
 755 028e 02F4      		brpl 1b
 756 0290 182B      		or r17,r24
 757 0292 00C0      		rjmp .L48
 758               	.L47:
 226:glcd.c        **** 	  temp &= ~_BV(k);
 760               	.LM75:
 761 0294 C501      		movw r24,r10
 762 0296 022E      		mov r0,r18
 763 0298 00C0      		rjmp 2f
 764 029a 880F      	1:	lsl r24
 765 029c 991F      		rol r25
 766 029e 0A94      	2:	dec r0
 767 02a0 02F4      		brpl 1b
 768 02a2 8095      		com r24
 769 02a4 1823      		and r17,r24
 770               	.L48:
 771 02a6 2F5F      		subi r18,lo8(-(1))
 772 02a8 3F4F      		sbci r19,hi8(-(1))
 773               	.L46:
 222:glcd.c        ****       for (k=0; k < b; k++) {
 775               	.LM76:
 776 02aa 2C17      		cp r18,r28
 777 02ac 3D07      		cpc r19,r29
 778 02ae 04F0      		brlt .L49
 228:glcd.c        ****       glcdSetAddress(x+i, j);
 780               	.LM77:
 781 02b0 8F2D      		mov r24,r15
 782 02b2 6E2D      		mov r22,r14
 783 02b4 0E94 0000 		call glcdSetAddress
 229:glcd.c        ****       glcdDataWrite(temp);
 785               	.LM78:
 786 02b8 812F      		mov r24,r17
 787 02ba 0E94 0000 		call glcdDataWrite
 217:glcd.c        ****     for (i=0; i<a; i++) {
 789               	.LM79:
 790 02be 0F5F      		subi r16,lo8(-(1))
 791               	.L45:
 792 02c0 0315      		cp r16,r3
 793 02c2 00F0      		brlo .L50
 794               	.L44:
 232:glcd.c        ****   glcdStartLine(0);
 796               	.LM80:
 797 02c4 80E0      		ldi r24,lo8(0)
 798 02c6 0E94 0000 		call glcdStartLine
 799               	/* epilogue start */
 233:glcd.c        **** }
 801               	.LM81:
 802 02ca DF91      		pop r29
 803 02cc CF91      		pop r28
 804 02ce 1F91      		pop r17
 805 02d0 0F91      		pop r16
 806 02d2 FF90      		pop r15
 807 02d4 EF90      		pop r14
 808 02d6 DF90      		pop r13
 809 02d8 CF90      		pop r12
 810 02da BF90      		pop r11
 811 02dc AF90      		pop r10
 812 02de 9F90      		pop r9
 813 02e0 8F90      		pop r8
 814 02e2 7F90      		pop r7
 815 02e4 6F90      		pop r6
 816 02e6 5F90      		pop r5
 817 02e8 4F90      		pop r4
 818 02ea 3F90      		pop r3
 819 02ec 2F90      		pop r2
 820 02ee 0895      		ret
 827               	.Lscope6:
 829               		.stabd	78,0,0
 835               	.global	glcdFillCircle
 837               	glcdFillCircle:
 838               		.stabd	46,0,0
 269:glcd.c        **** {
 840               	.LM82:
 841               	.LFBB7:
 842 02f0 2F92      		push r2
 843 02f2 3F92      		push r3
 844 02f4 4F92      		push r4
 845 02f6 5F92      		push r5
 846 02f8 6F92      		push r6
 847 02fa 7F92      		push r7
 848 02fc 8F92      		push r8
 849 02fe 9F92      		push r9
 850 0300 AF92      		push r10
 851 0302 BF92      		push r11
 852 0304 CF92      		push r12
 853 0306 DF92      		push r13
 854 0308 EF92      		push r14
 855 030a FF92      		push r15
 856 030c 0F93      		push r16
 857 030e 1F93      		push r17
 858 0310 DF93      		push r29
 859 0312 CF93      		push r28
 860 0314 00D0      		rcall .
 861 0316 0F92      		push __tmp_reg__
 862 0318 CDB7      		in r28,__SP_L__
 863 031a DEB7      		in r29,__SP_H__
 864               	/* prologue: function */
 865               	/* frame size = 3 */
 866 031c 382E      		mov r3,r24
 867 031e 462E      		mov r4,r22
 868 0320 522E      		mov r5,r18
 273:glcd.c        ****   d = ycenter - xcenter;
 870               	.LM83:
 871 0322 262E      		mov r2,r22
 872 0324 281A      		sub r2,r24
 274:glcd.c        ****   y = radius;
 874               	.LM84:
 875 0326 A42E      		mov r10,r20
 876 0328 BB24      		clr r11
 275:glcd.c        ****   tswitch = 3 - 2 * radius;
 878               	.LM85:
 879 032a C501      		movw r24,r10
 880 032c 880F      		lsl r24
 881 032e 991F      		rol r25
 882 0330 2227      		clr r18
 883 0332 3327      		clr r19
 884 0334 281B      		sub r18,r24
 885 0336 390B      		sbc r19,r25
 886 0338 2D5F      		subi r18,lo8(-(3))
 887 033a 3F4F      		sbci r19,hi8(-(3))
 888 033c 3B83      		std Y+3,r19
 889 033e 2A83      		std Y+2,r18
 890 0340 8824      		clr r8
 891 0342 9924      		clr r9
 892 0344 6624      		clr r6
 893 0346 7724      		clr r7
 279:glcd.c        ****     glcdFillRectangle(ycenter + y - d, ycenter - x, 1, x*2, color);
 895               	.LM86:
 896 0348 342D      		mov r19,r4
 897 034a 3219      		sub r19,r2
 898 034c 3983      		std Y+1,r19
 899               	.L56:
 269:glcd.c        **** {
 901               	.LM87:
 902 034e 182D      		mov r17,r8
 277:glcd.c        ****     glcdFillRectangle(xcenter + x, ycenter - y, 1, y*2, color);
 904               	.LM88:
 905 0350 D42C      		mov r13,r4
 906 0352 DA18      		sub r13,r10
 907 0354 7501      		movw r14,r10
 908 0356 EE0C      		lsl r14
 909 0358 FF1C      		rol r15
 910 035a 882D      		mov r24,r8
 911 035c 830D      		add r24,r3
 912 035e 6D2D      		mov r22,r13
 913 0360 41E0      		ldi r20,lo8(1)
 914 0362 2E2D      		mov r18,r14
 915 0364 052D      		mov r16,r5
 916 0366 0E94 0000 		call glcdFillRectangle
 278:glcd.c        ****     glcdFillRectangle(xcenter - x, ycenter - y, 1, y*2, color);
 918               	.LM89:
 919 036a 832D      		mov r24,r3
 920 036c 8819      		sub r24,r8
 921 036e 6D2D      		mov r22,r13
 922 0370 41E0      		ldi r20,lo8(1)
 923 0372 2E2D      		mov r18,r14
 924 0374 0E94 0000 		call glcdFillRectangle
 925 0378 F42C      		mov r15,r4
 926 037a F818      		sub r15,r8
 927 037c 110F      		lsl r17
 279:glcd.c        ****     glcdFillRectangle(ycenter + y - d, ycenter - x, 1, x*2, color);
 929               	.LM90:
 930 037e 8981      		ldd r24,Y+1
 931 0380 8A0D      		add r24,r10
 932 0382 6F2D      		mov r22,r15
 933 0384 41E0      		ldi r20,lo8(1)
 934 0386 212F      		mov r18,r17
 935 0388 0E94 0000 		call glcdFillRectangle
 280:glcd.c        ****     glcdFillRectangle(ycenter - y - d, ycenter - x, 1, x*2, color);   
 937               	.LM91:
 938 038c 8D2D      		mov r24,r13
 939 038e 8219      		sub r24,r2
 940 0390 6F2D      		mov r22,r15
 941 0392 41E0      		ldi r20,lo8(1)
 942 0394 212F      		mov r18,r17
 943 0396 0E94 0000 		call glcdFillRectangle
 281:glcd.c        ****     if (tswitch < 0) tswitch += (4 * x + 6);
 945               	.LM92:
 946 039a 8A81      		ldd r24,Y+2
 947 039c 9B81      		ldd r25,Y+3
 948 039e 97FF      		sbrs r25,7
 949 03a0 00C0      		rjmp .L54
 950 03a2 0696      		adiw r24,6
 951 03a4 860D      		add r24,r6
 952 03a6 971D      		adc r25,r7
 953 03a8 9B83      		std Y+3,r25
 954 03aa 8A83      		std Y+2,r24
 955 03ac 00C0      		rjmp .L55
 956               	.L54:
 283:glcd.c        ****       tswitch += (4 * (x - y) + 10);
 958               	.LM93:
 959 03ae EA81      		ldd r30,Y+2
 960 03b0 FB81      		ldd r31,Y+3
 961 03b2 3A96      		adiw r30,10
 962 03b4 C401      		movw r24,r8
 963 03b6 8A19      		sub r24,r10
 964 03b8 9B09      		sbc r25,r11
 965 03ba 880F      		lsl r24
 966 03bc 991F      		rol r25
 967 03be 880F      		lsl r24
 968 03c0 991F      		rol r25
 969 03c2 E80F      		add r30,r24
 970 03c4 F91F      		adc r31,r25
 971 03c6 FB83      		std Y+3,r31
 972 03c8 EA83      		std Y+2,r30
 284:glcd.c        ****       y--;
 974               	.LM94:
 975 03ca 0894      		sec
 976 03cc A108      		sbc r10,__zero_reg__
 977 03ce B108      		sbc r11,__zero_reg__
 978               	.L55:
 286:glcd.c        ****     x++;
 980               	.LM95:
 981 03d0 0894      		sec
 982 03d2 811C      		adc r8,__zero_reg__
 983 03d4 911C      		adc r9,__zero_reg__
 984 03d6 24E0      		ldi r18,lo8(4)
 985 03d8 30E0      		ldi r19,hi8(4)
 986 03da 620E      		add r6,r18
 987 03dc 731E      		adc r7,r19
 276:glcd.c        ****   while (x <= y) {
 989               	.LM96:
 990 03de A814      		cp r10,r8
 991 03e0 B904      		cpc r11,r9
 992 03e2 04F0      		brlt .+2
 993 03e4 00C0      		rjmp .L56
 994               	/* epilogue start */
 288:glcd.c        **** }
 996               	.LM97:
 997 03e6 0F90      		pop __tmp_reg__
 998 03e8 0F90      		pop __tmp_reg__
 999 03ea 0F90      		pop __tmp_reg__
 1000 03ec CF91      		pop r28
 1001 03ee DF91      		pop r29
 1002 03f0 1F91      		pop r17
 1003 03f2 0F91      		pop r16
 1004 03f4 FF90      		pop r15
 1005 03f6 EF90      		pop r14
 1006 03f8 DF90      		pop r13
 1007 03fa CF90      		pop r12
 1008 03fc BF90      		pop r11
 1009 03fe AF90      		pop r10
 1010 0400 9F90      		pop r9
 1011 0402 8F90      		pop r8
 1012 0404 7F90      		pop r7
 1013 0406 6F90      		pop r6
 1014 0408 5F90      		pop r5
 1015 040a 4F90      		pop r4
 1016 040c 3F90      		pop r3
 1017 040e 2F90      		pop r2
 1018 0410 0895      		ret
 1026               	.Lscope7:
 1028               		.stabd	78,0,0
 1032               	.global	glcdSetDot
 1034               	glcdSetDot:
 1035               		.stabd	46,0,0
  46:glcd.c        **** {
 1037               	.LM98:
 1038               	.LFBB8:
 1039 0412 EF92      		push r14
 1040 0414 FF92      		push r15
 1041 0416 0F93      		push r16
 1042 0418 1F93      		push r17
 1043               	/* prologue: function */
 1044               	/* frame size = 0 */
 1045 041a F82E      		mov r15,r24
 1046 041c 162F      		mov r17,r22
  53:glcd.c        **** 	glcdSetAddress(x, y/8);
 1048               	.LM99:
 1049 041e 062F      		mov r16,r22
 1050 0420 0695      		lsr r16
 1051 0422 0695      		lsr r16
 1052 0424 0695      		lsr r16
 1053 0426 602F      		mov r22,r16
 1054 0428 0E94 0000 		call glcdSetAddress
  54:glcd.c        **** 	temp = glcdDataRead();	// dummy read
 1056               	.LM100:
 1057 042c 0E94 0000 		call glcdDataRead
  55:glcd.c        **** 	temp = glcdDataRead();	// read back current value
 1059               	.LM101:
 1060 0430 0E94 0000 		call glcdDataRead
 1061 0434 E82E      		mov r14,r24
  56:glcd.c        **** 	glcdSetAddress(x, y/8);
 1063               	.LM102:
 1064 0436 8F2D      		mov r24,r15
 1065 0438 602F      		mov r22,r16
 1066 043a 0E94 0000 		call glcdSetAddress
  57:glcd.c        **** 	glcdDataWrite(temp | (1 << (y % 8)));
 1068               	.LM103:
 1069 043e 1770      		andi r17,lo8(7)
 1070 0440 81E0      		ldi r24,lo8(1)
 1071 0442 90E0      		ldi r25,hi8(1)
 1072 0444 00C0      		rjmp 2f
 1073 0446 880F      	1:	lsl r24
 1074 0448 991F      		rol r25
 1075 044a 1A95      	2:	dec r17
 1076 044c 02F4      		brpl 1b
 1077 044e 8E29      		or r24,r14
 1078 0450 0E94 0000 		call glcdDataWrite
  58:glcd.c        **** 	glcdStartLine(0);
 1080               	.LM104:
 1081 0454 80E0      		ldi r24,lo8(0)
 1082 0456 0E94 0000 		call glcdStartLine
 1083               	/* epilogue start */
  59:glcd.c        **** }
 1085               	.LM105:
 1086 045a 1F91      		pop r17
 1087 045c 0F91      		pop r16
 1088 045e FF90      		pop r15
 1089 0460 EF90      		pop r14
 1090 0462 0895      		ret
 1095               	.Lscope8:
 1097               		.stabd	78,0,0
 1099               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 glcd.c
     /tmp/ccKnBI3h.s:2      *ABS*:0000003f __SREG__
     /tmp/ccKnBI3h.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccKnBI3h.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccKnBI3h.s:5      *ABS*:00000034 __CCP__
     /tmp/ccKnBI3h.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccKnBI3h.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccKnBI3h.s:128    .text:00000000 get_font
     /tmp/ccKnBI3h.s:153    .text:0000000a glcdWriteCharGr
     /tmp/ccKnBI3h.s:275    .text:0000006a glcdWriteChar
     /tmp/ccKnBI3h.s:364    .text:000000c0 glcdPutStr_rom
     /tmp/ccKnBI3h.s:427    .text:000000ee glcdPutStr_ram
     /tmp/ccKnBI3h.s:473    .text:00000110 glcdFillRectangle
     /tmp/ccKnBI3h.s:837    .text:000002f0 glcdFillCircle
     /tmp/ccKnBI3h.s:1034   .text:00000412 glcdSetDot

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
Font5x7
__eerd_byte_m328p
FontGr
glcdDataWrite
glcdStartLine
glcdSetAddress
glcdDataRead
