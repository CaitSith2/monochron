   1               		.file	"ratt.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  12               		.text
  13               	.Ltext0:
 141               	.global	__vector_18
 143               	__vector_18:
 144               		.stabd	46,0,0
   0:ratt.c        **** #include <avr/io.h>      // this contains all the IO port definitions
   1:ratt.c        **** #include <avr/interrupt.h>
   2:ratt.c        **** #include <util/delay.h>
   3:ratt.c        **** #include <avr/pgmspace.h>
   4:ratt.c        **** #include <avr/eeprom.h>
   5:ratt.c        **** #include <avr/wdt.h>
   6:ratt.c        **** #include <string.h>
   7:ratt.c        **** #include <i2c.h>
   8:ratt.c        **** #include <stdlib.h>
   9:ratt.c        **** #include "util.h"
  10:ratt.c        **** #include "ratt.h"
  11:ratt.c        **** #include "ks0108.h"
  12:ratt.c        **** #include "glcd.h"
  13:ratt.c        **** #include "dispatch.h"
  14:ratt.c        **** 
  15:ratt.c        **** 
  16:ratt.c        **** volatile uint8_t time_s, time_m, time_h;
  17:ratt.c        **** volatile uint8_t old_h, old_m, old_s;
  18:ratt.c        **** volatile uint8_t timeunknown = 1;
  19:ratt.c        **** volatile uint8_t date_m, date_d, date_y;
  20:ratt.c        **** volatile uint8_t alarming, alarm_on, alarm_tripped, alarm_h, alarm_m;
  21:ratt.c        **** volatile uint8_t displaymode;
  22:ratt.c        **** volatile uint8_t volume;
  23:ratt.c        **** volatile uint8_t sleepmode = 0;
  24:ratt.c        **** volatile uint8_t region;
  25:ratt.c        **** volatile uint8_t time_format;
  26:ratt.c        **** extern volatile uint8_t screenmutex;
  27:ratt.c        **** volatile uint8_t minute_changed = 0, hour_changed = 0, second_changed = 0;
  28:ratt.c        **** volatile uint8_t score_mode_timeout = 0;
  29:ratt.c        **** volatile uint8_t score_mode = SCORE_MODE_TIME;
  30:ratt.c        **** volatile uint8_t last_score_mode;
  31:ratt.c        **** volatile uint8_t displaystyle; //dataman - add access to displaystyle, enables MultiChron
  32:ratt.c        **** volatile uint8_t RotateFlag;   //dataman - enables display rotation
  33:ratt.c        **** 
  34:ratt.c        **** #ifdef GPSENABLE
  35:ratt.c        **** volatile uint8_t gpsenable=0;    //dataman - enables gps check
  36:ratt.c        **** volatile int8_t timezone=0;     //timezone +/- gmt
  37:ratt.c        **** volatile int8_t timezonehour=0, timezonemin=0;
  38:ratt.c        **** 
  39:ratt.c        **** #define RX_BUFFER_SIZE 128
  40:ratt.c        **** 
  41:ratt.c        **** struct ring_buffer {
  42:ratt.c        ****   unsigned char buffer[RX_BUFFER_SIZE];
  43:ratt.c        ****   int head;
  44:ratt.c        ****   int tail;
  45:ratt.c        **** };
  46:ratt.c        **** 
  47:ratt.c        **** struct ring_buffer rx_buffer = { { 0 }, 0, 0 };
  48:ratt.c        **** 
  49:ratt.c        **** inline void store_char(unsigned char c, struct ring_buffer *rx_buffer)
  50:ratt.c        **** {
  51:ratt.c        ****   int i = (rx_buffer->head + 1) % RX_BUFFER_SIZE;
  52:ratt.c        **** 
  53:ratt.c        ****   // if we should be storing the received character into the location
  54:ratt.c        ****   // just before the tail (meaning that the head would advance to the
  55:ratt.c        ****   // current location of the tail), we're about to overflow the buffer
  56:ratt.c        ****   // and so we don't write the character or advance the head.
  57:ratt.c        ****   if (i != rx_buffer->tail) {
  58:ratt.c        ****     rx_buffer->buffer[rx_buffer->head] = c;
  59:ratt.c        ****     rx_buffer->head = i;
  60:ratt.c        ****   }
  61:ratt.c        **** }
  62:ratt.c        **** 
  63:ratt.c        **** SIGNAL(USART_RX_vect)
  64:ratt.c        **** {
 146               	.LM0:
 147               	.LFBB1:
 148 0000 1F92      		push __zero_reg__
 149 0002 0F92      		push r0
 150 0004 0FB6      		in r0,__SREG__
 151 0006 0F92      		push r0
 152 0008 1124      		clr __zero_reg__
 153 000a 2F93      		push r18
 154 000c 3F93      		push r19
 155 000e 4F93      		push r20
 156 0010 5F93      		push r21
 157 0012 6F93      		push r22
 158 0014 7F93      		push r23
 159 0016 8F93      		push r24
 160 0018 9F93      		push r25
 161 001a AF93      		push r26
 162 001c BF93      		push r27
 163 001e EF93      		push r30
 164 0020 FF93      		push r31
 165               	/* prologue: Signal */
 166               	/* frame size = 0 */
  65:ratt.c        ****   unsigned char c = UDR0;
 168               	.LM1:
 169 0022 4091 C600 		lds r20,198
 170               	.LBB20:
 171               	.LBB21:
  52:ratt.c        ****   int i = (rx_buffer->head + 1) % RX_BUFFER_SIZE;
 173               	.LM2:
 174 0026 E091 0000 		lds r30,rx_buffer+128
 175 002a F091 0000 		lds r31,(rx_buffer+128)+1
 176 002e CF01      		movw r24,r30
 177 0030 0196      		adiw r24,1
 178 0032 60E8      		ldi r22,lo8(128)
 179 0034 70E0      		ldi r23,hi8(128)
 180 0036 0E94 0000 		call __divmodhi4
 181 003a 9C01      		movw r18,r24
  58:ratt.c        ****   if (i != rx_buffer->tail) {
 183               	.LM3:
 184 003c 8091 0000 		lds r24,rx_buffer+130
 185 0040 9091 0000 		lds r25,(rx_buffer+130)+1
 186 0044 2817      		cp r18,r24
 187 0046 3907      		cpc r19,r25
 188 0048 01F0      		breq .L3
  59:ratt.c        ****     rx_buffer->buffer[rx_buffer->head] = c;
 190               	.LM4:
 191 004a E050      		subi r30,lo8(-(rx_buffer))
 192 004c F040      		sbci r31,hi8(-(rx_buffer))
 193 004e 4083      		st Z,r20
  60:ratt.c        ****     rx_buffer->head = i;
 195               	.LM5:
 196 0050 3093 0000 		sts (rx_buffer+128)+1,r19
 197 0054 2093 0000 		sts rx_buffer+128,r18
 198               	.L3:
 199               	/* epilogue start */
 200               	.LBE21:
 201               	.LBE20:
  66:ratt.c        ****   store_char(c, &rx_buffer);
  67:ratt.c        **** }
 203               	.LM6:
 204 0058 FF91      		pop r31
 205 005a EF91      		pop r30
 206 005c BF91      		pop r27
 207 005e AF91      		pop r26
 208 0060 9F91      		pop r25
 209 0062 8F91      		pop r24
 210 0064 7F91      		pop r23
 211 0066 6F91      		pop r22
 212 0068 5F91      		pop r21
 213 006a 4F91      		pop r20
 214 006c 3F91      		pop r19
 215 006e 2F91      		pop r18
 216 0070 0F90      		pop r0
 217 0072 0FBE      		out __SREG__,r0
 218 0074 0F90      		pop r0
 219 0076 1F90      		pop __zero_reg__
 220 0078 1895      		reti
 225               	.Lscope1:
 227               		.stabd	78,0,0
 229               	.global	char_available
 231               	char_available:
 232               		.stabd	46,0,0
  68:ratt.c        **** 
  69:ratt.c        **** uint8_t char_available(void)
  70:ratt.c        **** {
 234               	.LM7:
 235               	.LFBB2:
 236               	/* prologue: function */
 237               	/* frame size = 0 */
 239               	.LM8:
 240 007a 8091 0000 		lds r24,rx_buffer+128
 241 007e 9091 0000 		lds r25,(rx_buffer+128)+1
 242 0082 8058      		subi r24,lo8(-(128))
 243 0084 9F4F      		sbci r25,hi8(-(128))
 244 0086 2091 0000 		lds r18,rx_buffer+130
 245 008a 3091 0000 		lds r19,(rx_buffer+130)+1
 246 008e 821B      		sub r24,r18
 247 0090 930B      		sbc r25,r19
 248 0092 60E8      		ldi r22,lo8(128)
 249 0094 70E0      		ldi r23,hi8(128)
 250 0096 0E94 0000 		call __divmodhi4
 251               	/* epilogue start */
  71:ratt.c        ****   return (RX_BUFFER_SIZE + rx_buffer.head - rx_buffer.tail) % RX_BUFFER_SIZE;
  72:ratt.c        **** }
 253               	.LM9:
 254 009a 0895      		ret
 256               	.Lscope2:
 258               		.stabd	78,0,0
 260               	.global	char_read
 262               	char_read:
 263               		.stabd	46,0,0
  73:ratt.c        **** 
  74:ratt.c        **** int char_read(void)
  75:ratt.c        **** {
 265               	.LM10:
 266               	.LFBB3:
 267               	/* prologue: function */
 268               	/* frame size = 0 */
  76:ratt.c        ****   // if the head isn't ahead of the tail, we don't have any characters
  77:ratt.c        ****   if (rx_buffer.head == rx_buffer.tail) {
 270               	.LM11:
 271 009c 4091 0000 		lds r20,rx_buffer+130
 272 00a0 5091 0000 		lds r21,(rx_buffer+130)+1
 273 00a4 8091 0000 		lds r24,rx_buffer+128
 274 00a8 9091 0000 		lds r25,(rx_buffer+128)+1
 275 00ac 8417      		cp r24,r20
 276 00ae 9507      		cpc r25,r21
 277 00b0 01F4      		brne .L7
 278 00b2 2FEF      		ldi r18,lo8(-1)
 279 00b4 3FEF      		ldi r19,hi8(-1)
 280 00b6 00C0      		rjmp .L8
 281               	.L7:
 282               	.LBB22:
  78:ratt.c        ****     return -1;
  79:ratt.c        ****   } else {
  80:ratt.c        ****     unsigned char c = rx_buffer.buffer[rx_buffer.tail];
 284               	.LM12:
 285 00b8 FA01      		movw r30,r20
 286 00ba E050      		subi r30,lo8(-(rx_buffer))
 287 00bc F040      		sbci r31,hi8(-(rx_buffer))
 288 00be 2081      		ld r18,Z
  81:ratt.c        ****     rx_buffer.tail = (rx_buffer.tail + 1) % RX_BUFFER_SIZE;
 290               	.LM13:
 291 00c0 CA01      		movw r24,r20
 292 00c2 0196      		adiw r24,1
 293 00c4 60E8      		ldi r22,lo8(128)
 294 00c6 70E0      		ldi r23,hi8(128)
 295 00c8 0E94 0000 		call __divmodhi4
 296 00cc 9093 0000 		sts (rx_buffer+130)+1,r25
 297 00d0 8093 0000 		sts rx_buffer+130,r24
  82:ratt.c        ****     return c;
 299               	.LM14:
 300 00d4 30E0      		ldi r19,lo8(0)
 301               	.L8:
 302               	.LBE22:
  83:ratt.c        ****   }
  84:ratt.c        **** }
 304               	.LM15:
 305 00d6 C901      		movw r24,r18
 306               	/* epilogue start */
 307 00d8 0895      		ret
 312               	.Lscope3:
 314               		.stabd	78,0,0
 316               	.global	__vector_13
 318               	__vector_13:
 319               		.stabd	46,0,0
  85:ratt.c        **** 
  86:ratt.c        **** 
  87:ratt.c        **** #endif
  88:ratt.c        **** 
  89:ratt.c        **** #ifdef DEATHCHRON
  90:ratt.c        **** extern volatile uint8_t border_tick;
  91:ratt.c        **** #endif
  92:ratt.c        **** 
  93:ratt.c        **** // These store the current button states for all 3 buttons. We can 
  94:ratt.c        **** // then query whether the buttons are pressed and released or pressed
  95:ratt.c        **** // This allows for 'high speed incrementing' when setting the time
  96:ratt.c        **** extern volatile uint8_t last_buttonstate, just_pressed, pressed;
  97:ratt.c        **** extern volatile uint8_t buttonholdcounter;
  98:ratt.c        **** 
  99:ratt.c        **** extern volatile uint8_t timeoutcounter;
 100:ratt.c        **** 
 101:ratt.c        **** // How long we have been snoozing
 102:ratt.c        **** uint16_t snoozetimer = 0;
 103:ratt.c        **** 
 104:ratt.c        **** SIGNAL(TIMER1_OVF_vect) {
 321               	.LM16:
 322               	.LFBB4:
 323 00da 1F92      		push __zero_reg__
 324 00dc 0F92      		push r0
 325 00de 0FB6      		in r0,__SREG__
 326 00e0 0F92      		push r0
 327 00e2 1124      		clr __zero_reg__
 328 00e4 8F93      		push r24
 329 00e6 9F93      		push r25
 330               	/* prologue: Signal */
 331               	/* frame size = 0 */
 105:ratt.c        ****   PIEZO_PORT ^= _BV(PIEZO);
 333               	.LM17:
 334 00e8 88B1      		in r24,40-32
 335 00ea 98E0      		ldi r25,lo8(8)
 336 00ec 8927      		eor r24,r25
 337 00ee 88B9      		out 40-32,r24
 338               	/* epilogue start */
 106:ratt.c        **** }
 340               	.LM18:
 341 00f0 9F91      		pop r25
 342 00f2 8F91      		pop r24
 343 00f4 0F90      		pop r0
 344 00f6 0FBE      		out __SREG__,r0
 345 00f8 0F90      		pop r0
 346 00fa 1F90      		pop __zero_reg__
 347 00fc 1895      		reti
 349               	.Lscope4:
 351               		.stabd	78,0,0
 353               	.global	__vector_14
 355               	__vector_14:
 356               		.stabd	46,0,0
 107:ratt.c        **** 
 108:ratt.c        **** volatile uint16_t millis = 0;
 109:ratt.c        **** volatile uint16_t animticker, alarmticker;
 110:ratt.c        **** SIGNAL(TIMER0_COMPA_vect) {
 358               	.LM19:
 359               	.LFBB5:
 360 00fe 1F92      		push __zero_reg__
 361 0100 0F92      		push r0
 362 0102 0FB6      		in r0,__SREG__
 363 0104 0F92      		push r0
 364 0106 1124      		clr __zero_reg__
 365 0108 8F93      		push r24
 366 010a 9F93      		push r25
 367               	/* prologue: Signal */
 368               	/* frame size = 0 */
 111:ratt.c        ****   if (millis)
 370               	.LM20:
 371 010c 8091 0000 		lds r24,millis
 372 0110 9091 0000 		lds r25,(millis)+1
 373 0114 892B      		or r24,r25
 374 0116 01F0      		breq .L13
 112:ratt.c        ****     millis--;
 376               	.LM21:
 377 0118 8091 0000 		lds r24,millis
 378 011c 9091 0000 		lds r25,(millis)+1
 379 0120 0197      		sbiw r24,1
 380 0122 9093 0000 		sts (millis)+1,r25
 381 0126 8093 0000 		sts millis,r24
 382               	.L13:
 113:ratt.c        ****   if (animticker)
 384               	.LM22:
 385 012a 8091 0000 		lds r24,animticker
 386 012e 9091 0000 		lds r25,(animticker)+1
 387 0132 892B      		or r24,r25
 388 0134 01F0      		breq .L14
 114:ratt.c        ****     animticker--;
 390               	.LM23:
 391 0136 8091 0000 		lds r24,animticker
 392 013a 9091 0000 		lds r25,(animticker)+1
 393 013e 0197      		sbiw r24,1
 394 0140 9093 0000 		sts (animticker)+1,r25
 395 0144 8093 0000 		sts animticker,r24
 396               	.L14:
 115:ratt.c        **** 
 116:ratt.c        ****   if (alarming && !snoozetimer) {
 398               	.LM24:
 399 0148 8091 0000 		lds r24,alarming
 400 014c 8823      		tst r24
 401 014e 01F0      		breq .L18
 402 0150 8091 0000 		lds r24,snoozetimer
 403 0154 9091 0000 		lds r25,(snoozetimer)+1
 404 0158 892B      		or r24,r25
 405 015a 01F4      		brne .L18
 117:ratt.c        ****     if (alarmticker == 0) {
 407               	.LM25:
 408 015c 8091 0000 		lds r24,alarmticker
 409 0160 9091 0000 		lds r25,(alarmticker)+1
 410 0164 892B      		or r24,r25
 411 0166 01F4      		brne .L16
 118:ratt.c        ****       alarmticker = 300;
 413               	.LM26:
 414 0168 8CE2      		ldi r24,lo8(300)
 415 016a 91E0      		ldi r25,hi8(300)
 416 016c 9093 0000 		sts (alarmticker)+1,r25
 417 0170 8093 0000 		sts alarmticker,r24
 119:ratt.c        ****       if (TCCR1B == 0) {
 419               	.LM27:
 420 0174 8091 8100 		lds r24,129
 421 0178 8823      		tst r24
 422 017a 01F4      		brne .L17
 120:ratt.c        **** 	TCCR1A = 0; 
 424               	.LM28:
 425 017c 1092 8000 		sts 128,__zero_reg__
 121:ratt.c        **** 	TCCR1B =  _BV(WGM12) | _BV(CS10); // CTC with fastest timer
 427               	.LM29:
 428 0180 89E0      		ldi r24,lo8(9)
 429 0182 8093 8100 		sts 129,r24
 122:ratt.c        **** 	TIMSK1 = _BV(TOIE1) | _BV(OCIE1A);
 431               	.LM30:
 432 0186 83E0      		ldi r24,lo8(3)
 433 0188 8093 6F00 		sts 111,r24
 123:ratt.c        **** 	OCR1A = (F_CPU / ALARM_FREQ) / 2;
 435               	.LM31:
 436 018c 88EE      		ldi r24,lo8(1000)
 437 018e 93E0      		ldi r25,hi8(1000)
 438 0190 9093 8900 		sts (136)+1,r25
 439 0194 8093 8800 		sts 136,r24
 440 0198 00C0      		rjmp .L16
 441               	.L17:
 124:ratt.c        ****       } else {
 125:ratt.c        **** 	TCCR1B = 0;
 443               	.LM32:
 444 019a 1092 8100 		sts 129,__zero_reg__
 126:ratt.c        **** 	// turn off piezo
 127:ratt.c        **** 	PIEZO_PORT &= ~_BV(PIEZO);
 446               	.LM33:
 447 019e 4398      		cbi 40-32,3
 448               	.L16:
 128:ratt.c        ****       }
 129:ratt.c        ****     }
 130:ratt.c        ****     alarmticker--;    
 450               	.LM34:
 451 01a0 8091 0000 		lds r24,alarmticker
 452 01a4 9091 0000 		lds r25,(alarmticker)+1
 453 01a8 0197      		sbiw r24,1
 454 01aa 9093 0000 		sts (alarmticker)+1,r25
 455 01ae 8093 0000 		sts alarmticker,r24
 456               	.L18:
 457               	/* epilogue start */
 131:ratt.c        ****   }
 132:ratt.c        **** }
 459               	.LM35:
 460 01b2 9F91      		pop r25
 461 01b4 8F91      		pop r24
 462 01b6 0F90      		pop r0
 463 01b8 0FBE      		out __SREG__,r0
 464 01ba 0F90      		pop r0
 465 01bc 1F90      		pop __zero_reg__
 466 01be 1895      		reti
 468               	.Lscope5:
 470               		.stabd	78,0,0
 472               	.global	__vector_11
 474               	__vector_11:
 475               		.stabd	46,0,0
 133:ratt.c        **** 
 134:ratt.c        **** extern uint8_t EE_ALARM_HOUR;
 135:ratt.c        **** extern uint8_t EE_ALARM_MIN;
 136:ratt.c        **** extern uint8_t EE_BRIGHT;
 137:ratt.c        **** extern uint8_t EE_REGION;
 138:ratt.c        **** extern uint8_t EE_TIME_FORMAT;
 139:ratt.c        **** extern uint8_t EE_SNOOZE;
 140:ratt.c        **** extern uint8_t EE_STYLE;
 141:ratt.c        **** 
 142:ratt.c        **** 
 143:ratt.c        **** void init_eeprom(void) {	//Set eeprom to a default state.
 144:ratt.c        ****  if (eeprom_read_byte(&EE_INIT) != pgm_read_byte(&EE_DATA[0])) {
 145:ratt.c        ****     DEBUG(putstring("Error with EEPROM data. Clock cannot function without it. Please reprogram."))
 146:ratt.c        ****     DEBUG(uart_putw_dec(eeprom_read_byte(&EE_INIT))); DEBUG(putstring_nl(""));
 147:ratt.c        ****     while(1) {
 148:ratt.c        ****       beep(4000, 100);
 149:ratt.c        ****       delay_ms(100);
 150:ratt.c        ****       beep(4000, 100);
 151:ratt.c        ****       delay_ms(100);
 152:ratt.c        ****       beep(4000, 100);
 153:ratt.c        ****       delay_ms(1000);
 154:ratt.c        ****     }
 155:ratt.c        ****   }
 156:ratt.c        ****   //We do not have the capability to reinitialize the EEPROM, other than by reprogramming it.
 157:ratt.c        ****   //Because of this, and because we are storing some data there, bad things will happen if the
 158:ratt.c        ****   //eeprom is NOT initialized. This is why we error out with infinite triple beeps if it is
 159:ratt.c        ****   //not initialized.
 160:ratt.c        **** }
 161:ratt.c        **** 
 162:ratt.c        **** int main(void) {
 163:ratt.c        ****   uint8_t inverted = 0;
 164:ratt.c        ****   uint8_t mcustate;
 165:ratt.c        ****   uint8_t display_date = 0;
 166:ratt.c        **** 
 167:ratt.c        ****   // check if we were reset
 168:ratt.c        ****   mcustate = MCUSR;
 169:ratt.c        ****   MCUSR = 0;
 170:ratt.c        ****   
 171:ratt.c        ****   //Just in case we were reset inside of the glcd init function
 172:ratt.c        ****   //which would happen if the lcd is not plugged in. The end result
 173:ratt.c        ****   //of that, is it will beep, pause, for as long as there is no lcd
 174:ratt.c        ****   //plugged in.
 175:ratt.c        ****   wdt_disable();
 176:ratt.c        **** 
 177:ratt.c        ****   // setup uart
 178:ratt.c        ****   uart_init(BRRL_4800);
 179:ratt.c        **** #ifdef GPSENABLE
 180:ratt.c        ****   UCSR0B |= _BV(TXEN0) | _BV(RXEN0) | _BV(RXCIE0);
 181:ratt.c        ****   //HardwareSerial Serial(&rx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UDR0, RXEN0, TXEN0, RXCI
 182:ratt.c        **** #endif
 183:ratt.c        ****   DEBUGP("RATT Clock");
 184:ratt.c        **** 
 185:ratt.c        ****   // set up piezo
 186:ratt.c        ****   PIEZO_DDR |= _BV(PIEZO);
 187:ratt.c        **** 
 188:ratt.c        ****   DEBUGP("clock!");
 189:ratt.c        ****   clock_init();
 190:ratt.c        ****   //beep(4000, 100);
 191:ratt.c        ****   
 192:ratt.c        **** 
 193:ratt.c        ****   init_eeprom();
 194:ratt.c        ****   
 195:ratt.c        ****   region = eeprom_read_byte(&EE_REGION);
 196:ratt.c        ****   time_format = eeprom_read_byte(&EE_TIME_FORMAT);
 197:ratt.c        ****   DEBUGP("buttons!");
 198:ratt.c        ****   initbuttons();
 199:ratt.c        **** 
 200:ratt.c        ****   setalarmstate();
 201:ratt.c        **** 
 202:ratt.c        ****   // setup 1ms timer on timer0
 203:ratt.c        ****   TCCR0A = _BV(WGM01);
 204:ratt.c        ****   TCCR0B = _BV(CS01) | _BV(CS00);
 205:ratt.c        ****   OCR0A = 125;
 206:ratt.c        ****   TIMSK0 |= _BV(OCIE0A);
 207:ratt.c        **** 
 208:ratt.c        ****   // turn backlight on
 209:ratt.c        ****   DDRD |= _BV(3);
 210:ratt.c        **** #ifndef BACKLIGHT_ADJUST
 211:ratt.c        ****   PORTD |= _BV(3);
 212:ratt.c        **** #else
 213:ratt.c        ****   TCCR2A = _BV(COM2B1); // PWM output on pin D3
 214:ratt.c        ****   TCCR2A |= _BV(WGM21) | _BV(WGM20); // fast PWM
 215:ratt.c        ****   TCCR2B |= _BV(WGM22);
 216:ratt.c        ****   OCR2A = OCR2A_VALUE;
 217:ratt.c        ****   OCR2B = eeprom_read_byte(&EE_BRIGHT);
 218:ratt.c        **** #endif
 219:ratt.c        **** 
 220:ratt.c        ****   DDRB |= _BV(5);
 221:ratt.c        ****   beep(4000, 100);
 222:ratt.c        ****   
 223:ratt.c        ****   //glcdInit locks and disables interrupts in one of its functions.  If the LCD is not
 224:ratt.c        ****   //plugged in, glcd will run forever.  For good reason, it would be desirable to know
 225:ratt.c        ****   //that the LCD is plugged in and working correctly as a result.  This is why we are
 226:ratt.c        ****   //using a watch dog timer.  The lcd should initialized in way less than 500 ms.
 227:ratt.c        ****   wdt_enable(WDTO_2S);
 228:ratt.c        ****   glcdInit();
 229:ratt.c        ****   glcdClearScreen();
 230:ratt.c        **** 
 231:ratt.c        ****   
 232:ratt.c        ****   //Dataman - InitiAmin now init displays(0) as well.
 233:ratt.c        ****   //initdisplay(0);
 234:ratt.c        ****   displaystyle = eeprom_read_byte(&EE_STYLE);
 235:ratt.c        ****   if(displaystyle >= STYLE_ABOUT) {
 236:ratt.c        ****     displaystyle = STYLE_ROTATE;
 237:ratt.c        ****     eeprom_write_byte(&EE_STYLE,displaystyle);
 238:ratt.c        ****   }
 239:ratt.c        ****   RotateFlag = 0;
 240:ratt.c        ****   initanim();
 241:ratt.c        ****   
 242:ratt.c        ****   while (1) {
 243:ratt.c        ****     animticker = ANIMTICK_MS;
 244:ratt.c        **** 
 245:ratt.c        ****     // check buttons to see if we have interaction stuff to deal with
 246:ratt.c        **** 	if(just_pressed && alarming)
 247:ratt.c        **** 	{
 248:ratt.c        **** 	  just_pressed = 0;
 249:ratt.c        **** 	  setsnooze();
 250:ratt.c        **** 	}
 251:ratt.c        **** 	
 252:ratt.c        **** 	if(display_date==3 && !score_mode_timeout)
 253:ratt.c        **** 	{
 254:ratt.c        **** 		display_date=0;
 255:ratt.c        **** #ifdef DEATHCHRON
 256:ratt.c        **** 	  if (displaystyle == STYLE_DEATH) {
 257:ratt.c        **** 	    if(score_mode >= SCORE_MODE_DEATH_TIME)
 258:ratt.c        **** 	      score_mode = SCORE_MODE_DEATH_YEAR;
 259:ratt.c        **** 	    else
 260:ratt.c        **** 	      score_mode = SCORE_MODE_YEAR;
 261:ratt.c        **** 	  }
 262:ratt.c        **** 	  else
 263:ratt.c        **** #endif
 264:ratt.c        **** 		   score_mode = SCORE_MODE_YEAR;
 265:ratt.c        **** 	    score_mode_timeout = SCORE_MODE_TIMEOUT;
 266:ratt.c        **** 	    //drawdisplay();
 267:ratt.c        **** 	}
 268:ratt.c        **** #ifdef OPTION_DOW_DATELONG
 269:ratt.c        **** 	else if(display_date==2 && !score_mode_timeout)
 270:ratt.c        **** 	{
 271:ratt.c        **** 		display_date=3;
 272:ratt.c        **** 		score_mode = SCORE_MODE_DATE;
 273:ratt.c        **** 	    score_mode_timeout = SCORE_MODE_TIMEOUT;
 274:ratt.c        **** 	    //drawdisplay();
 275:ratt.c        **** 	}
 276:ratt.c        **** 	else if(display_date==1 && !score_mode_timeout)
 277:ratt.c        **** 	{
 278:ratt.c        **** 		display_date=4;
 279:ratt.c        **** 		score_mode = SCORE_MODE_DATELONG_MON;
 280:ratt.c        **** 	    score_mode_timeout = SCORE_MODE_TIMEOUT;
 281:ratt.c        **** 	    //drawdisplay();
 282:ratt.c        **** 	}
 283:ratt.c        **** 	else if(display_date==4 && !score_mode_timeout)
 284:ratt.c        **** 	{
 285:ratt.c        **** 		display_date=3;
 286:ratt.c        **** 		score_mode = SCORE_MODE_DATELONG_DAY;
 287:ratt.c        **** 		score_mode_timeout = SCORE_MODE_TIMEOUT;
 288:ratt.c        **** 	}
 289:ratt.c        **** #endif
 290:ratt.c        **** 	
 291:ratt.c        **** 	/*if(display_date && !score_mode_timeout)
 292:ratt.c        **** 	{
 293:ratt.c        **** 	  if(last_score_mode == SCORE_MODE_DATELONG)
 294:ratt.c        **** 	  {
 295:ratt.c        **** 	    score_mode = SCORE_MODE_DOW;
 296:ratt.c        **** 	    score_mode_timeout = SCORE_MODE_TIMEOUT;
 297:ratt.c        **** 	    setscore();
 298:ratt.c        **** 	  }
 299:ratt.c        **** 	  
 300:ratt.c        **** 	  else if(last_score_mode == SCORE_MODE_DOW)
 301:ratt.c        **** 	  {
 302:ratt.c        **** 	    score_mode = SCORE_MODE_DATE;
 303:ratt.c        **** 	    score_mode_timeout = SCORE_MODE_TIMEOUT;
 304:ratt.c        **** 	    setscore();
 305:ratt.c        **** 	  }
 306:ratt.c        **** 	  else if(last_score_mode == SCORE_MODE_DATE)
 307:ratt.c        **** 	  {
 308:ratt.c        **** 	    score_mode = SCORE_MODE_YEAR;
 309:ratt.c        **** 	    score_mode_timeout = SCORE_MODE_TIMEOUT;
 310:ratt.c        **** 	    setscore();
 311:ratt.c        **** 	    display_date = 0;
 312:ratt.c        **** 	  }
 313:ratt.c        **** 	  
 314:ratt.c        **** 	}*/
 315:ratt.c        **** 	/*if(display_date && !score_mode_timeout)
 316:ratt.c        **** 	{
 317:ratt.c        **** 	  score_mode = SCORE_MODE_YEAR;
 318:ratt.c        **** 	  score_mode_timeout = SCORE_MODE_TIMEOUT;
 319:ratt.c        **** 	  setscore();
 320:ratt.c        **** 	  display_date = 0;
 321:ratt.c        **** 	}*/
 322:ratt.c        **** 
 323:ratt.c        ****     //Was formally set for just the + button.  However, because the Set button was never
 324:ratt.c        ****     //accounted for, If the alarm was turned on, and ONLY the set button was pushed since then,
 325:ratt.c        ****     //the alarm would not sound at alarm time, but go into a snooze immediately after going off.
 326:ratt.c        ****     //This could potentially make you late for work, and had to be fixed.
 327:ratt.c        **** 
 328:ratt.c        ****     if(just_pressed & 0x4) {
 329:ratt.c        **** #ifdef DEATHCHRON
 330:ratt.c        **** 	  if (displaystyle == STYLE_DEATH) {
 331:ratt.c        **** 	    just_pressed = 0;
 332:ratt.c        **** 	    if(score_mode < SCORE_MODE_DEATH_TIME)
 333:ratt.c        **** 	      score_mode = SCORE_MODE_DEATH_TIME;
 334:ratt.c        **** 	    else
 335:ratt.c        **** 	      score_mode = SCORE_MODE_TIME;
 336:ratt.c        **** 	  }
 337:ratt.c        **** 	  else
 338:ratt.c        **** #endif
 339:ratt.c        **** 	    just_pressed = 2;
 340:ratt.c        **** 	}
 341:ratt.c        ****     
 342:ratt.c        **** 	if (just_pressed & 0x2) {
 343:ratt.c        **** 	  just_pressed = 0;
 344:ratt.c        **** #ifdef OPTION_DOW_DATELONG
 345:ratt.c        **** 	  if((region == REGION_US) || (region == REGION_EU)) {
 346:ratt.c        **** #endif
 347:ratt.c        **** 	  	display_date = 3;
 348:ratt.c        **** #ifdef DEATHCHRON
 349:ratt.c        **** 	  if (displaystyle == STYLE_DEATH) {
 350:ratt.c        **** 	    if(score_mode >= SCORE_MODE_DEATH_TIME)
 351:ratt.c        **** 	      score_mode = SCORE_MODE_DEATH_DATE;
 352:ratt.c        **** 	    else
 353:ratt.c        **** 	      score_mode = SCORE_MODE_DATE;
 354:ratt.c        **** 	  }
 355:ratt.c        **** 	  else
 356:ratt.c        **** #endif
 357:ratt.c        **** 	  	score_mode = SCORE_MODE_DATE;
 358:ratt.c        **** #ifdef OPTION_DOW_DATELONG
 359:ratt.c        **** 	  }
 360:ratt.c        **** 	  else if ((region == DOW_REGION_US) || (region == DOW_REGION_EU)) {
 361:ratt.c        **** 	  	display_date = 2;
 362:ratt.c        **** 	  	score_mode = SCORE_MODE_DOW;
 363:ratt.c        **** 	  }
 364:ratt.c        **** 	  else if (region == DATELONG) {
 365:ratt.c        **** 	  	display_date = 4;
 366:ratt.c        **** 	  	score_mode = SCORE_MODE_DATELONG_MON;
 367:ratt.c        **** 	  }
 368:ratt.c        **** 	  else {
 369:ratt.c        **** 	  	display_date = 1;
 370:ratt.c        **** 	  	score_mode = SCORE_MODE_DOW;
 371:ratt.c        **** 	  }
 372:ratt.c        **** #endif
 373:ratt.c        **** 	  score_mode_timeout = SCORE_MODE_TIMEOUT;
 374:ratt.c        **** 	  //drawdisplay();
 375:ratt.c        **** 	}
 376:ratt.c        **** 
 377:ratt.c        ****     if (just_pressed & 0x1) {
 378:ratt.c        ****       just_pressed = 0;
 379:ratt.c        ****       display_date = 0;
 380:ratt.c        ****       score_mode = SCORE_MODE_TIME;
 381:ratt.c        ****       score_mode_timeout = 0;
 382:ratt.c        ****       //drawdisplay();
 383:ratt.c        ****       switch(displaymode) {
 384:ratt.c        ****       case (SHOW_TIME):
 385:ratt.c        ****       case (CFG_MENU):	//Returning from a configuration menu module.
 386:ratt.c        **** 	// DATAMAN - ADD STYLE MENU
 387:ratt.c        **** 	displaymode = SET_STYLE;
 388:ratt.c        **** 	set_style();
 389:ratt.c        **** 	break; 
 390:ratt.c        **** 	case SET_STYLE:
 391:ratt.c        **** 	// END ADD STYLE MENU
 392:ratt.c        **** 	displaymode = SET_ALARM;
 393:ratt.c        **** 	set_alarm();
 394:ratt.c        **** 	break;
 395:ratt.c        ****       case (SET_ALARM):
 396:ratt.c        **** 	displaymode = SET_TIME;
 397:ratt.c        **** 	set_time();
 398:ratt.c        **** 	timeunknown = 0;
 399:ratt.c        **** 	break;
 400:ratt.c        ****       case SET_TIME:
 401:ratt.c        **** 	displaymode = SET_DATE;
 402:ratt.c        **** 	set_date();
 403:ratt.c        **** 	break;
 404:ratt.c        ****       case SET_DATE:
 405:ratt.c        **** 	displaymode = SET_REGION;
 406:ratt.c        **** 	set_region();
 407:ratt.c        **** 	break;
 408:ratt.c        **** #ifdef BACKLIGHT_ADJUST
 409:ratt.c        **** 	  case SET_REGION:
 410:ratt.c        **** 	displaymode = SET_BRIGHTNESS;
 411:ratt.c        **** 	set_backlight();
 412:ratt.c        **** 	break;
 413:ratt.c        **** #endif
 414:ratt.c        ****       default:
 415:ratt.c        **** 	displaymode = SHOW_TIME;
 416:ratt.c        **** 	//glcdClearScreen();
 417:ratt.c        **** 	//Dataman - Changing initdisplays to initanims, need to make sure as animation may have changed.
 418:ratt.c        **** 	//initdisplay(0);
 419:ratt.c        **** 	//initanim();
 420:ratt.c        ****       }
 421:ratt.c        **** 
 422:ratt.c        ****       if (displaymode == SHOW_TIME) {
 423:ratt.c        **** 	glcdClearScreen();
 424:ratt.c        **** 	//Dataman - Changing initdisplays to initanims, need to make sure as animation may have changed.
 425:ratt.c        **** 	//initdisplay(0);
 426:ratt.c        **** 	initanim();
 427:ratt.c        ****       }
 428:ratt.c        ****     }
 429:ratt.c        **** 
 430:ratt.c        ****     step();
 431:ratt.c        ****     if (displaymode == SHOW_TIME) {
 432:ratt.c        ****       if (! inverted && alarming && (time_s & 0x1)) {
 433:ratt.c        **** 	inverted = 1;
 434:ratt.c        **** 	initdisplay(inverted);
 435:ratt.c        ****       }
 436:ratt.c        ****       else if ((inverted && ! alarming) || (alarming && inverted && !(time_s & 0x1))) {
 437:ratt.c        **** 	inverted = 0;
 438:ratt.c        **** 	initdisplay(0);
 439:ratt.c        ****       } else {
 440:ratt.c        **** 	PORTB |= _BV(5);
 441:ratt.c        **** 	drawdisplay(inverted);
 442:ratt.c        **** 	PORTB &= ~_BV(5);
 443:ratt.c        ****       }
 444:ratt.c        ****     }
 445:ratt.c        ****   
 446:ratt.c        ****     while (animticker);
 447:ratt.c        ****     //uart_getchar();  // you would uncomment this so you can manually 'step'
 448:ratt.c        ****   }
 449:ratt.c        **** 
 450:ratt.c        ****   halt();
 451:ratt.c        **** }
 452:ratt.c        **** 
 453:ratt.c        **** 
 454:ratt.c        **** SIGNAL(TIMER1_COMPA_vect) {
 477               	.LM36:
 478               	.LFBB6:
 479 01c0 1F92      		push __zero_reg__
 480 01c2 0F92      		push r0
 481 01c4 0FB6      		in r0,__SREG__
 482 01c6 0F92      		push r0
 483 01c8 1124      		clr __zero_reg__
 484 01ca 8F93      		push r24
 485 01cc 9F93      		push r25
 486               	/* prologue: Signal */
 487               	/* frame size = 0 */
 455:ratt.c        ****   PIEZO_PORT ^= _BV(PIEZO);
 489               	.LM37:
 490 01ce 88B1      		in r24,40-32
 491 01d0 98E0      		ldi r25,lo8(8)
 492 01d2 8927      		eor r24,r25
 493 01d4 88B9      		out 40-32,r24
 494               	/* epilogue start */
 456:ratt.c        **** }
 496               	.LM38:
 497 01d6 9F91      		pop r25
 498 01d8 8F91      		pop r24
 499 01da 0F90      		pop r0
 500 01dc 0FBE      		out __SREG__,r0
 501 01de 0F90      		pop r0
 502 01e0 1F90      		pop __zero_reg__
 503 01e2 1895      		reti
 505               	.Lscope6:
 507               		.stabd	78,0,0
 509               	.global	setalarmstate
 511               	setalarmstate:
 512               		.stabd	46,0,0
 457:ratt.c        **** 
 458:ratt.c        **** void beep(uint16_t freq, uint8_t duration) {
 459:ratt.c        ****   // use timer 1 for the piezo/buzzer 
 460:ratt.c        ****   TCCR1A = 0; 
 461:ratt.c        ****   TCCR1B =  _BV(WGM12) | _BV(CS10); // CTC with fastest timer
 462:ratt.c        ****   TIMSK1 = _BV(TOIE1) | _BV(OCIE1A);
 463:ratt.c        ****   OCR1A = (F_CPU / freq) / 2;
 464:ratt.c        ****   delay_ms(duration);
 465:ratt.c        ****   TCCR1B = 0;
 466:ratt.c        ****   // turn off piezo
 467:ratt.c        ****   PIEZO_PORT &= ~_BV(PIEZO);
 468:ratt.c        **** }
 469:ratt.c        **** 
 470:ratt.c        **** // This turns on/off the alarm when the switch has been
 471:ratt.c        **** // set. It also displays the alarm time
 472:ratt.c        **** void setalarmstate(void) {
 514               	.LM39:
 515               	.LFBB7:
 516               	/* prologue: function */
 517               	/* frame size = 0 */
 473:ratt.c        ****   DEBUGP("a");
 474:ratt.c        ****   if (ALARM_PIN & _BV(ALARM)) { 
 519               	.LM40:
 520 01e4 1E9B      		sbis 35-32,6
 521 01e6 00C0      		rjmp .L22
 475:ratt.c        ****     if (alarm_on) {
 523               	.LM41:
 524 01e8 8091 0000 		lds r24,alarm_on
 525 01ec 8823      		tst r24
 526 01ee 01F0      		breq .L29
 476:ratt.c        ****       // turn off the alarm
 477:ratt.c        ****       alarm_on = 0;
 528               	.LM42:
 529 01f0 1092 0000 		sts alarm_on,__zero_reg__
 478:ratt.c        ****       alarm_tripped = 0;
 531               	.LM43:
 532 01f4 1092 0000 		sts alarm_tripped,__zero_reg__
 479:ratt.c        ****       snoozetimer = 0;
 534               	.LM44:
 535 01f8 1092 0000 		sts (snoozetimer)+1,__zero_reg__
 536 01fc 1092 0000 		sts snoozetimer,__zero_reg__
 480:ratt.c        ****       if (alarming) {
 538               	.LM45:
 539 0200 8091 0000 		lds r24,alarming
 540 0204 8823      		tst r24
 541 0206 01F0      		breq .L29
 481:ratt.c        **** 	// if the alarm is going off, we should turn it off
 482:ratt.c        **** 	// and quiet the speaker
 483:ratt.c        **** 	DEBUGP("alarm off");
 484:ratt.c        **** 	alarming = 0;
 543               	.LM46:
 544 0208 1092 0000 		sts alarming,__zero_reg__
 485:ratt.c        **** 	TCCR1B = 0;
 546               	.LM47:
 547 020c 1092 8100 		sts 129,__zero_reg__
 486:ratt.c        **** 	// turn off piezo
 487:ratt.c        **** 	PIEZO_PORT &= ~_BV(PIEZO);
 549               	.LM48:
 550 0210 4398      		cbi 40-32,3
 551 0212 0895      		ret
 552               	.L22:
 488:ratt.c        ****       } 
 489:ratt.c        ****     }
 490:ratt.c        ****   } else {
 491:ratt.c        ****     // Don't display the alarm/beep if we already have
 492:ratt.c        ****     if  (!alarm_on) {
 554               	.LM49:
 555 0214 8091 0000 		lds r24,alarm_on
 556 0218 8823      		tst r24
 557 021a 01F4      		brne .L29
 493:ratt.c        ****       // alarm on!
 494:ratt.c        ****       alarm_on = 1;
 559               	.LM50:
 560 021c 81E0      		ldi r24,lo8(1)
 561 021e 8093 0000 		sts alarm_on,r24
 495:ratt.c        ****       // reset snoozing
 496:ratt.c        ****       snoozetimer = 0;
 563               	.LM51:
 564 0222 1092 0000 		sts (snoozetimer)+1,__zero_reg__
 565 0226 1092 0000 		sts snoozetimer,__zero_reg__
 497:ratt.c        **** #ifdef DEATHCHRON
 498:ratt.c        **** 	  if (displaystyle == STYLE_DEATH) {
 567               	.LM52:
 568 022a 8091 0000 		lds r24,displaystyle
 569 022e 833D      		cpi r24,lo8(-45)
 570 0230 01F4      		brne .L24
 499:ratt.c        **** 	    if(score_mode >= SCORE_MODE_DEATH_TIME)
 572               	.LM53:
 573 0232 8091 0000 		lds r24,score_mode
 574 0236 8430      		cpi r24,lo8(4)
 575 0238 00F0      		brlo .L24
 500:ratt.c        **** 	      score_mode = SCORE_MODE_DEATH_ALARM;
 577               	.LM54:
 578 023a 87E0      		ldi r24,lo8(7)
 579 023c 00C0      		rjmp .L30
 580               	.L24:
 501:ratt.c        **** 	    else
 502:ratt.c        **** 	      score_mode = SCORE_MODE_ALARM;
 503:ratt.c        **** 	  }
 504:ratt.c        **** 	  else
 505:ratt.c        **** #endif
 506:ratt.c        **** 	    score_mode = SCORE_MODE_ALARM;
 582               	.LM55:
 583 023e 83E0      		ldi r24,lo8(3)
 584               	.L30:
 585 0240 8093 0000 		sts score_mode,r24
 507:ratt.c        **** 	  score_mode_timeout = SCORE_MODE_TIMEOUT;
 587               	.LM56:
 588 0244 8091 0000 		lds r24,displaystyle
 589 0248 8130      		cpi r24,lo8(1)
 590 024a 01F0      		breq .L27
 591 024c 83E0      		ldi r24,lo8(3)
 592 024e 00C0      		rjmp .L28
 593               	.L27:
 594 0250 85E0      		ldi r24,lo8(5)
 595               	.L28:
 596 0252 8093 0000 		sts score_mode_timeout,r24
 597               	.L29:
 598 0256 0895      		ret
 600               	.Lscope7:
 602               		.stabd	78,0,0
 605               	.global	leapyear
 607               	leapyear:
 608               		.stabd	46,0,0
 508:ratt.c        **** 	  //drawdisplay();
 509:ratt.c        ****       DEBUGP("alarm on");
 510:ratt.c        ****     }   
 511:ratt.c        ****   }
 512:ratt.c        **** }
 513:ratt.c        **** 
 514:ratt.c        **** 
 515:ratt.c        **** void drawArrow(uint8_t x, uint8_t y, uint8_t l) {
 516:ratt.c        ****   glcdFillRectangle(x, y, l, 1, ON);
 517:ratt.c        ****   glcdSetDot(x+l-2,y-1);
 518:ratt.c        ****   glcdSetDot(x+l-2,y+1);
 519:ratt.c        ****   glcdSetDot(x+l-3,y-2);
 520:ratt.c        ****   glcdSetDot(x+l-3,y+2);
 521:ratt.c        **** }
 522:ratt.c        **** 
 523:ratt.c        **** 
 524:ratt.c        **** void printnumber(uint8_t n, uint8_t inverted) {
 525:ratt.c        ****   glcdWriteChar(n/10+'0', inverted);
 526:ratt.c        ****   glcdWriteChar(n%10+'0', inverted);
 527:ratt.c        **** }
 528:ratt.c        **** 
 529:ratt.c        **** uint8_t readi2ctime(void) {
 530:ratt.c        ****   uint8_t regaddr = 0, r;
 531:ratt.c        ****   uint8_t clockdata[8];
 532:ratt.c        ****   
 533:ratt.c        ****   // check the time from the RTC
 534:ratt.c        ****   cli();
 535:ratt.c        ****   r = i2cMasterSendNI(0xD0, 1, &regaddr);
 536:ratt.c        **** 
 537:ratt.c        ****   if (r != 0) {
 538:ratt.c        ****     DEBUG(putstring("Reading i2c data: ")); DEBUG(uart_putw_dec(r)); DEBUG(putstring_nl(""));
 539:ratt.c        ****     while(1) {
 540:ratt.c        ****       sei();
 541:ratt.c        ****       beep(4000, 100);
 542:ratt.c        ****       delay_ms(100);
 543:ratt.c        ****       beep(4000, 100);
 544:ratt.c        ****       delay_ms(1000);
 545:ratt.c        ****     }
 546:ratt.c        ****   }
 547:ratt.c        **** 
 548:ratt.c        ****   r = i2cMasterReceiveNI(0xD0, 7, &clockdata[0]);
 549:ratt.c        ****   sei();
 550:ratt.c        **** 
 551:ratt.c        ****   if (r != 0) {
 552:ratt.c        ****     DEBUG(putstring("Reading i2c data: ")); DEBUG(uart_putw_dec(r)); DEBUG(putstring_nl(""));
 553:ratt.c        ****     while(1) {
 554:ratt.c        ****       beep(4000, 100);
 555:ratt.c        ****       delay_ms(100);
 556:ratt.c        ****       beep(4000, 100);
 557:ratt.c        ****       delay_ms(1000);
 558:ratt.c        ****     }
 559:ratt.c        ****   }
 560:ratt.c        **** 
 561:ratt.c        ****   time_s = ((clockdata[0] >> 4) & 0x7)*10 + (clockdata[0] & 0xF);
 562:ratt.c        ****   time_m = ((clockdata[1] >> 4) & 0x7)*10 + (clockdata[1] & 0xF);
 563:ratt.c        ****   if (clockdata[2] & _BV(6)) {
 564:ratt.c        ****     // "12 hr" mode
 565:ratt.c        ****     time_h = ((clockdata[2] >> 5) & 0x1)*12 + 
 566:ratt.c        ****       ((clockdata[2] >> 4) & 0x1)*10 + (clockdata[2] & 0xF);
 567:ratt.c        ****   } else {
 568:ratt.c        ****     time_h = ((clockdata[2] >> 4) & 0x3)*10 + (clockdata[2] & 0xF);
 569:ratt.c        ****   }
 570:ratt.c        ****   
 571:ratt.c        ****   date_d = ((clockdata[4] >> 4) & 0x3)*10 + (clockdata[4] & 0xF);
 572:ratt.c        ****   date_m = ((clockdata[5] >> 4) & 0x1)*10 + (clockdata[5] & 0xF);
 573:ratt.c        ****   date_y = ((clockdata[6] >> 4) & 0xF)*10 + (clockdata[6] & 0xF);
 574:ratt.c        ****   return clockdata[0] & 0x80;
 575:ratt.c        **** }
 576:ratt.c        **** 
 577:ratt.c        **** void writei2ctime(uint8_t sec, uint8_t min, uint8_t hr, uint8_t day,
 578:ratt.c        **** 		  uint8_t date, uint8_t mon, uint8_t yr) {
 579:ratt.c        ****   uint8_t clockdata[8] = {0,0,0,0,0,0,0,0};
 580:ratt.c        **** 
 581:ratt.c        ****   clockdata[0] = 0; // address
 582:ratt.c        ****   clockdata[1] = i2bcd(sec);  // s
 583:ratt.c        ****   clockdata[2] = i2bcd(min);  // m
 584:ratt.c        ****   clockdata[3] = i2bcd(hr); // h
 585:ratt.c        ****   clockdata[4] = i2bcd(day);  // day
 586:ratt.c        ****   clockdata[5] = i2bcd(date);  // date
 587:ratt.c        ****   clockdata[6] = i2bcd(mon);  // month
 588:ratt.c        ****   clockdata[7] = i2bcd(yr); // year
 589:ratt.c        ****   
 590:ratt.c        ****   cli();
 591:ratt.c        ****   uint8_t r = i2cMasterSendNI(0xD0, 8, &clockdata[0]);
 592:ratt.c        ****   sei();
 593:ratt.c        **** 
 594:ratt.c        ****   //DEBUG(putstring("Writing i2c data: ")); DEBUG(uart_putw_dec()); DEBUG(putstring_nl(""));
 595:ratt.c        **** 
 596:ratt.c        ****   if (r != 0) {
 597:ratt.c        ****     while(1) {
 598:ratt.c        ****       beep(4000, 100);
 599:ratt.c        ****       delay_ms(100);
 600:ratt.c        ****       beep(4000, 100);
 601:ratt.c        ****       delay_ms(1000);
 602:ratt.c        ****     }
 603:ratt.c        ****   }
 604:ratt.c        **** 
 605:ratt.c        **** }
 606:ratt.c        **** 
 607:ratt.c        **** // runs at about 30 hz
 608:ratt.c        **** uint8_t t2divider1 = 0, t2divider2 = 0;
 609:ratt.c        **** SIGNAL (TIMER2_OVF_vect) {
 610:ratt.c        ****   wdt_reset();
 611:ratt.c        **** #ifdef BACKLIGHT_ADJUST
 612:ratt.c        ****   if (t2divider1 == TIMER2_RETURN) {
 613:ratt.c        **** #else
 614:ratt.c        ****   if (t2divider1 == 5) {
 615:ratt.c        **** #endif
 616:ratt.c        ****     t2divider1 = 0;
 617:ratt.c        ****   } else {
 618:ratt.c        ****     t2divider1++;
 619:ratt.c        ****     return;
 620:ratt.c        ****   }
 621:ratt.c        **** 
 622:ratt.c        ****   //This occurs at 6 Hz
 623:ratt.c        **** 
 624:ratt.c        ****   uint8_t last_s = time_s;
 625:ratt.c        ****   uint8_t last_m = time_m;
 626:ratt.c        ****   uint8_t last_h = time_h;
 627:ratt.c        **** 
 628:ratt.c        ****   readi2ctime();
 629:ratt.c        **** #ifdef GPSENABLE
 630:ratt.c        ****   //Hooking time reading, and thus time_changed here.
 631:ratt.c        ****   GPSCheck((displaystyle==STYLE_GPS) && (displaymode == SHOW_TIME));	
 632:ratt.c        **** #endif
 633:ratt.c        **** #ifdef DEATHCHRON
 634:ratt.c        ****   border_tick++;
 635:ratt.c        **** #endif
 636:ratt.c        ****   
 637:ratt.c        ****   if (time_h != last_h) {
 638:ratt.c        ****     hour_changed = 1; 
 639:ratt.c        ****     old_h = last_h;
 640:ratt.c        ****     old_m = last_m;
 641:ratt.c        ****   } else if (time_m != last_m) {
 642:ratt.c        ****     minute_changed = 1;
 643:ratt.c        ****     old_m = last_m;
 644:ratt.c        ****   } else if (time_s != last_s) {
 645:ratt.c        ****     second_changed = 1;
 646:ratt.c        ****     old_s = last_s;
 647:ratt.c        ****   }
 648:ratt.c        **** 
 649:ratt.c        **** 
 650:ratt.c        ****   if (time_s != last_s) {
 651:ratt.c        ****     if(alarming && snoozetimer)
 652:ratt.c        **** 	  snoozetimer--;
 653:ratt.c        **** 
 654:ratt.c        ****     if(score_mode_timeout) {
 655:ratt.c        **** 	  score_mode_timeout--;
 656:ratt.c        **** 	  if(!score_mode_timeout) {
 657:ratt.c        **** 	  	last_score_mode = score_mode;
 658:ratt.c        **** #ifdef DEATHCHRON
 659:ratt.c        **** 	  if (displaystyle == STYLE_DEATH) {
 660:ratt.c        **** 	    if(score_mode >= SCORE_MODE_DEATH_TIME)
 661:ratt.c        **** 	      score_mode = SCORE_MODE_DEATH_TIME;
 662:ratt.c        **** 	    else
 663:ratt.c        **** 	      score_mode = SCORE_MODE_TIME;
 664:ratt.c        **** 	  }
 665:ratt.c        **** 	  else
 666:ratt.c        **** #endif
 667:ratt.c        **** 	    score_mode = SCORE_MODE_TIME;
 668:ratt.c        **** 	    if(hour_changed) {
 669:ratt.c        **** 	      time_h = old_h;
 670:ratt.c        **** 	      time_m = old_m;
 671:ratt.c        **** 	    } else if (minute_changed) {
 672:ratt.c        **** 	      time_m = old_m;
 673:ratt.c        **** 	    }
 674:ratt.c        **** 	    if(hour_changed || minute_changed) {
 675:ratt.c        **** 	      time_h = last_h;
 676:ratt.c        **** 	      time_m = last_m;
 677:ratt.c        **** 	    }
 678:ratt.c        **** 	  }
 679:ratt.c        **** 	}
 680:ratt.c        **** 
 681:ratt.c        **** 
 682:ratt.c        ****     /*DEBUG(putstring("**** "));
 683:ratt.c        ****     DEBUG(uart_putw_dec(time_h));
 684:ratt.c        ****     DEBUG(uart_putchar(':'));
 685:ratt.c        ****     DEBUG(uart_putw_dec(time_m));
 686:ratt.c        ****     DEBUG(uart_putchar(':'));
 687:ratt.c        ****     DEBUG(uart_putw_dec(time_s));
 688:ratt.c        ****     DEBUG(putstring_nl("****"));*/
 689:ratt.c        ****   }
 690:ratt.c        **** 
 691:ratt.c        ****   // check if we have an alarm set
 692:ratt.c        ****   if (alarm_on && (time_s == 0) && (time_m == alarm_m) && (time_h == alarm_h)) {
 693:ratt.c        ****     DEBUG(putstring_nl("ALARM TRIPPED!!!"));
 694:ratt.c        ****     alarm_tripped = 1;
 695:ratt.c        ****   }
 696:ratt.c        ****   
 697:ratt.c        ****   //And wait till the score changes to actually set the alarm off.
 698:ratt.c        ****   if(!minute_changed && !hour_changed && alarm_tripped) {
 699:ratt.c        ****   	 DEBUG(putstring_nl("ALARM GOING!!!!"));
 700:ratt.c        ****   	 alarming = 1;
 701:ratt.c        ****   	 alarm_tripped = 0;
 702:ratt.c        ****   }
 703:ratt.c        **** 
 704:ratt.c        ****   if (t2divider2 == 6) {
 705:ratt.c        ****     t2divider2 = 0;
 706:ratt.c        ****   } else {
 707:ratt.c        ****     t2divider2++;
 708:ratt.c        ****     return;
 709:ratt.c        ****   }
 710:ratt.c        **** 
 711:ratt.c        ****   if (buttonholdcounter) {
 712:ratt.c        ****     buttonholdcounter--;
 713:ratt.c        ****   }
 714:ratt.c        **** 
 715:ratt.c        ****   if (timeoutcounter) {
 716:ratt.c        ****     timeoutcounter--;
 717:ratt.c        ****   }
 718:ratt.c        **** }
 719:ratt.c        **** 
 720:ratt.c        **** uint8_t leapyear(uint16_t y) {
 610               	.LM57:
 611               	.LFBB8:
 612               	/* prologue: function */
 613               	/* frame size = 0 */
 614 0258 FC01      		movw r30,r24
 721:ratt.c        ****   return ( (!(y % 4) && (y % 100)) || !(y % 400));
 616               	.LM58:
 617 025a 8370      		andi r24,lo8(3)
 618 025c 9070      		andi r25,hi8(3)
 619 025e 892B      		or r24,r25
 620 0260 01F4      		brne .L32
 621 0262 CF01      		movw r24,r30
 622 0264 64E6      		ldi r22,lo8(100)
 623 0266 70E0      		ldi r23,hi8(100)
 624 0268 0E94 0000 		call __udivmodhi4
 625 026c 892B      		or r24,r25
 626 026e 01F4      		brne .L36
 627               	.L32:
 628 0270 20E0      		ldi r18,lo8(0)
 629 0272 30E0      		ldi r19,hi8(0)
 630 0274 CF01      		movw r24,r30
 631 0276 60E9      		ldi r22,lo8(400)
 632 0278 71E0      		ldi r23,hi8(400)
 633 027a 0E94 0000 		call __udivmodhi4
 634 027e 892B      		or r24,r25
 635 0280 01F4      		brne .L33
 636               	.L36:
 637 0282 21E0      		ldi r18,lo8(1)
 638 0284 30E0      		ldi r19,hi8(1)
 639               	.L33:
 722:ratt.c        **** }
 641               	.LM59:
 642 0286 822F      		mov r24,r18
 643               	/* epilogue start */
 644 0288 0895      		ret
 646               	.Lscope8:
 648               		.stabd	78,0,0
 650               	.global	tick
 652               	tick:
 653               		.stabd	46,0,0
 723:ratt.c        **** 
 724:ratt.c        **** void tick(void) {
 655               	.LM60:
 656               	.LFBB9:
 657               	/* prologue: function */
 658               	/* frame size = 0 */
 659               	/* epilogue start */
 725:ratt.c        **** 
 726:ratt.c        **** 
 727:ratt.c        **** }
 661               	.LM61:
 662 028a 0895      		ret
 664               	.Lscope9:
 666               		.stabd	78,0,0
 669               	.global	i2bcd
 671               	i2bcd:
 672               		.stabd	46,0,0
 728:ratt.c        **** 
 729:ratt.c        **** 
 730:ratt.c        **** 
 731:ratt.c        **** inline uint8_t i2bcd(uint8_t x) {
 674               	.LM62:
 675               	.LFBB10:
 676               	/* prologue: function */
 677               	/* frame size = 0 */
 678 028c 482F      		mov r20,r24
 680               	.LM63:
 681 028e 6AE0      		ldi r22,lo8(10)
 682 0290 0E94 0000 		call __udivmodqi4
 683 0294 282F      		mov r18,r24
 684 0296 30E0      		ldi r19,lo8(0)
 685 0298 84E0      		ldi r24,4
 686 029a 220F      	1:	lsl r18
 687 029c 331F      		rol r19
 688 029e 8A95      		dec r24
 689 02a0 01F4      		brne 1b
 690 02a2 842F      		mov r24,r20
 691 02a4 0E94 0000 		call __udivmodqi4
 732:ratt.c        ****   return ((x/10)<<4) | (x%10);
 733:ratt.c        **** }
 693               	.LM64:
 694 02a8 892F      		mov r24,r25
 695 02aa 822B      		or r24,r18
 696               	/* epilogue start */
 697 02ac 0895      		ret
 699               	.Lscope10:
 701               		.stabd	78,0,0
 703               	.global	setsnooze
 705               	setsnooze:
 706               		.stabd	46,0,0
 734:ratt.c        **** 
 735:ratt.c        **** 
 736:ratt.c        **** void clock_init(void) {
 737:ratt.c        ****   // talk to clock
 738:ratt.c        ****   i2cInit();
 739:ratt.c        **** 
 740:ratt.c        **** 
 741:ratt.c        ****   if (readi2ctime()) {
 742:ratt.c        ****     DEBUGP("uh oh, RTC was off, lets reset it!");
 743:ratt.c        ****     writei2ctime(0, 0, 12, 0, 1, 1, 9); // noon 1/1/2009
 744:ratt.c        ****    }
 745:ratt.c        **** 
 746:ratt.c        ****   readi2ctime();
 747:ratt.c        **** 
 748:ratt.c        ****   DEBUG(putstring("\n\rread "));
 749:ratt.c        ****   DEBUG(uart_putw_dec(time_h));
 750:ratt.c        ****   DEBUG(uart_putchar(':'));
 751:ratt.c        ****   DEBUG(uart_putw_dec(time_m));
 752:ratt.c        ****   DEBUG(uart_putchar(':'));
 753:ratt.c        ****   DEBUG(uart_putw_dec(time_s));
 754:ratt.c        **** 
 755:ratt.c        ****   DEBUG(uart_putchar('\t'));
 756:ratt.c        ****   DEBUG(uart_putw_dec(date_d));
 757:ratt.c        ****   DEBUG(uart_putchar('/'));
 758:ratt.c        ****   DEBUG(uart_putw_dec(date_m));
 759:ratt.c        ****   DEBUG(uart_putchar('/'));
 760:ratt.c        ****   DEBUG(uart_putw_dec(date_y));
 761:ratt.c        ****   DEBUG(putstring_nl(""));
 762:ratt.c        **** 
 763:ratt.c        ****   alarm_m = eeprom_read_byte(&EE_ALARM_MIN) % 60;
 764:ratt.c        ****   alarm_h = eeprom_read_byte(&EE_ALARM_HOUR) % 24;
 765:ratt.c        **** 
 766:ratt.c        **** 
 767:ratt.c        ****   //ASSR |= _BV(AS2); // use crystal
 768:ratt.c        **** 
 769:ratt.c        ****   TCCR2B = _BV(CS22) | _BV(CS21) | _BV(CS20); // div by 1024
 770:ratt.c        ****   // overflow ~30Hz = 8MHz/(255 * 1024)
 771:ratt.c        **** 
 772:ratt.c        ****   // enable interrupt
 773:ratt.c        ****   TIMSK2 = _BV(TOIE2);
 774:ratt.c        **** 
 775:ratt.c        ****   sei();
 776:ratt.c        **** }
 777:ratt.c        **** 
 778:ratt.c        **** void setsnooze(void) {
 708               	.LM65:
 709               	.LFBB11:
 710               	/* prologue: function */
 711               	/* frame size = 0 */
 779:ratt.c        ****   //snoozetimer = eeprom_read_byte(&EE_SNOOZE);
 780:ratt.c        ****   //snoozetimer *= 60; // convert minutes to seconds
 781:ratt.c        ****   snoozetimer = MAXSNOOZE;
 713               	.LM66:
 714 02ae 88E5      		ldi r24,lo8(600)
 715 02b0 92E0      		ldi r25,hi8(600)
 716 02b2 9093 0000 		sts (snoozetimer)+1,r25
 717 02b6 8093 0000 		sts snoozetimer,r24
 782:ratt.c        ****   TCCR1B = 0;
 719               	.LM67:
 720 02ba 1092 8100 		sts 129,__zero_reg__
 783:ratt.c        ****   // turn off piezo
 784:ratt.c        ****   PIEZO_PORT &= ~_BV(PIEZO);
 722               	.LM68:
 723 02be 4398      		cbi 40-32,3
 785:ratt.c        ****   DEBUGP("snooze");
 786:ratt.c        ****   //displaymode = SHOW_SNOOZE;
 787:ratt.c        ****   //delay_ms(1000);
 788:ratt.c        ****   displaymode = SHOW_TIME;
 725               	.LM69:
 726 02c0 1092 0000 		sts displaymode,__zero_reg__
 727               	/* epilogue start */
 789:ratt.c        **** }
 729               	.LM70:
 730 02c4 0895      		ret
 732               	.Lscope11:
 734               		.stabd	78,0,0
 737               	.global	DecodeGPSBuffer
 739               	DecodeGPSBuffer:
 740               		.stabd	46,0,0
 790:ratt.c        **** 
 791:ratt.c        **** #ifdef GPSENABLE
 792:ratt.c        **** 
 793:ratt.c        **** uint8_t GPSRead(uint8_t debugmode) {
 794:ratt.c        ****  // debugmode 0=quiet, 1=debug to line 6 (used by anim_gps.c)
 795:ratt.c        ****  // method, read chars dump to screen
 796:ratt.c        ****  static uint8_t soh=0;
 797:ratt.c        ****  static uint8_t blen=0;
 798:ratt.c        ****  static char buffer[11];
 799:ratt.c        ****  static int8_t dadjflag =0;
 800:ratt.c        ****  static uint8_t scrpos=0;
 801:ratt.c        ****  char ch=0;
 802:ratt.c        ****  timezone=(int8_t)eeprom_read_byte(&EE_TIMEZONE);
 803:ratt.c        ****  timezonehour=TIMEZONEHOUR;
 804:ratt.c        ****  timezonemin=TIMEZONEMIN;
 805:ratt.c        ****  if(timezone<0) {
 806:ratt.c        ****   timezonehour*=-1;
 807:ratt.c        ****   timezonemin*=-1;
 808:ratt.c        ****  }
 809:ratt.c        ****  
 810:ratt.c        ****  //                     JA FE MA AP MA JU JL AU SE OC NO DE
 811:ratt.c        ****  uint8_t monthmath[] = {31,28,31,30,31,30,31,31,30,31,30,31};
 812:ratt.c        ****  //if(!uart_getch()) return 0;
 813:ratt.c        ****  //ch = uart_getchar();
 814:ratt.c        ****  while(char_available()) {
 815:ratt.c        ****    ch = char_read();
 816:ratt.c        ****  if (ch<32 || ch>127) continue;
 817:ratt.c        ****  if (debugmode) {
 818:ratt.c        ****   glcdSetAddress(6 * scrpos++, 6); 
 819:ratt.c        ****   glcdWriteChar(ch, NORMAL); 
 820:ratt.c        ****   glcdWriteChar(32, NORMAL); 
 821:ratt.c        ****   if (scrpos>19) {scrpos=0;}
 822:ratt.c        ****  }
 823:ratt.c        ****  // Check for start of sentence
 824:ratt.c        ****  if (ch=='$') { 
 825:ratt.c        ****   soh=1; 
 826:ratt.c        ****   blen=0; 
 827:ratt.c        ****   continue;
 828:ratt.c        ****  }
 829:ratt.c        ****  // If inside a sentence...
 830:ratt.c        ****  if (soh>0) {
 831:ratt.c        **** 
 832:ratt.c        ****   // check for next field
 833:ratt.c        ****   if (ch == ',') {
 834:ratt.c        ****    soh++; 
 835:ratt.c        ****    if (blen==0) {buffer[0]=0;}  
 836:ratt.c        ****    blen=0;
 837:ratt.c        ****   }
 838:ratt.c        ****   // otherwise, add character to buffer
 839:ratt.c        ****   else { 
 840:ratt.c        ****    if (blen<10) {
 841:ratt.c        ****     buffer[blen++]=ch;
 842:ratt.c        ****     buffer[blen]=0;
 843:ratt.c        ****    } 
 844:ratt.c        ****   }
 845:ratt.c        **** 
 846:ratt.c        ****   // Process: Command
 847:ratt.c        ****   if (soh==2) {
 848:ratt.c        ****    if (!strcmp(buffer,"GPRMC")) {soh=3; blen=0; buffer[0]=0;}
 849:ratt.c        ****    else {soh=0;}
 850:ratt.c        ****    continue;
 851:ratt.c        ****   }
 852:ratt.c        ****   
 853:ratt.c        ****   // Process: Time
 854:ratt.c        ****   if (soh==4) { // Time Word
 855:ratt.c        ****    soh++;
 856:ratt.c        ****    if (debugmode) {
 857:ratt.c        ****     buffer[6]=0; 
 858:ratt.c        ****     glcdSetAddress(MENU_INDENT+60, 5); 
 859:ratt.c        ****     glcdPutStr_ram(buffer, NORMAL); 
 860:ratt.c        ****     continue;
 861:ratt.c        ****    }
 862:ratt.c        ****    cli();
 863:ratt.c        ****    time_s = DecodeGPSBuffer((char *)&buffer[4]); 
 864:ratt.c        ****    time_m = DecodeGPSBuffer((char *)&buffer[2]);
 865:ratt.c        ****    time_h = DecodeGPSBuffer(buffer);
 866:ratt.c        ****    // Adjust hour by time zone offset
 867:ratt.c        ****    // have to be careful because uint8's underflow back to 255, not -1
 868:ratt.c        ****    dadjflag =0;
 869:ratt.c        ****    if (timezonemin<0 && abs(timezonemin) > time_m) {
 870:ratt.c        ****     timezonehour--;
 871:ratt.c        ****     time_m = 60 + time_m + timezonemin;
 872:ratt.c        ****    }
 873:ratt.c        ****    else {
 874:ratt.c        ****     time_m+=timezonemin;
 875:ratt.c        ****     if (time_m>60) { // Remind us to add a day...
 876:ratt.c        ****      time_m-=60; 
 877:ratt.c        ****      timezonehour++;
 878:ratt.c        ****     }
 879:ratt.c        ****    }
 880:ratt.c        ****    if (timezonehour<0 && abs(timezonehour) > time_h) {
 881:ratt.c        ****     dadjflag=-1; // Remind us to subtract a day... 
 882:ratt.c        ****     time_h = 24 + time_h + timezonehour;
 883:ratt.c        ****    }
 884:ratt.c        ****    else {
 885:ratt.c        ****     time_h+=timezonehour;
 886:ratt.c        ****     if (time_h>24) { // Remind us to add a day...
 887:ratt.c        ****      time_h-=24; 
 888:ratt.c        ****      dadjflag=1;
 889:ratt.c        ****     }
 890:ratt.c        ****    }
 891:ratt.c        ****    continue;
 892:ratt.c        ****   }
 893:ratt.c        **** 
 894:ratt.c        ****   if (soh==6) { // LAT WORD
 895:ratt.c        ****     if (debugmode) {
 896:ratt.c        ****      glcdSetAddress(MENU_INDENT+60, 3); 
 897:ratt.c        ****      glcdPutStr_ram((!buffer[0] ? "NOLOCK" : "LOCKED"), NORMAL);
 898:ratt.c        ****     }
 899:ratt.c        ****     if (!buffer[0]) return 0;
 900:ratt.c        ****   }
 901:ratt.c        ****   
 902:ratt.c        ****   // Process: Date
 903:ratt.c        ****   if (soh==13) {// Date Word
 904:ratt.c        ****    if (debugmode) {
 905:ratt.c        ****     glcdSetAddress(MENU_INDENT+60, 4); 
 906:ratt.c        ****     glcdPutStr_ram(buffer, NORMAL); 
 907:ratt.c        ****     soh=0; 
 908:ratt.c        ****     return 1;
 909:ratt.c        ****    }
 910:ratt.c        ****    // Joy, datemath...
 911:ratt.c        ****    cli();
 912:ratt.c        ****    date_d = DecodeGPSBuffer(buffer);  
 913:ratt.c        ****    date_m = DecodeGPSBuffer((char *)&buffer[2]); 
 914:ratt.c        ****    date_y = DecodeGPSBuffer((char *)&buffer[4]);
 915:ratt.c        ****    monthmath[2-1] = (((date_y%4)==0) ? 29 : 28);	//Account for leap year for month 2. 
 916:ratt.c        ****    // dadjflag is set by the time routine to remember to add or subtract a day...
 917:ratt.c        ****    if (dadjflag) {
 918:ratt.c        ****     date_d += dadjflag;
 919:ratt.c        ****     if (!date_d) { // Subtracted to Day=0
 920:ratt.c        ****      if (!--date_m) {
 921:ratt.c        ****       date_y--;
 922:ratt.c        ****       date_m = 12;
 923:ratt.c        ****       date_d = 31;
 924:ratt.c        ****      }
 925:ratt.c        ****      else {
 926:ratt.c        ****      date_d = monthmath[date_m-1];
 927:ratt.c        ****      }     
 928:ratt.c        ****     }
 929:ratt.c        ****     else { // check for date > end of month (including leap year calc)
 930:ratt.c        ****      if (date_d > monthmath[date_m-1]) {
 931:ratt.c        ****       date_d = 1;
 932:ratt.c        ****       date_m++;
 933:ratt.c        ****       if (date_m>12) {
 934:ratt.c        ****        date_y++; 
 935:ratt.c        ****        date_m=1;
 936:ratt.c        ****       }
 937:ratt.c        ****      }
 938:ratt.c        ****     }
 939:ratt.c        ****    }
 940:ratt.c        ****    return 1;
 941:ratt.c        ****   }
 942:ratt.c        ****   }
 943:ratt.c        ****  }
 944:ratt.c        **** 
 945:ratt.c        ****  return 0;
 946:ratt.c        **** }
 947:ratt.c        **** 
 948:ratt.c        **** void GPSCheck(uint8_t mode) {
 949:ratt.c        ****  if (GPSRead(mode) && !mode) {
 950:ratt.c        ****   writei2ctime(time_s, time_m, time_h, dotw(date_m, date_d, date_y), date_d, date_m, date_y);
 951:ratt.c        ****   sei();
 952:ratt.c        ****  } 
 953:ratt.c        **** }
 954:ratt.c        **** 
 955:ratt.c        **** 
 956:ratt.c        **** // Decodes a 2 char number to uint8
 957:ratt.c        **** uint8_t DecodeGPSBuffer(char *cBuffer) {
 742               	.LM71:
 743               	.LFBB12:
 744               	/* prologue: function */
 745               	/* frame size = 0 */
 746 02c6 FC01      		movw r30,r24
 748               	.LM72:
 749 02c8 8181      		ldd r24,Z+1
 750 02ca 8051      		subi r24,lo8(-(-16))
 751 02cc 2081      		ld r18,Z
 752 02ce 9AE0      		ldi r25,lo8(10)
 753 02d0 299F      		mul r18,r25
 754 02d2 9001      		movw r18,r0
 755 02d4 1124      		clr r1
 958:ratt.c        ****  return ((cBuffer[0]-48)*10) + (cBuffer[1]-48);
 959:ratt.c        **** }
 757               	.LM73:
 758 02d6 820F      		add r24,r18
 759               	/* epilogue start */
 760 02d8 0895      		ret
 762               	.Lscope12:
 764               		.stabd	78,0,0
 768               	.global	printnumber
 770               	printnumber:
 771               		.stabd	46,0,0
 525:ratt.c        **** void printnumber(uint8_t n, uint8_t inverted) {
 773               	.LM74:
 774               	.LFBB13:
 775 02da 0F93      		push r16
 776 02dc 1F93      		push r17
 777               	/* prologue: function */
 778               	/* frame size = 0 */
 779 02de 182F      		mov r17,r24
 780 02e0 062F      		mov r16,r22
 526:ratt.c        ****   glcdWriteChar(n/10+'0', inverted);
 782               	.LM75:
 783 02e2 6AE0      		ldi r22,lo8(10)
 784 02e4 0E94 0000 		call __udivmodqi4
 785 02e8 805D      		subi r24,lo8(-(48))
 786 02ea 602F      		mov r22,r16
 787 02ec 0E94 0000 		call glcdWriteChar
 527:ratt.c        ****   glcdWriteChar(n%10+'0', inverted);
 789               	.LM76:
 790 02f0 812F      		mov r24,r17
 791 02f2 6AE0      		ldi r22,lo8(10)
 792 02f4 0E94 0000 		call __udivmodqi4
 793 02f8 892F      		mov r24,r25
 794 02fa 805D      		subi r24,lo8(-(48))
 795 02fc 602F      		mov r22,r16
 796 02fe 0E94 0000 		call glcdWriteChar
 797               	/* epilogue start */
 528:ratt.c        **** }
 799               	.LM77:
 800 0302 1F91      		pop r17
 801 0304 0F91      		pop r16
 802 0306 0895      		ret
 804               	.Lscope13:
 806               		.stabd	78,0,0
 807               		.data
 808               	.LC0:
 809 0000 4750 524D 		.string	"GPRMC"
 809      4300 
 810               	.LC1:
 811 0006 4C4F 434B 		.string	"LOCKED"
 811      4544 00
 812               	.LC2:
 813 000d 4E4F 4C4F 		.string	"NOLOCK"
 813      434B 00
 814               		.text
 817               	.global	GPSRead
 819               	GPSRead:
 820               		.stabd	46,0,0
 794:ratt.c        **** uint8_t GPSRead(uint8_t debugmode) {
 822               	.LM78:
 823               	.LFBB14:
 824 0308 BF92      		push r11
 825 030a CF92      		push r12
 826 030c DF92      		push r13
 827 030e EF92      		push r14
 828 0310 FF92      		push r15
 829 0312 0F93      		push r16
 830 0314 1F93      		push r17
 831 0316 DF93      		push r29
 832 0318 CF93      		push r28
 833 031a CDB7      		in r28,__SP_L__
 834 031c DEB7      		in r29,__SP_H__
 835 031e 2C97      		sbiw r28,12
 836 0320 0FB6      		in __tmp_reg__,__SREG__
 837 0322 F894      		cli
 838 0324 DEBF      		out __SP_H__,r29
 839 0326 0FBE      		out __SREG__,__tmp_reg__
 840 0328 CDBF      		out __SP_L__,r28
 841               	/* prologue: function */
 842               	/* frame size = 12 */
 843 032a 082F      		mov r16,r24
 803:ratt.c        ****  timezone=(int8_t)eeprom_read_byte(&EE_TIMEZONE);
 845               	.LM79:
 846 032c 80E0      		ldi r24,lo8(EE_TIMEZONE)
 847 032e 90E0      		ldi r25,hi8(EE_TIMEZONE)
 848 0330 0E94 0000 		call __eerd_byte_m328p
 849 0334 8093 0000 		sts timezone,r24
 804:ratt.c        ****  timezonehour=TIMEZONEHOUR;
 851               	.LM80:
 852 0338 8091 0000 		lds r24,timezone
 853 033c 9927      		clr r25
 854 033e 87FD      		sbrc r24,7
 855 0340 9095      		com r25
 856 0342 97FF      		sbrs r25,7
 857 0344 00C0      		rjmp .L48
 858 0346 9095      		com r25
 859 0348 8195      		neg r24
 860 034a 9F4F      		sbci r25,lo8(-1)
 861               	.L48:
 862 034c 9595      		asr r25
 863 034e 8795      		ror r24
 864 0350 9595      		asr r25
 865 0352 8795      		ror r24
 866 0354 8093 0000 		sts timezonehour,r24
 805:ratt.c        ****  timezonemin=TIMEZONEMIN;
 868               	.LM81:
 869 0358 8091 0000 		lds r24,timezone
 870 035c 9927      		clr r25
 871 035e 87FD      		sbrc r24,7
 872 0360 9095      		com r25
 873 0362 97FF      		sbrs r25,7
 874 0364 00C0      		rjmp .L49
 875 0366 9095      		com r25
 876 0368 8195      		neg r24
 877 036a 9F4F      		sbci r25,lo8(-1)
 878               	.L49:
 879 036c 8370      		andi r24,lo8(3)
 880 036e 9070      		andi r25,hi8(3)
 881 0370 9C01      		movw r18,r24
 882 0372 44E0      		ldi r20,4
 883 0374 220F      	1:	lsl r18
 884 0376 331F      		rol r19
 885 0378 4A95      		dec r20
 886 037a 01F4      		brne 1b
 887 037c 281B      		sub r18,r24
 888 037e 390B      		sbc r19,r25
 889 0380 2093 0000 		sts timezonemin,r18
 806:ratt.c        ****  if(timezone<0) {
 891               	.LM82:
 892 0384 8091 0000 		lds r24,timezone
 893 0388 87FF      		sbrs r24,7
 894 038a 00C0      		rjmp .L50
 807:ratt.c        ****   timezonehour*=-1;
 896               	.LM83:
 897 038c 8091 0000 		lds r24,timezonehour
 898 0390 8195      		neg r24
 899 0392 8093 0000 		sts timezonehour,r24
 808:ratt.c        ****   timezonemin*=-1;
 901               	.LM84:
 902 0396 8091 0000 		lds r24,timezonemin
 903 039a 8195      		neg r24
 904 039c 8093 0000 		sts timezonemin,r24
 905               	.L50:
 812:ratt.c        ****  uint8_t monthmath[] = {31,28,31,30,31,30,31,31,30,31,30,31};
 907               	.LM85:
 908 03a0 DE01      		movw r26,r28
 909 03a2 1196      		adiw r26,1
 910 03a4 E0E0      		ldi r30,lo8(C.122.2689)
 911 03a6 F0E0      		ldi r31,hi8(C.122.2689)
 912 03a8 8CE0      		ldi r24,lo8(12)
 913               	.L51:
 914 03aa 0190      		ld r0,Z+
 915 03ac 0D92      		st X+,r0
 916 03ae 8150      		subi r24,lo8(-(-1))
 917 03b0 01F4      		brne .L51
 918 03b2 00C0      		rjmp .L87
 919               	.L79:
 816:ratt.c        ****    ch = char_read();
 921               	.LM86:
 922 03b4 0E94 0000 		call char_read
 923 03b8 182F      		mov r17,r24
 817:ratt.c        ****  if (ch<32 || ch>127) continue;
 925               	.LM87:
 926 03ba 8052      		subi r24,lo8(-(-32))
 927 03bc 8036      		cpi r24,lo8(96)
 928 03be 00F0      		brlo .+2
 929 03c0 00C0      		rjmp .L84
 818:ratt.c        ****  if (debugmode) {
 931               	.LM88:
 932 03c2 0023      		tst r16
 933 03c4 01F0      		breq .L53
 819:ratt.c        ****   glcdSetAddress(6 * scrpos++, 6); 
 935               	.LM89:
 936 03c6 8091 0000 		lds r24,scrpos.2665
 937 03ca 8F5F      		subi r24,lo8(-(1))
 938 03cc 8093 0000 		sts scrpos.2665,r24
 939 03d0 8150      		subi r24,lo8(-(-1))
 940 03d2 8C9D      		mul r24,r12
 941 03d4 802D      		mov r24,r0
 942 03d6 1124      		clr r1
 943 03d8 66E0      		ldi r22,lo8(6)
 944 03da 0E94 0000 		call glcdSetAddress
 820:ratt.c        ****   glcdWriteChar(ch, NORMAL); 
 946               	.LM90:
 947 03de 812F      		mov r24,r17
 948 03e0 60E0      		ldi r22,lo8(0)
 949 03e2 0E94 0000 		call glcdWriteChar
 821:ratt.c        ****   glcdWriteChar(32, NORMAL); 
 951               	.LM91:
 952 03e6 80E2      		ldi r24,lo8(32)
 953 03e8 60E0      		ldi r22,lo8(0)
 954 03ea 0E94 0000 		call glcdWriteChar
 822:ratt.c        ****   if (scrpos>19) {scrpos=0;}
 956               	.LM92:
 957 03ee 8091 0000 		lds r24,scrpos.2665
 958 03f2 8431      		cpi r24,lo8(20)
 959 03f4 00F0      		brlo .L53
 960 03f6 1092 0000 		sts scrpos.2665,__zero_reg__
 961               	.L53:
 825:ratt.c        ****  if (ch=='$') { 
 963               	.LM93:
 964 03fa 1432      		cpi r17,lo8(36)
 965 03fc 01F4      		brne .L54
 826:ratt.c        ****   soh=1; 
 967               	.LM94:
 968 03fe E092 0000 		sts soh.2661,r14
 827:ratt.c        ****   blen=0; 
 970               	.LM95:
 971 0402 1092 0000 		sts blen.2662,__zero_reg__
 972 0406 00C0      		rjmp .L84
 973               	.L54:
 831:ratt.c        ****  if (soh>0) {
 975               	.LM96:
 976 0408 8091 0000 		lds r24,soh.2661
 977 040c 8823      		tst r24
 978 040e 01F4      		brne .+2
 979 0410 00C0      		rjmp .L84
 980 0412 9091 0000 		lds r25,blen.2662
 834:ratt.c        ****   if (ch == ',') {
 982               	.LM97:
 983 0416 1C32      		cpi r17,lo8(44)
 984 0418 01F4      		brne .L55
 835:ratt.c        ****    soh++; 
 986               	.LM98:
 987 041a 8F5F      		subi r24,lo8(-(1))
 988 041c 8093 0000 		sts soh.2661,r24
 836:ratt.c        ****    if (blen==0) {buffer[0]=0;}  
 990               	.LM99:
 991 0420 9923      		tst r25
 992 0422 01F4      		brne .L56
 993 0424 1092 0000 		sts buffer.2663,__zero_reg__
 994               	.L56:
 837:ratt.c        ****    blen=0;
 996               	.LM100:
 997 0428 1092 0000 		sts blen.2662,__zero_reg__
 998 042c 00C0      		rjmp .L57
 999               	.L55:
 841:ratt.c        ****    if (blen<10) {
 1001               	.LM101:
 1002 042e 9A30      		cpi r25,lo8(10)
 1003 0430 00F4      		brsh .L57
 842:ratt.c        ****     buffer[blen++]=ch;
 1005               	.LM102:
 1006 0432 E92F      		mov r30,r25
 1007 0434 F0E0      		ldi r31,lo8(0)
 1008 0436 E050      		subi r30,lo8(-(buffer.2663))
 1009 0438 F040      		sbci r31,hi8(-(buffer.2663))
 1010 043a 1083      		st Z,r17
 1011 043c E92F      		mov r30,r25
 1012 043e EF5F      		subi r30,lo8(-(1))
 1013 0440 E093 0000 		sts blen.2662,r30
 843:ratt.c        ****     buffer[blen]=0;
 1015               	.LM103:
 1016 0444 F0E0      		ldi r31,lo8(0)
 1017 0446 E050      		subi r30,lo8(-(buffer.2663))
 1018 0448 F040      		sbci r31,hi8(-(buffer.2663))
 1019 044a 1082      		st Z,__zero_reg__
 1020               	.L57:
 848:ratt.c        ****   if (soh==2) {
 1022               	.LM104:
 1023 044c 8091 0000 		lds r24,soh.2661
 1024 0450 8230      		cpi r24,lo8(2)
 1025 0452 01F4      		brne .L58
 849:ratt.c        ****    if (!strcmp(buffer,"GPRMC")) {soh=3; blen=0; buffer[0]=0;}
 1027               	.LM105:
 1028 0454 80E0      		ldi r24,lo8(buffer.2663)
 1029 0456 90E0      		ldi r25,hi8(buffer.2663)
 1030 0458 60E0      		ldi r22,lo8(.LC0)
 1031 045a 70E0      		ldi r23,hi8(.LC0)
 1032 045c 0E94 0000 		call strcmp
 1033 0460 0097      		sbiw r24,0
 1034 0462 01F4      		brne .L59
 1035 0464 83E0      		ldi r24,lo8(3)
 1036 0466 8093 0000 		sts soh.2661,r24
 1037 046a 1092 0000 		sts blen.2662,__zero_reg__
 1038 046e 1092 0000 		sts buffer.2663,__zero_reg__
 1039 0472 00C0      		rjmp .L84
 1040               	.L59:
 850:ratt.c        ****    else {soh=0;}
 1042               	.LM106:
 1043 0474 1092 0000 		sts soh.2661,__zero_reg__
 1044 0478 00C0      		rjmp .L84
 1045               	.L58:
 855:ratt.c        ****   if (soh==4) { // Time Word
 1047               	.LM107:
 1048 047a 8430      		cpi r24,lo8(4)
 1049 047c 01F0      		breq .+2
 1050 047e 00C0      		rjmp .L60
 856:ratt.c        ****    soh++;
 1052               	.LM108:
 1053 0480 B092 0000 		sts soh.2661,r11
 857:ratt.c        ****    if (debugmode) {
 1055               	.LM109:
 1056 0484 0023      		tst r16
 1057 0486 01F0      		breq .L61
 858:ratt.c        ****     buffer[6]=0; 
 1059               	.LM110:
 1060 0488 1092 0000 		sts buffer.2663+6,__zero_reg__
 859:ratt.c        ****     glcdSetAddress(MENU_INDENT+60, 5); 
 1062               	.LM111:
 1063 048c 84E4      		ldi r24,lo8(68)
 1064 048e 65E0      		ldi r22,lo8(5)
 1065 0490 0E94 0000 		call glcdSetAddress
 860:ratt.c        ****     glcdPutStr_ram(buffer, NORMAL); 
 1067               	.LM112:
 1068 0494 80E0      		ldi r24,lo8(buffer.2663)
 1069 0496 90E0      		ldi r25,hi8(buffer.2663)
 1070 0498 60E0      		ldi r22,lo8(0)
 1071 049a 0E94 0000 		call glcdPutStr_ram
 1072 049e 00C0      		rjmp .L84
 1073               	.L61:
 863:ratt.c        ****    cli();
 1075               	.LM113:
 1076               	/* #APP */
 1077               	 ;  863 "ratt.c" 1
 1078 04a0 F894      		cli
 1079               	 ;  0 "" 2
 1080               	/* #NOAPP */
 1081               	.LBB23:
 1082               	.LBB24:
 959:ratt.c        ****  return ((cBuffer[0]-48)*10) + (cBuffer[1]-48);
 1084               	.LM114:
 1085 04a2 2091 0000 		lds r18,buffer.2663+5
 1086 04a6 2051      		subi r18,lo8(-(-16))
 1087 04a8 8091 0000 		lds r24,buffer.2663+4
 1088 04ac 8F9D      		mul r24,r15
 1089 04ae C001      		movw r24,r0
 1090 04b0 1124      		clr r1
 1091 04b2 280F      		add r18,r24
 1092               	.LBE24:
 1093               	.LBE23:
 864:ratt.c        ****    time_s = DecodeGPSBuffer((char *)&buffer[4]); 
 1095               	.LM115:
 1096 04b4 2093 0000 		sts time_s,r18
 1097               	.LBB26:
 1098               	.LBB27:
 959:ratt.c        ****  return ((cBuffer[0]-48)*10) + (cBuffer[1]-48);
 1100               	.LM116:
 1101 04b8 2091 0000 		lds r18,buffer.2663+3
 1102 04bc 2051      		subi r18,lo8(-(-16))
 1103 04be 8091 0000 		lds r24,buffer.2663+2
 1104 04c2 8F9D      		mul r24,r15
 1105 04c4 C001      		movw r24,r0
 1106 04c6 1124      		clr r1
 1107 04c8 280F      		add r18,r24
 1108               	.LBE27:
 1109               	.LBE26:
 865:ratt.c        ****    time_m = DecodeGPSBuffer((char *)&buffer[2]);
 1111               	.LM117:
 1112 04ca 2093 0000 		sts time_m,r18
 1113               	.LBB28:
 1114               	.LBB29:
 959:ratt.c        ****  return ((cBuffer[0]-48)*10) + (cBuffer[1]-48);
 1116               	.LM118:
 1117 04ce 2091 0000 		lds r18,buffer.2663+1
 1118 04d2 2051      		subi r18,lo8(-(-16))
 1119 04d4 8091 0000 		lds r24,buffer.2663
 1120 04d8 8F9D      		mul r24,r15
 1121 04da C001      		movw r24,r0
 1122 04dc 1124      		clr r1
 1123 04de 280F      		add r18,r24
 1124               	.LBE29:
 1125               	.LBE28:
 866:ratt.c        ****    time_h = DecodeGPSBuffer(buffer);
 1127               	.LM119:
 1128 04e0 2093 0000 		sts time_h,r18
 869:ratt.c        ****    dadjflag =0;
 1130               	.LM120:
 1131 04e4 1092 0000 		sts dadjflag.2664,__zero_reg__
 870:ratt.c        ****    if (timezonemin<0 && abs(timezonemin) > time_m) {
 1133               	.LM121:
 1134 04e8 8091 0000 		lds r24,timezonemin
 1135 04ec 87FF      		sbrs r24,7
 1136 04ee 00C0      		rjmp .L62
 1137 04f0 8091 0000 		lds r24,timezonemin
 1138 04f4 9091 0000 		lds r25,time_m
 1139 04f8 282F      		mov r18,r24
 1140 04fa 3327      		clr r19
 1141 04fc 27FD      		sbrc r18,7
 1142 04fe 3095      		com r19
 1143 0500 37FF      		sbrs r19,7
 1144 0502 00C0      		rjmp .L63
 1145 0504 3095      		com r19
 1146 0506 2195      		neg r18
 1147 0508 3F4F      		sbci r19,lo8(-1)
 1148               	.L63:
 1149 050a 892F      		mov r24,r25
 1150 050c 90E0      		ldi r25,lo8(0)
 1151 050e 8217      		cp r24,r18
 1152 0510 9307      		cpc r25,r19
 1153 0512 04F4      		brge .L62
 871:ratt.c        ****     timezonehour--;
 1155               	.LM122:
 1156 0514 8091 0000 		lds r24,timezonehour
 1157 0518 8150      		subi r24,lo8(-(-1))
 1158 051a 8093 0000 		sts timezonehour,r24
 872:ratt.c        ****     time_m = 60 + time_m + timezonemin;
 1160               	.LM123:
 1161 051e 8091 0000 		lds r24,time_m
 1162 0522 9091 0000 		lds r25,timezonemin
 1163 0526 845C      		subi r24,lo8(-(60))
 1164 0528 890F      		add r24,r25
 1165 052a 8093 0000 		sts time_m,r24
 1166 052e 00C0      		rjmp .L64
 1167               	.L62:
 875:ratt.c        ****     time_m+=timezonemin;
 1169               	.LM124:
 1170 0530 8091 0000 		lds r24,time_m
 1171 0534 9091 0000 		lds r25,timezonemin
 1172 0538 980F      		add r25,r24
 1173 053a 9093 0000 		sts time_m,r25
 876:ratt.c        ****     if (time_m>60) { // Remind us to add a day...
 1175               	.LM125:
 1176 053e 8091 0000 		lds r24,time_m
 1177 0542 8D33      		cpi r24,lo8(61)
 1178 0544 00F0      		brlo .L64
 877:ratt.c        ****      time_m-=60; 
 1180               	.LM126:
 1181 0546 8091 0000 		lds r24,time_m
 1182 054a 8C53      		subi r24,lo8(-(-60))
 1183 054c 8093 0000 		sts time_m,r24
 878:ratt.c        ****      timezonehour++;
 1185               	.LM127:
 1186 0550 8091 0000 		lds r24,timezonehour
 1187 0554 8F5F      		subi r24,lo8(-(1))
 1188 0556 8093 0000 		sts timezonehour,r24
 1189               	.L64:
 881:ratt.c        ****    if (timezonehour<0 && abs(timezonehour) > time_h) {
 1191               	.LM128:
 1192 055a 8091 0000 		lds r24,timezonehour
 1193 055e 87FF      		sbrs r24,7
 1194 0560 00C0      		rjmp .L65
 1195 0562 8091 0000 		lds r24,timezonehour
 1196 0566 9091 0000 		lds r25,time_h
 1197 056a 282F      		mov r18,r24
 1198 056c 3327      		clr r19
 1199 056e 27FD      		sbrc r18,7
 1200 0570 3095      		com r19
 1201 0572 37FF      		sbrs r19,7
 1202 0574 00C0      		rjmp .L66
 1203 0576 3095      		com r19
 1204 0578 2195      		neg r18
 1205 057a 3F4F      		sbci r19,lo8(-1)
 1206               	.L66:
 1207 057c 892F      		mov r24,r25
 1208 057e 90E0      		ldi r25,lo8(0)
 1209 0580 8217      		cp r24,r18
 1210 0582 9307      		cpc r25,r19
 1211 0584 04F4      		brge .L65
 882:ratt.c        ****     dadjflag=-1; // Remind us to subtract a day... 
 1213               	.LM129:
 1214 0586 D092 0000 		sts dadjflag.2664,r13
 883:ratt.c        ****     time_h = 24 + time_h + timezonehour;
 1216               	.LM130:
 1217 058a 8091 0000 		lds r24,time_h
 1218 058e 9091 0000 		lds r25,timezonehour
 1219 0592 885E      		subi r24,lo8(-(24))
 1220 0594 890F      		add r24,r25
 1221 0596 8093 0000 		sts time_h,r24
 1222 059a 00C0      		rjmp .L84
 1223               	.L65:
 886:ratt.c        ****     time_h+=timezonehour;
 1225               	.LM131:
 1226 059c 8091 0000 		lds r24,time_h
 1227 05a0 9091 0000 		lds r25,timezonehour
 1228 05a4 980F      		add r25,r24
 1229 05a6 9093 0000 		sts time_h,r25
 887:ratt.c        ****     if (time_h>24) { // Remind us to add a day...
 1231               	.LM132:
 1232 05aa 8091 0000 		lds r24,time_h
 1233 05ae 8931      		cpi r24,lo8(25)
 1234 05b0 00F4      		brsh .+2
 1235 05b2 00C0      		rjmp .L84
 888:ratt.c        ****      time_h-=24; 
 1237               	.LM133:
 1238 05b4 8091 0000 		lds r24,time_h
 1239 05b8 8851      		subi r24,lo8(-(-24))
 1240 05ba 8093 0000 		sts time_h,r24
 889:ratt.c        ****      dadjflag=1;
 1242               	.LM134:
 1243 05be E092 0000 		sts dadjflag.2664,r14
 1244 05c2 00C0      		rjmp .L84
 1245               	.L60:
 895:ratt.c        ****   if (soh==6) { // LAT WORD
 1247               	.LM135:
 1248 05c4 8630      		cpi r24,lo8(6)
 1249 05c6 01F4      		brne .L67
 896:ratt.c        ****     if (debugmode) {
 1251               	.LM136:
 1252 05c8 0023      		tst r16
 1253 05ca 01F0      		breq .L68
 897:ratt.c        ****      glcdSetAddress(MENU_INDENT+60, 3); 
 1255               	.LM137:
 1256 05cc 84E4      		ldi r24,lo8(68)
 1257 05ce 63E0      		ldi r22,lo8(3)
 1258 05d0 0E94 0000 		call glcdSetAddress
 898:ratt.c        ****      glcdPutStr_ram((!buffer[0] ? "NOLOCK" : "LOCKED"), NORMAL);
 1260               	.LM138:
 1261 05d4 8091 0000 		lds r24,buffer.2663
 1262 05d8 8823      		tst r24
 1263 05da 01F0      		breq .L69
 1264 05dc 80E0      		ldi r24,lo8(.LC1)
 1265 05de 90E0      		ldi r25,hi8(.LC1)
 1266 05e0 00C0      		rjmp .L70
 1267               	.L69:
 1268 05e2 80E0      		ldi r24,lo8(.LC2)
 1269 05e4 90E0      		ldi r25,hi8(.LC2)
 1270               	.L70:
 1271 05e6 60E0      		ldi r22,lo8(0)
 1272 05e8 0E94 0000 		call glcdPutStr_ram
 1273               	.L68:
 900:ratt.c        ****     if (!buffer[0]) return 0;
 1275               	.LM139:
 1276 05ec 8091 0000 		lds r24,buffer.2663
 1277 05f0 8823      		tst r24
 1278 05f2 01F4      		brne .+2
 1279 05f4 00C0      		rjmp .L71
 1280               	.L67:
 904:ratt.c        ****   if (soh==13) {// Date Word
 1282               	.LM140:
 1283 05f6 8091 0000 		lds r24,soh.2661
 1284 05fa 8D30      		cpi r24,lo8(13)
 1285 05fc 01F0      		breq .+2
 1286 05fe 00C0      		rjmp .L84
 905:ratt.c        ****    if (debugmode) {
 1288               	.LM141:
 1289 0600 0023      		tst r16
 1290 0602 01F0      		breq .L72
 906:ratt.c        ****     glcdSetAddress(MENU_INDENT+60, 4); 
 1292               	.LM142:
 1293 0604 84E4      		ldi r24,lo8(68)
 1294 0606 64E0      		ldi r22,lo8(4)
 1295 0608 0E94 0000 		call glcdSetAddress
 907:ratt.c        ****     glcdPutStr_ram(buffer, NORMAL); 
 1297               	.LM143:
 1298 060c 80E0      		ldi r24,lo8(buffer.2663)
 1299 060e 90E0      		ldi r25,hi8(buffer.2663)
 1300 0610 60E0      		ldi r22,lo8(0)
 1301 0612 0E94 0000 		call glcdPutStr_ram
 908:ratt.c        ****     soh=0; 
 1303               	.LM144:
 1304 0616 1092 0000 		sts soh.2661,__zero_reg__
 1305 061a 00C0      		rjmp .L76
 1306               	.L72:
 912:ratt.c        ****    cli();
 1308               	.LM145:
 1309               	/* #APP */
 1310               	 ;  912 "ratt.c" 1
 1311 061c F894      		cli
 1312               	 ;  0 "" 2
 1313               	/* #NOAPP */
 1314               	.LBB30:
 1315               	.LBB31:
 959:ratt.c        ****  return ((cBuffer[0]-48)*10) + (cBuffer[1]-48);
 1317               	.LM146:
 1318 061e 2091 0000 		lds r18,buffer.2663+1
 1319 0622 2051      		subi r18,lo8(-(-16))
 1320 0624 8091 0000 		lds r24,buffer.2663
 1321 0628 3AE0      		ldi r19,lo8(10)
 1322 062a 839F      		mul r24,r19
 1323 062c C001      		movw r24,r0
 1324 062e 1124      		clr r1
 1325 0630 280F      		add r18,r24
 1326               	.LBE31:
 1327               	.LBE30:
 913:ratt.c        ****    date_d = DecodeGPSBuffer(buffer);  
 1329               	.LM147:
 1330 0632 2093 0000 		sts date_d,r18
 1331               	.LBB32:
 1332               	.LBB33:
 959:ratt.c        ****  return ((cBuffer[0]-48)*10) + (cBuffer[1]-48);
 1334               	.LM148:
 1335 0636 2091 0000 		lds r18,buffer.2663+3
 1336 063a 2051      		subi r18,lo8(-(-16))
 1337 063c 8091 0000 		lds r24,buffer.2663+2
 1338 0640 839F      		mul r24,r19
 1339 0642 C001      		movw r24,r0
 1340 0644 1124      		clr r1
 1341 0646 280F      		add r18,r24
 1342               	.LBE33:
 1343               	.LBE32:
 914:ratt.c        ****    date_m = DecodeGPSBuffer((char *)&buffer[2]); 
 1345               	.LM149:
 1346 0648 2093 0000 		sts date_m,r18
 1347               	.LBB34:
 1348               	.LBB35:
 959:ratt.c        ****  return ((cBuffer[0]-48)*10) + (cBuffer[1]-48);
 1350               	.LM150:
 1351 064c 2091 0000 		lds r18,buffer.2663+5
 1352 0650 2051      		subi r18,lo8(-(-16))
 1353 0652 8091 0000 		lds r24,buffer.2663+4
 1354 0656 839F      		mul r24,r19
 1355 0658 C001      		movw r24,r0
 1356 065a 1124      		clr r1
 1357 065c 280F      		add r18,r24
 1358               	.LBE35:
 1359               	.LBE34:
 915:ratt.c        ****    date_y = DecodeGPSBuffer((char *)&buffer[4]);
 1361               	.LM151:
 1362 065e 2093 0000 		sts date_y,r18
 916:ratt.c        ****    monthmath[2-1] = (((date_y%4)==0) ? 29 : 28);	//Account for leap year for month 2. 
 1364               	.LM152:
 1365 0662 8091 0000 		lds r24,date_y
 1366 0666 90E0      		ldi r25,lo8(0)
 1367 0668 8370      		andi r24,lo8(3)
 1368 066a 9070      		andi r25,hi8(3)
 1369 066c 892B      		or r24,r25
 1370 066e 01F0      		breq .L74
 1371 0670 8CE1      		ldi r24,lo8(28)
 1372 0672 00C0      		rjmp .L75
 1373               	.L74:
 1374 0674 8DE1      		ldi r24,lo8(29)
 1375               	.L75:
 918:ratt.c        ****    if (dadjflag) {
 1377               	.LM153:
 1378 0676 9091 0000 		lds r25,dadjflag.2664
 1379 067a 9923      		tst r25
 1380 067c 01F4      		brne .+2
 1381 067e 00C0      		rjmp .L76
 916:ratt.c        ****    monthmath[2-1] = (((date_y%4)==0) ? 29 : 28);	//Account for leap year for month 2. 
 1383               	.LM154:
 1384 0680 8A83      		std Y+2,r24
 919:ratt.c        ****     date_d += dadjflag;
 1386               	.LM155:
 1387 0682 8091 0000 		lds r24,date_d
 1388 0686 980F      		add r25,r24
 1389 0688 9093 0000 		sts date_d,r25
 920:ratt.c        ****     if (!date_d) { // Subtracted to Day=0
 1391               	.LM156:
 1392 068c 8091 0000 		lds r24,date_d
 1393 0690 8823      		tst r24
 1394 0692 01F4      		brne .L77
 921:ratt.c        ****      if (!--date_m) {
 1396               	.LM157:
 1397 0694 8091 0000 		lds r24,date_m
 1398 0698 8150      		subi r24,lo8(-(-1))
 1399 069a 8093 0000 		sts date_m,r24
 1400 069e 8091 0000 		lds r24,date_m
 1401 06a2 8823      		tst r24
 1402 06a4 01F4      		brne .L78
 922:ratt.c        ****       date_y--;
 1404               	.LM158:
 1405 06a6 8091 0000 		lds r24,date_y
 1406 06aa 8150      		subi r24,lo8(-(-1))
 1407 06ac 8093 0000 		sts date_y,r24
 923:ratt.c        ****       date_m = 12;
 1409               	.LM159:
 1410 06b0 8CE0      		ldi r24,lo8(12)
 1411 06b2 8093 0000 		sts date_m,r24
 924:ratt.c        ****       date_d = 31;
 1413               	.LM160:
 1414 06b6 8FE1      		ldi r24,lo8(31)
 1415 06b8 00C0      		rjmp .L86
 1416               	.L78:
 927:ratt.c        ****      date_d = monthmath[date_m-1];
 1418               	.LM161:
 1419 06ba 8091 0000 		lds r24,date_m
 1420 06be FE01      		movw r30,r28
 1421 06c0 E80F      		add r30,r24
 1422 06c2 F11D      		adc r31,__zero_reg__
 1423 06c4 8081      		ld r24,Z
 1424               	.L86:
 1425 06c6 8093 0000 		sts date_d,r24
 1426 06ca 00C0      		rjmp .L76
 1427               	.L77:
 931:ratt.c        ****      if (date_d > monthmath[date_m-1]) {
 1429               	.LM162:
 1430 06cc 9091 0000 		lds r25,date_d
 1431 06d0 8091 0000 		lds r24,date_m
 1432 06d4 FE01      		movw r30,r28
 1433 06d6 E80F      		add r30,r24
 1434 06d8 F11D      		adc r31,__zero_reg__
 1435 06da 8081      		ld r24,Z
 1436 06dc 8917      		cp r24,r25
 1437 06de 00F4      		brsh .L76
 932:ratt.c        ****       date_d = 1;
 1439               	.LM163:
 1440 06e0 91E0      		ldi r25,lo8(1)
 1441 06e2 9093 0000 		sts date_d,r25
 933:ratt.c        ****       date_m++;
 1443               	.LM164:
 1444 06e6 8091 0000 		lds r24,date_m
 1445 06ea 8F5F      		subi r24,lo8(-(1))
 1446 06ec 8093 0000 		sts date_m,r24
 934:ratt.c        ****       if (date_m>12) {
 1448               	.LM165:
 1449 06f0 8091 0000 		lds r24,date_m
 1450 06f4 8D30      		cpi r24,lo8(13)
 1451 06f6 00F0      		brlo .L76
 935:ratt.c        ****        date_y++; 
 1453               	.LM166:
 1454 06f8 8091 0000 		lds r24,date_y
 1455 06fc 8F5F      		subi r24,lo8(-(1))
 1456 06fe 8093 0000 		sts date_y,r24
 936:ratt.c        ****        date_m=1;
 1458               	.LM167:
 1459 0702 9093 0000 		sts date_m,r25
 1460 0706 00C0      		rjmp .L76
 1461               	.L87:
 856:ratt.c        ****    soh++;
 1463               	.LM168:
 1464 0708 35E0      		ldi r19,lo8(5)
 1465 070a B32E      		mov r11,r19
 1466               	.LBB36:
 1467               	.LBB25:
 959:ratt.c        ****  return ((cBuffer[0]-48)*10) + (cBuffer[1]-48);
 1469               	.LM169:
 1470 070c 2AE0      		ldi r18,lo8(10)
 1471 070e F22E      		mov r15,r18
 1472               	.LBE25:
 1473               	.LBE36:
 889:ratt.c        ****      dadjflag=1;
 1475               	.LM170:
 1476 0710 EE24      		clr r14
 1477 0712 E394      		inc r14
 882:ratt.c        ****     dadjflag=-1; // Remind us to subtract a day... 
 1479               	.LM171:
 1480 0714 DD24      		clr r13
 1481 0716 DA94      		dec r13
 819:ratt.c        ****   glcdSetAddress(6 * scrpos++, 6); 
 1483               	.LM172:
 1484 0718 96E0      		ldi r25,lo8(6)
 1485 071a C92E      		mov r12,r25
 1486               	.L84:
 815:ratt.c        ****  while(char_available()) {
 1488               	.LM173:
 1489 071c 8091 0000 		lds r24,rx_buffer+128
 1490 0720 9091 0000 		lds r25,(rx_buffer+128)+1
 1491 0724 8058      		subi r24,lo8(-(128))
 1492 0726 9F4F      		sbci r25,hi8(-(128))
 1493 0728 2091 0000 		lds r18,rx_buffer+130
 1494 072c 3091 0000 		lds r19,(rx_buffer+130)+1
 1495 0730 821B      		sub r24,r18
 1496 0732 930B      		sbc r25,r19
 1497 0734 60E8      		ldi r22,lo8(128)
 1498 0736 70E0      		ldi r23,hi8(128)
 1499 0738 0E94 0000 		call __divmodhi4
 1500 073c 8823      		tst r24
 1501 073e 01F0      		breq .+2
 1502 0740 00C0      		rjmp .L79
 1503               	.L71:
 1504 0742 80E0      		ldi r24,lo8(0)
 1505 0744 00C0      		rjmp .L73
 1506               	.L76:
 1507 0746 81E0      		ldi r24,lo8(1)
 1508               	.L73:
 1509               	/* epilogue start */
 947:ratt.c        **** }
 1511               	.LM174:
 1512 0748 2C96      		adiw r28,12
 1513 074a 0FB6      		in __tmp_reg__,__SREG__
 1514 074c F894      		cli
 1515 074e DEBF      		out __SP_H__,r29
 1516 0750 0FBE      		out __SREG__,__tmp_reg__
 1517 0752 CDBF      		out __SP_L__,r28
 1518 0754 CF91      		pop r28
 1519 0756 DF91      		pop r29
 1520 0758 1F91      		pop r17
 1521 075a 0F91      		pop r16
 1522 075c FF90      		pop r15
 1523 075e EF90      		pop r14
 1524 0760 DF90      		pop r13
 1525 0762 CF90      		pop r12
 1526 0764 BF90      		pop r11
 1527 0766 0895      		ret
 1538               	.Lscope14:
 1540               		.stabd	78,0,0
 1544               	.global	beep
 1546               	beep:
 1547               		.stabd	46,0,0
 459:ratt.c        **** void beep(uint16_t freq, uint8_t duration) {
 1549               	.LM175:
 1550               	.LFBB15:
 1551 0768 FF92      		push r15
 1552 076a 0F93      		push r16
 1553 076c 1F93      		push r17
 1554               	/* prologue: function */
 1555               	/* frame size = 0 */
 1556 076e F62E      		mov r15,r22
 461:ratt.c        ****   TCCR1A = 0; 
 1558               	.LM176:
 1559 0770 1092 8000 		sts 128,__zero_reg__
 462:ratt.c        ****   TCCR1B =  _BV(WGM12) | _BV(CS10); // CTC with fastest timer
 1561               	.LM177:
 1562 0774 01E8      		ldi r16,lo8(129)
 1563 0776 10E0      		ldi r17,hi8(129)
 1564 0778 29E0      		ldi r18,lo8(9)
 1565 077a F801      		movw r30,r16
 1566 077c 2083      		st Z,r18
 463:ratt.c        ****   TIMSK1 = _BV(TOIE1) | _BV(OCIE1A);
 1568               	.LM178:
 1569 077e 23E0      		ldi r18,lo8(3)
 1570 0780 2093 6F00 		sts 111,r18
 464:ratt.c        ****   OCR1A = (F_CPU / freq) / 2;
 1572               	.LM179:
 1573 0784 9C01      		movw r18,r24
 1574 0786 40E0      		ldi r20,lo8(0)
 1575 0788 50E0      		ldi r21,hi8(0)
 1576 078a 60E0      		ldi r22,lo8(4000000)
 1577 078c 79E0      		ldi r23,hi8(4000000)
 1578 078e 8DE3      		ldi r24,hlo8(4000000)
 1579 0790 90E0      		ldi r25,hhi8(4000000)
 1580 0792 0E94 0000 		call __divmodsi4
 1581 0796 3093 8900 		sts (136)+1,r19
 1582 079a 2093 8800 		sts 136,r18
 465:ratt.c        ****   delay_ms(duration);
 1584               	.LM180:
 1585 079e 8F2D      		mov r24,r15
 1586 07a0 90E0      		ldi r25,lo8(0)
 1587 07a2 0E94 0000 		call delay_ms
 466:ratt.c        ****   TCCR1B = 0;
 1589               	.LM181:
 1590 07a6 F801      		movw r30,r16
 1591 07a8 1082      		st Z,__zero_reg__
 468:ratt.c        ****   PIEZO_PORT &= ~_BV(PIEZO);
 1593               	.LM182:
 1594 07aa 4398      		cbi 40-32,3
 1595               	/* epilogue start */
 469:ratt.c        **** }
 1597               	.LM183:
 1598 07ac 1F91      		pop r17
 1599 07ae 0F91      		pop r16
 1600 07b0 FF90      		pop r15
 1601 07b2 0895      		ret
 1603               	.Lscope15:
 1605               		.stabd	78,0,0
 1614               	.global	writei2ctime
 1616               	writei2ctime:
 1617               		.stabd	46,0,0
 579:ratt.c        **** 		  uint8_t date, uint8_t mon, uint8_t yr) {
 1619               	.LM184:
 1620               	.LFBB16:
 1621 07b4 CF92      		push r12
 1622 07b6 DF92      		push r13
 1623 07b8 EF92      		push r14
 1624 07ba FF92      		push r15
 1625 07bc 0F93      		push r16
 1626 07be 1F93      		push r17
 1627 07c0 DF93      		push r29
 1628 07c2 CF93      		push r28
 1629 07c4 CDB7      		in r28,__SP_L__
 1630 07c6 DEB7      		in r29,__SP_H__
 1631 07c8 2897      		sbiw r28,8
 1632 07ca 0FB6      		in __tmp_reg__,__SREG__
 1633 07cc F894      		cli
 1634 07ce DEBF      		out __SP_H__,r29
 1635 07d0 0FBE      		out __SREG__,__tmp_reg__
 1636 07d2 CDBF      		out __SP_L__,r28
 1637               	/* prologue: function */
 1638               	/* frame size = 8 */
 1639 07d4 162F      		mov r17,r22
 1640 07d6 F42E      		mov r15,r20
 1641 07d8 D22E      		mov r13,r18
 580:ratt.c        ****   uint8_t clockdata[8] = {0,0,0,0,0,0,0,0};
 1643               	.LM185:
 1644 07da FE01      		movw r30,r28
 1645 07dc 3196      		adiw r30,1
 1646 07de 98E0      		ldi r25,lo8(8)
 1647 07e0 DF01      		movw r26,r30
 1648 07e2 1D92      		st X+,__zero_reg__
 1649 07e4 9A95      	        dec r25
 1650 07e6 01F4      		brne .-6
 582:ratt.c        ****   clockdata[0] = 0; // address
 1652               	.LM186:
 1653 07e8 1982      		std Y+1,__zero_reg__
 583:ratt.c        ****   clockdata[1] = i2bcd(sec);  // s
 1655               	.LM187:
 1656 07ea 0E94 0000 		call i2bcd
 1657 07ee 8A83      		std Y+2,r24
 584:ratt.c        ****   clockdata[2] = i2bcd(min);  // m
 1659               	.LM188:
 1660 07f0 812F      		mov r24,r17
 1661 07f2 0E94 0000 		call i2bcd
 1662 07f6 8B83      		std Y+3,r24
 585:ratt.c        ****   clockdata[3] = i2bcd(hr); // h
 1664               	.LM189:
 1665 07f8 8F2D      		mov r24,r15
 1666 07fa 0E94 0000 		call i2bcd
 1667 07fe 8C83      		std Y+4,r24
 586:ratt.c        ****   clockdata[4] = i2bcd(day);  // day
 1669               	.LM190:
 1670 0800 8D2D      		mov r24,r13
 1671 0802 0E94 0000 		call i2bcd
 1672 0806 8D83      		std Y+5,r24
 587:ratt.c        ****   clockdata[5] = i2bcd(date);  // date
 1674               	.LM191:
 1675 0808 802F      		mov r24,r16
 1676 080a 0E94 0000 		call i2bcd
 1677 080e 8E83      		std Y+6,r24
 588:ratt.c        ****   clockdata[6] = i2bcd(mon);  // month
 1679               	.LM192:
 1680 0810 8E2D      		mov r24,r14
 1681 0812 0E94 0000 		call i2bcd
 1682 0816 8F83      		std Y+7,r24
 589:ratt.c        ****   clockdata[7] = i2bcd(yr); // year
 1684               	.LM193:
 1685 0818 8C2D      		mov r24,r12
 1686 081a 0E94 0000 		call i2bcd
 1687 081e 8887      		std Y+8,r24
 591:ratt.c        ****   cli();
 1689               	.LM194:
 1690               	/* #APP */
 1691               	 ;  591 "ratt.c" 1
 1692 0820 F894      		cli
 1693               	 ;  0 "" 2
 592:ratt.c        ****   uint8_t r = i2cMasterSendNI(0xD0, 8, &clockdata[0]);
 1695               	.LM195:
 1696               	/* #NOAPP */
 1697 0822 80ED      		ldi r24,lo8(-48)
 1698 0824 68E0      		ldi r22,lo8(8)
 1699 0826 AE01      		movw r20,r28
 1700 0828 4F5F      		subi r20,lo8(-(1))
 1701 082a 5F4F      		sbci r21,hi8(-(1))
 1702 082c 0E94 0000 		call i2cMasterSendNI
 593:ratt.c        ****   sei();
 1704               	.LM196:
 1705               	/* #APP */
 1706               	 ;  593 "ratt.c" 1
 1707 0830 7894      		sei
 1708               	 ;  0 "" 2
 597:ratt.c        ****   if (r != 0) {
 1710               	.LM197:
 1711               	/* #NOAPP */
 1712 0832 8823      		tst r24
 1713 0834 01F0      		breq .L93
 1714               	.L94:
 599:ratt.c        ****       beep(4000, 100);
 1716               	.LM198:
 1717 0836 80EA      		ldi r24,lo8(4000)
 1718 0838 9FE0      		ldi r25,hi8(4000)
 1719 083a 64E6      		ldi r22,lo8(100)
 1720 083c 0E94 0000 		call beep
 600:ratt.c        ****       delay_ms(100);
 1722               	.LM199:
 1723 0840 84E6      		ldi r24,lo8(100)
 1724 0842 90E0      		ldi r25,hi8(100)
 1725 0844 0E94 0000 		call delay_ms
 601:ratt.c        ****       beep(4000, 100);
 1727               	.LM200:
 1728 0848 80EA      		ldi r24,lo8(4000)
 1729 084a 9FE0      		ldi r25,hi8(4000)
 1730 084c 64E6      		ldi r22,lo8(100)
 1731 084e 0E94 0000 		call beep
 602:ratt.c        ****       delay_ms(1000);
 1733               	.LM201:
 1734 0852 88EE      		ldi r24,lo8(1000)
 1735 0854 93E0      		ldi r25,hi8(1000)
 1736 0856 0E94 0000 		call delay_ms
 1737 085a 00C0      		rjmp .L94
 1738               	.L93:
 1739               	/* epilogue start */
 606:ratt.c        **** }
 1741               	.LM202:
 1742 085c 2896      		adiw r28,8
 1743 085e 0FB6      		in __tmp_reg__,__SREG__
 1744 0860 F894      		cli
 1745 0862 DEBF      		out __SP_H__,r29
 1746 0864 0FBE      		out __SREG__,__tmp_reg__
 1747 0866 CDBF      		out __SP_L__,r28
 1748 0868 CF91      		pop r28
 1749 086a DF91      		pop r29
 1750 086c 1F91      		pop r17
 1751 086e 0F91      		pop r16
 1752 0870 FF90      		pop r15
 1753 0872 EF90      		pop r14
 1754 0874 DF90      		pop r13
 1755 0876 CF90      		pop r12
 1756 0878 0895      		ret
 1762               	.Lscope16:
 1764               		.stabd	78,0,0
 1767               	.global	GPSCheck
 1769               	GPSCheck:
 1770               		.stabd	46,0,0
 949:ratt.c        **** void GPSCheck(uint8_t mode) {
 1772               	.LM203:
 1773               	.LFBB17:
 1774 087a CF92      		push r12
 1775 087c DF92      		push r13
 1776 087e EF92      		push r14
 1777 0880 FF92      		push r15
 1778 0882 0F93      		push r16
 1779 0884 1F93      		push r17
 1780               	/* prologue: function */
 1781               	/* frame size = 0 */
 1782 0886 182F      		mov r17,r24
 950:ratt.c        ****  if (GPSRead(mode) && !mode) {
 1784               	.LM204:
 1785 0888 0E94 0000 		call GPSRead
 1786 088c 8823      		tst r24
 1787 088e 01F0      		breq .L97
 1788 0890 1123      		tst r17
 1789 0892 01F4      		brne .L97
 951:ratt.c        ****   writei2ctime(time_s, time_m, time_h, dotw(date_m, date_d, date_y), date_d, date_m, date_y);
 1791               	.LM205:
 1792 0894 1091 0000 		lds r17,time_s
 1793 0898 F090 0000 		lds r15,time_m
 1794 089c D090 0000 		lds r13,time_h
 1795 08a0 8091 0000 		lds r24,date_m
 1796 08a4 6091 0000 		lds r22,date_d
 1797 08a8 4091 0000 		lds r20,date_y
 1798 08ac 0E94 0000 		call dotw
 1799 08b0 282F      		mov r18,r24
 1800 08b2 0091 0000 		lds r16,date_d
 1801 08b6 E090 0000 		lds r14,date_m
 1802 08ba C090 0000 		lds r12,date_y
 1803 08be 812F      		mov r24,r17
 1804 08c0 6F2D      		mov r22,r15
 1805 08c2 4D2D      		mov r20,r13
 1806 08c4 0E94 0000 		call writei2ctime
 952:ratt.c        ****   sei();
 1808               	.LM206:
 1809               	/* #APP */
 1810               	 ;  952 "ratt.c" 1
 1811 08c8 7894      		sei
 1812               	 ;  0 "" 2
 1813               	/* #NOAPP */
 1814               	.L97:
 1815               	/* epilogue start */
 954:ratt.c        **** }
 1817               	.LM207:
 1818 08ca 1F91      		pop r17
 1819 08cc 0F91      		pop r16
 1820 08ce FF90      		pop r15
 1821 08d0 EF90      		pop r14
 1822 08d2 DF90      		pop r13
 1823 08d4 CF90      		pop r12
 1824 08d6 0895      		ret
 1826               	.Lscope17:
 1828               		.stabd	78,0,0
 1830               	.global	init_eeprom
 1832               	init_eeprom:
 1833               		.stabd	46,0,0
 144:ratt.c        **** void init_eeprom(void) {	//Set eeprom to a default state.
 1835               	.LM208:
 1836               	.LFBB18:
 1837               	/* prologue: function */
 1838               	/* frame size = 0 */
 145:ratt.c        ****  if (eeprom_read_byte(&EE_INIT) != pgm_read_byte(&EE_DATA[0])) {
 1840               	.LM209:
 1841 08d8 80E0      		ldi r24,lo8(EE_INIT)
 1842 08da 90E0      		ldi r25,hi8(EE_INIT)
 1843 08dc 0E94 0000 		call __eerd_byte_m328p
 1844               	.LBB37:
 1845 08e0 E0E0      		ldi r30,lo8(EE_DATA)
 1846 08e2 F0E0      		ldi r31,hi8(EE_DATA)
 1847               	/* #APP */
 1848               	 ;  145 "ratt.c" 1
 1849 08e4 E491      		lpm r30, Z
 1850               		
 1851               	 ;  0 "" 2
 1852               	/* #NOAPP */
 1853               	.LBE37:
 1854 08e6 8E17      		cp r24,r30
 1855 08e8 01F0      		breq .L101
 1856               	.L102:
 149:ratt.c        ****       beep(4000, 100);
 1858               	.LM210:
 1859 08ea 80EA      		ldi r24,lo8(4000)
 1860 08ec 9FE0      		ldi r25,hi8(4000)
 1861 08ee 64E6      		ldi r22,lo8(100)
 1862 08f0 0E94 0000 		call beep
 150:ratt.c        ****       delay_ms(100);
 1864               	.LM211:
 1865 08f4 84E6      		ldi r24,lo8(100)
 1866 08f6 90E0      		ldi r25,hi8(100)
 1867 08f8 0E94 0000 		call delay_ms
 151:ratt.c        ****       beep(4000, 100);
 1869               	.LM212:
 1870 08fc 80EA      		ldi r24,lo8(4000)
 1871 08fe 9FE0      		ldi r25,hi8(4000)
 1872 0900 64E6      		ldi r22,lo8(100)
 1873 0902 0E94 0000 		call beep
 152:ratt.c        ****       delay_ms(100);
 1875               	.LM213:
 1876 0906 84E6      		ldi r24,lo8(100)
 1877 0908 90E0      		ldi r25,hi8(100)
 1878 090a 0E94 0000 		call delay_ms
 153:ratt.c        ****       beep(4000, 100);
 1880               	.LM214:
 1881 090e 80EA      		ldi r24,lo8(4000)
 1882 0910 9FE0      		ldi r25,hi8(4000)
 1883 0912 64E6      		ldi r22,lo8(100)
 1884 0914 0E94 0000 		call beep
 154:ratt.c        ****       delay_ms(1000);
 1886               	.LM215:
 1887 0918 88EE      		ldi r24,lo8(1000)
 1888 091a 93E0      		ldi r25,hi8(1000)
 1889 091c 0E94 0000 		call delay_ms
 1890 0920 00C0      		rjmp .L102
 1891               	.L101:
 1892 0922 0895      		ret
 1897               	.Lscope18:
 1899               		.stabd	78,0,0
 1901               	.global	readi2ctime
 1903               	readi2ctime:
 1904               		.stabd	46,0,0
 530:ratt.c        **** uint8_t readi2ctime(void) {
 1906               	.LM216:
 1907               	.LFBB19:
 1908 0924 DF93      		push r29
 1909 0926 CF93      		push r28
 1910 0928 CDB7      		in r28,__SP_L__
 1911 092a DEB7      		in r29,__SP_H__
 1912 092c 2997      		sbiw r28,9
 1913 092e 0FB6      		in __tmp_reg__,__SREG__
 1914 0930 F894      		cli
 1915 0932 DEBF      		out __SP_H__,r29
 1916 0934 0FBE      		out __SREG__,__tmp_reg__
 1917 0936 CDBF      		out __SP_L__,r28
 1918               	/* prologue: function */
 1919               	/* frame size = 9 */
 531:ratt.c        ****   uint8_t regaddr = 0, r;
 1921               	.LM217:
 1922 0938 1982      		std Y+1,__zero_reg__
 535:ratt.c        ****   cli();
 1924               	.LM218:
 1925               	/* #APP */
 1926               	 ;  535 "ratt.c" 1
 1927 093a F894      		cli
 1928               	 ;  0 "" 2
 536:ratt.c        ****   r = i2cMasterSendNI(0xD0, 1, &regaddr);
 1930               	.LM219:
 1931               	/* #NOAPP */
 1932 093c 80ED      		ldi r24,lo8(-48)
 1933 093e 61E0      		ldi r22,lo8(1)
 1934 0940 AE01      		movw r20,r28
 1935 0942 4F5F      		subi r20,lo8(-(1))
 1936 0944 5F4F      		sbci r21,hi8(-(1))
 1937 0946 0E94 0000 		call i2cMasterSendNI
 538:ratt.c        ****   if (r != 0) {
 1939               	.LM220:
 1940 094a 8823      		tst r24
 1941 094c 01F0      		breq .L104
 1942               	.L111:
 541:ratt.c        ****       sei();
 1944               	.LM221:
 1945               	/* #APP */
 1946               	 ;  541 "ratt.c" 1
 1947 094e 7894      		sei
 1948               	 ;  0 "" 2
 542:ratt.c        ****       beep(4000, 100);
 1950               	.LM222:
 1951               	/* #NOAPP */
 1952 0950 80EA      		ldi r24,lo8(4000)
 1953 0952 9FE0      		ldi r25,hi8(4000)
 1954 0954 64E6      		ldi r22,lo8(100)
 1955 0956 0E94 0000 		call beep
 543:ratt.c        ****       delay_ms(100);
 1957               	.LM223:
 1958 095a 84E6      		ldi r24,lo8(100)
 1959 095c 90E0      		ldi r25,hi8(100)
 1960 095e 0E94 0000 		call delay_ms
 544:ratt.c        ****       beep(4000, 100);
 1962               	.LM224:
 1963 0962 80EA      		ldi r24,lo8(4000)
 1964 0964 9FE0      		ldi r25,hi8(4000)
 1965 0966 64E6      		ldi r22,lo8(100)
 1966 0968 0E94 0000 		call beep
 545:ratt.c        ****       delay_ms(1000);
 1968               	.LM225:
 1969 096c 88EE      		ldi r24,lo8(1000)
 1970 096e 93E0      		ldi r25,hi8(1000)
 1971 0970 0E94 0000 		call delay_ms
 1972 0974 00C0      		rjmp .L111
 1973               	.L104:
 549:ratt.c        ****   r = i2cMasterReceiveNI(0xD0, 7, &clockdata[0]);
 1975               	.LM226:
 1976 0976 80ED      		ldi r24,lo8(-48)
 1977 0978 67E0      		ldi r22,lo8(7)
 1978 097a AE01      		movw r20,r28
 1979 097c 4E5F      		subi r20,lo8(-(2))
 1980 097e 5F4F      		sbci r21,hi8(-(2))
 1981 0980 0E94 0000 		call i2cMasterReceiveNI
 550:ratt.c        ****   sei();
 1983               	.LM227:
 1984               	/* #APP */
 1985               	 ;  550 "ratt.c" 1
 1986 0984 7894      		sei
 1987               	 ;  0 "" 2
 552:ratt.c        ****   if (r != 0) {
 1989               	.LM228:
 1990               	/* #NOAPP */
 1991 0986 8823      		tst r24
 1992 0988 01F0      		breq .L106
 1993               	.L112:
 555:ratt.c        ****       beep(4000, 100);
 1995               	.LM229:
 1996 098a 80EA      		ldi r24,lo8(4000)
 1997 098c 9FE0      		ldi r25,hi8(4000)
 1998 098e 64E6      		ldi r22,lo8(100)
 1999 0990 0E94 0000 		call beep
 556:ratt.c        ****       delay_ms(100);
 2001               	.LM230:
 2002 0994 84E6      		ldi r24,lo8(100)
 2003 0996 90E0      		ldi r25,hi8(100)
 2004 0998 0E94 0000 		call delay_ms
 557:ratt.c        ****       beep(4000, 100);
 2006               	.LM231:
 2007 099c 80EA      		ldi r24,lo8(4000)
 2008 099e 9FE0      		ldi r25,hi8(4000)
 2009 09a0 64E6      		ldi r22,lo8(100)
 2010 09a2 0E94 0000 		call beep
 558:ratt.c        ****       delay_ms(1000);
 2012               	.LM232:
 2013 09a6 88EE      		ldi r24,lo8(1000)
 2014 09a8 93E0      		ldi r25,hi8(1000)
 2015 09aa 0E94 0000 		call delay_ms
 2016 09ae 00C0      		rjmp .L112
 2017               	.L106:
 562:ratt.c        ****   time_s = ((clockdata[0] >> 4) & 0x7)*10 + (clockdata[0] & 0xF);
 2019               	.LM233:
 2020 09b0 7A81      		ldd r23,Y+2
 2021 09b2 872F      		mov r24,r23
 2022 09b4 8295      		swap r24
 2023 09b6 8F70      		andi r24,0x0f
 2024 09b8 90E0      		ldi r25,lo8(0)
 2025 09ba 8770      		andi r24,lo8(7)
 2026 09bc 9070      		andi r25,hi8(7)
 2027 09be 9C01      		movw r18,r24
 2028 09c0 F3E0      		ldi r31,3
 2029 09c2 220F      	1:	lsl r18
 2030 09c4 331F      		rol r19
 2031 09c6 FA95      		dec r31
 2032 09c8 01F4      		brne 1b
 2033 09ca 880F      		lsl r24
 2034 09cc 991F      		rol r25
 2035 09ce 280F      		add r18,r24
 2036 09d0 391F      		adc r19,r25
 2037 09d2 872F      		mov r24,r23
 2038 09d4 8F70      		andi r24,lo8(15)
 2039 09d6 820F      		add r24,r18
 2040 09d8 8093 0000 		sts time_s,r24
 563:ratt.c        ****   time_m = ((clockdata[1] >> 4) & 0x7)*10 + (clockdata[1] & 0xF);
 2042               	.LM234:
 2043 09dc 4B81      		ldd r20,Y+3
 2044 09de 842F      		mov r24,r20
 2045 09e0 8295      		swap r24
 2046 09e2 8F70      		andi r24,0x0f
 2047 09e4 90E0      		ldi r25,lo8(0)
 2048 09e6 8770      		andi r24,lo8(7)
 2049 09e8 9070      		andi r25,hi8(7)
 2050 09ea 9C01      		movw r18,r24
 2051 09ec 63E0      		ldi r22,3
 2052 09ee 220F      	1:	lsl r18
 2053 09f0 331F      		rol r19
 2054 09f2 6A95      		dec r22
 2055 09f4 01F4      		brne 1b
 2056 09f6 880F      		lsl r24
 2057 09f8 991F      		rol r25
 2058 09fa 280F      		add r18,r24
 2059 09fc 391F      		adc r19,r25
 2060 09fe 4F70      		andi r20,lo8(15)
 2061 0a00 420F      		add r20,r18
 2062 0a02 4093 0000 		sts time_m,r20
 564:ratt.c        ****   if (clockdata[2] & _BV(6)) {
 2064               	.LM235:
 2065 0a06 8C81      		ldd r24,Y+4
 2066 0a08 482F      		mov r20,r24
 2067 0a0a 4295      		swap r20
 2068 0a0c 4F70      		andi r20,0x0f
 2069 0a0e 682F      		mov r22,r24
 2070 0a10 6F70      		andi r22,lo8(15)
 2071 0a12 86FF      		sbrs r24,6
 2072 0a14 00C0      		rjmp .L108
 566:ratt.c        ****     time_h = ((clockdata[2] >> 5) & 0x1)*12 + 
 2074               	.LM236:
 2075 0a16 8295      		swap r24
 2076 0a18 8695      		lsr r24
 2077 0a1a 8770      		andi r24,0x7
 2078 0a1c 90E0      		ldi r25,lo8(0)
 2079 0a1e 8170      		andi r24,lo8(1)
 2080 0a20 9070      		andi r25,hi8(1)
 2081 0a22 9C01      		movw r18,r24
 2082 0a24 220F      		lsl r18
 2083 0a26 331F      		rol r19
 2084 0a28 280F      		add r18,r24
 2085 0a2a 391F      		adc r19,r25
 2086 0a2c 220F      		lsl r18
 2087 0a2e 331F      		rol r19
 2088 0a30 220F      		lsl r18
 2089 0a32 331F      		rol r19
 2090 0a34 842F      		mov r24,r20
 2091 0a36 90E0      		ldi r25,lo8(0)
 2092 0a38 8170      		andi r24,lo8(1)
 2093 0a3a 9070      		andi r25,hi8(1)
 2094 0a3c AC01      		movw r20,r24
 2095 0a3e F3E0      		ldi r31,3
 2096 0a40 440F      	1:	lsl r20
 2097 0a42 551F      		rol r21
 2098 0a44 FA95      		dec r31
 2099 0a46 01F4      		brne 1b
 2100 0a48 880F      		lsl r24
 2101 0a4a 991F      		rol r25
 2102 0a4c 480F      		add r20,r24
 2103 0a4e 591F      		adc r21,r25
 2104 0a50 240F      		add r18,r20
 2105 0a52 260F      		add r18,r22
 2106 0a54 2093 0000 		sts time_h,r18
 2107 0a58 00C0      		rjmp .L109
 2108               	.L108:
 569:ratt.c        ****     time_h = ((clockdata[2] >> 4) & 0x3)*10 + (clockdata[2] & 0xF);
 2110               	.LM237:
 2111 0a5a 842F      		mov r24,r20
 2112 0a5c 90E0      		ldi r25,lo8(0)
 2113 0a5e 8370      		andi r24,lo8(3)
 2114 0a60 9070      		andi r25,hi8(3)
 2115 0a62 9C01      		movw r18,r24
 2116 0a64 43E0      		ldi r20,3
 2117 0a66 220F      	1:	lsl r18
 2118 0a68 331F      		rol r19
 2119 0a6a 4A95      		dec r20
 2120 0a6c 01F4      		brne 1b
 2121 0a6e 880F      		lsl r24
 2122 0a70 991F      		rol r25
 2123 0a72 280F      		add r18,r24
 2124 0a74 391F      		adc r19,r25
 2125 0a76 620F      		add r22,r18
 2126 0a78 6093 0000 		sts time_h,r22
 2127               	.L109:
 572:ratt.c        ****   date_d = ((clockdata[4] >> 4) & 0x3)*10 + (clockdata[4] & 0xF);
 2129               	.LM238:
 2130 0a7c 4E81      		ldd r20,Y+6
 2131 0a7e 842F      		mov r24,r20
 2132 0a80 8295      		swap r24
 2133 0a82 8F70      		andi r24,0x0f
 2134 0a84 90E0      		ldi r25,lo8(0)
 2135 0a86 8370      		andi r24,lo8(3)
 2136 0a88 9070      		andi r25,hi8(3)
 2137 0a8a 9C01      		movw r18,r24
 2138 0a8c A3E0      		ldi r26,3
 2139 0a8e 220F      	1:	lsl r18
 2140 0a90 331F      		rol r19
 2141 0a92 AA95      		dec r26
 2142 0a94 01F4      		brne 1b
 2143 0a96 880F      		lsl r24
 2144 0a98 991F      		rol r25
 2145 0a9a 280F      		add r18,r24
 2146 0a9c 391F      		adc r19,r25
 2147 0a9e 4F70      		andi r20,lo8(15)
 2148 0aa0 420F      		add r20,r18
 2149 0aa2 4093 0000 		sts date_d,r20
 573:ratt.c        ****   date_m = ((clockdata[5] >> 4) & 0x1)*10 + (clockdata[5] & 0xF);
 2151               	.LM239:
 2152 0aa6 4F81      		ldd r20,Y+7
 2153 0aa8 842F      		mov r24,r20
 2154 0aaa 8295      		swap r24
 2155 0aac 8F70      		andi r24,0x0f
 2156 0aae 90E0      		ldi r25,lo8(0)
 2157 0ab0 8170      		andi r24,lo8(1)
 2158 0ab2 9070      		andi r25,hi8(1)
 2159 0ab4 9C01      		movw r18,r24
 2160 0ab6 E3E0      		ldi r30,3
 2161 0ab8 220F      	1:	lsl r18
 2162 0aba 331F      		rol r19
 2163 0abc EA95      		dec r30
 2164 0abe 01F4      		brne 1b
 2165 0ac0 880F      		lsl r24
 2166 0ac2 991F      		rol r25
 2167 0ac4 280F      		add r18,r24
 2168 0ac6 391F      		adc r19,r25
 2169 0ac8 4F70      		andi r20,lo8(15)
 2170 0aca 420F      		add r20,r18
 2171 0acc 4093 0000 		sts date_m,r20
 574:ratt.c        ****   date_y = ((clockdata[6] >> 4) & 0xF)*10 + (clockdata[6] & 0xF);
 2173               	.LM240:
 2174 0ad0 2885      		ldd r18,Y+8
 2175 0ad2 822F      		mov r24,r18
 2176 0ad4 8295      		swap r24
 2177 0ad6 8F70      		andi r24,0x0f
 2178 0ad8 3AE0      		ldi r19,lo8(10)
 2179 0ada 839F      		mul r24,r19
 2180 0adc C001      		movw r24,r0
 2181 0ade 1124      		clr r1
 2182 0ae0 2F70      		andi r18,lo8(15)
 2183 0ae2 280F      		add r18,r24
 2184 0ae4 2093 0000 		sts date_y,r18
 576:ratt.c        **** }
 2186               	.LM241:
 2187 0ae8 872F      		mov r24,r23
 2188 0aea 8078      		andi r24,lo8(-128)
 2189               	/* epilogue start */
 2190 0aec 2996      		adiw r28,9
 2191 0aee 0FB6      		in __tmp_reg__,__SREG__
 2192 0af0 F894      		cli
 2193 0af2 DEBF      		out __SP_H__,r29
 2194 0af4 0FBE      		out __SREG__,__tmp_reg__
 2195 0af6 CDBF      		out __SP_L__,r28
 2196 0af8 CF91      		pop r28
 2197 0afa DF91      		pop r29
 2198 0afc 0895      		ret
 2204               	.Lscope19:
 2206               		.stabd	78,0,0
 2208               	.global	clock_init
 2210               	clock_init:
 2211               		.stabd	46,0,0
 737:ratt.c        **** void clock_init(void) {
 2213               	.LM242:
 2214               	.LFBB20:
 2215 0afe CF92      		push r12
 2216 0b00 EF92      		push r14
 2217 0b02 0F93      		push r16
 2218               	/* prologue: function */
 2219               	/* frame size = 0 */
 739:ratt.c        ****   i2cInit();
 2221               	.LM243:
 2222 0b04 0E94 0000 		call i2cInit
 742:ratt.c        ****   if (readi2ctime()) {
 2224               	.LM244:
 2225 0b08 0E94 0000 		call readi2ctime
 2226 0b0c 8823      		tst r24
 2227 0b0e 01F0      		breq .L114
 744:ratt.c        ****     writei2ctime(0, 0, 12, 0, 1, 1, 9); // noon 1/1/2009
 2229               	.LM245:
 2230 0b10 80E0      		ldi r24,lo8(0)
 2231 0b12 60E0      		ldi r22,lo8(0)
 2232 0b14 4CE0      		ldi r20,lo8(12)
 2233 0b16 20E0      		ldi r18,lo8(0)
 2234 0b18 01E0      		ldi r16,lo8(1)
 2235 0b1a EE24      		clr r14
 2236 0b1c E394      		inc r14
 2237 0b1e A9E0      		ldi r26,lo8(9)
 2238 0b20 CA2E      		mov r12,r26
 2239 0b22 0E94 0000 		call writei2ctime
 2240               	.L114:
 747:ratt.c        ****   readi2ctime();
 2242               	.LM246:
 2243 0b26 0E94 0000 		call readi2ctime
 764:ratt.c        ****   alarm_m = eeprom_read_byte(&EE_ALARM_MIN) % 60;
 2245               	.LM247:
 2246 0b2a 80E0      		ldi r24,lo8(EE_ALARM_MIN)
 2247 0b2c 90E0      		ldi r25,hi8(EE_ALARM_MIN)
 2248 0b2e 0E94 0000 		call __eerd_byte_m328p
 2249 0b32 6CE3      		ldi r22,lo8(60)
 2250 0b34 0E94 0000 		call __udivmodqi4
 2251 0b38 9093 0000 		sts alarm_m,r25
 765:ratt.c        ****   alarm_h = eeprom_read_byte(&EE_ALARM_HOUR) % 24;
 2253               	.LM248:
 2254 0b3c 80E0      		ldi r24,lo8(EE_ALARM_HOUR)
 2255 0b3e 90E0      		ldi r25,hi8(EE_ALARM_HOUR)
 2256 0b40 0E94 0000 		call __eerd_byte_m328p
 2257 0b44 68E1      		ldi r22,lo8(24)
 2258 0b46 0E94 0000 		call __udivmodqi4
 2259 0b4a 9093 0000 		sts alarm_h,r25
 770:ratt.c        ****   TCCR2B = _BV(CS22) | _BV(CS21) | _BV(CS20); // div by 1024
 2261               	.LM249:
 2262 0b4e 87E0      		ldi r24,lo8(7)
 2263 0b50 8093 B100 		sts 177,r24
 774:ratt.c        ****   TIMSK2 = _BV(TOIE2);
 2265               	.LM250:
 2266 0b54 81E0      		ldi r24,lo8(1)
 2267 0b56 8093 7000 		sts 112,r24
 776:ratt.c        ****   sei();
 2269               	.LM251:
 2270               	/* #APP */
 2271               	 ;  776 "ratt.c" 1
 2272 0b5a 7894      		sei
 2273               	 ;  0 "" 2
 2274               	/* epilogue start */
 777:ratt.c        **** }
 2276               	.LM252:
 2277               	/* #NOAPP */
 2278 0b5c 0F91      		pop r16
 2279 0b5e EF90      		pop r14
 2280 0b60 CF90      		pop r12
 2281 0b62 0895      		ret
 2283               	.Lscope20:
 2285               		.stabd	78,0,0
 2287               	.global	__vector_9
 2289               	__vector_9:
 2290               		.stabd	46,0,0
 610:ratt.c        **** SIGNAL (TIMER2_OVF_vect) {
 2292               	.LM253:
 2293               	.LFBB21:
 2294 0b64 1F92      		push __zero_reg__
 2295 0b66 0F92      		push r0
 2296 0b68 0FB6      		in r0,__SREG__
 2297 0b6a 0F92      		push r0
 2298 0b6c 1124      		clr __zero_reg__
 2299 0b6e FF92      		push r15
 2300 0b70 0F93      		push r16
 2301 0b72 1F93      		push r17
 2302 0b74 2F93      		push r18
 2303 0b76 3F93      		push r19
 2304 0b78 4F93      		push r20
 2305 0b7a 5F93      		push r21
 2306 0b7c 6F93      		push r22
 2307 0b7e 7F93      		push r23
 2308 0b80 8F93      		push r24
 2309 0b82 9F93      		push r25
 2310 0b84 AF93      		push r26
 2311 0b86 BF93      		push r27
 2312 0b88 EF93      		push r30
 2313 0b8a FF93      		push r31
 2314               	/* prologue: Signal */
 2315               	/* frame size = 0 */
 611:ratt.c        ****   wdt_reset();
 2317               	.LM254:
 2318               	/* #APP */
 2319               	 ;  611 "ratt.c" 1
 2320 0b8c A895      		wdr
 2321               	 ;  0 "" 2
 613:ratt.c        ****   if (t2divider1 == TIMER2_RETURN) {
 2323               	.LM255:
 2324               	/* #NOAPP */
 2325 0b8e 8091 0000 		lds r24,t2divider1
 2326 0b92 8035      		cpi r24,lo8(80)
 2327 0b94 01F4      		brne .L117
 617:ratt.c        ****     t2divider1 = 0;
 2329               	.LM256:
 2330 0b96 1092 0000 		sts t2divider1,__zero_reg__
 625:ratt.c        ****   uint8_t last_s = time_s;
 2332               	.LM257:
 2333 0b9a 1091 0000 		lds r17,time_s
 626:ratt.c        ****   uint8_t last_m = time_m;
 2335               	.LM258:
 2336 0b9e 0091 0000 		lds r16,time_m
 627:ratt.c        ****   uint8_t last_h = time_h;
 2338               	.LM259:
 2339 0ba2 F090 0000 		lds r15,time_h
 629:ratt.c        ****   readi2ctime();
 2341               	.LM260:
 2342 0ba6 0E94 0000 		call readi2ctime
 632:ratt.c        ****   GPSCheck((displaystyle==STYLE_GPS) && (displaymode == SHOW_TIME));	
 2344               	.LM261:
 2345 0baa 8091 0000 		lds r24,displaystyle
 2346 0bae 873D      		cpi r24,lo8(-41)
 2347 0bb0 01F0      		breq .L118
 2348 0bb2 80E0      		ldi r24,lo8(0)
 2349 0bb4 90E0      		ldi r25,hi8(0)
 2350 0bb6 00C0      		rjmp .L119
 2351               	.L117:
 619:ratt.c        ****     t2divider1++;
 2353               	.LM262:
 2354 0bb8 8F5F      		subi r24,lo8(-(1))
 2355 0bba 8093 0000 		sts t2divider1,r24
 2356 0bbe 00C0      		rjmp .L138
 2357               	.L118:
 632:ratt.c        ****   GPSCheck((displaystyle==STYLE_GPS) && (displaymode == SHOW_TIME));	
 2359               	.LM263:
 2360 0bc0 8091 0000 		lds r24,displaymode
 2361 0bc4 90E0      		ldi r25,lo8(0)
 2362 0bc6 8111      		cpse r24,__zero_reg__
 2363 0bc8 91E0      		ldi r25,lo8(1)
 2364               	.L121:
 2365 0bca 81E0      		ldi r24,lo8(1)
 2366 0bcc 9827      		eor r25,r24
 2367 0bce 892F      		mov r24,r25
 2368 0bd0 90E0      		ldi r25,lo8(0)
 2369               	.L119:
 2370 0bd2 0E94 0000 		call GPSCheck
 635:ratt.c        ****   border_tick++;
 2372               	.LM264:
 2373 0bd6 8091 0000 		lds r24,border_tick
 2374 0bda 8F5F      		subi r24,lo8(-(1))
 2375 0bdc 8093 0000 		sts border_tick,r24
 638:ratt.c        ****   if (time_h != last_h) {
 2377               	.LM265:
 2378 0be0 8091 0000 		lds r24,time_h
 2379 0be4 8F15      		cp r24,r15
 2380 0be6 01F0      		breq .L122
 639:ratt.c        ****     hour_changed = 1; 
 2382               	.LM266:
 2383 0be8 81E0      		ldi r24,lo8(1)
 2384 0bea 8093 0000 		sts hour_changed,r24
 640:ratt.c        ****     old_h = last_h;
 2386               	.LM267:
 2387 0bee F092 0000 		sts old_h,r15
 2388 0bf2 00C0      		rjmp .L139
 2389               	.L122:
 642:ratt.c        ****   } else if (time_m != last_m) {
 2391               	.LM268:
 2392 0bf4 8091 0000 		lds r24,time_m
 2393 0bf8 8017      		cp r24,r16
 2394 0bfa 01F0      		breq .L124
 643:ratt.c        ****     minute_changed = 1;
 2396               	.LM269:
 2397 0bfc 81E0      		ldi r24,lo8(1)
 2398 0bfe 8093 0000 		sts minute_changed,r24
 2399               	.L139:
 644:ratt.c        ****     old_m = last_m;
 2401               	.LM270:
 2402 0c02 0093 0000 		sts old_m,r16
 2403 0c06 00C0      		rjmp .L123
 2404               	.L124:
 645:ratt.c        ****   } else if (time_s != last_s) {
 2406               	.LM271:
 2407 0c08 8091 0000 		lds r24,time_s
 2408 0c0c 8117      		cp r24,r17
 2409 0c0e 01F0      		breq .L123
 646:ratt.c        ****     second_changed = 1;
 2411               	.LM272:
 2412 0c10 81E0      		ldi r24,lo8(1)
 2413 0c12 8093 0000 		sts second_changed,r24
 647:ratt.c        ****     old_s = last_s;
 2415               	.LM273:
 2416 0c16 1093 0000 		sts old_s,r17
 2417               	.L123:
 651:ratt.c        ****   if (time_s != last_s) {
 2419               	.LM274:
 2420 0c1a 8091 0000 		lds r24,time_s
 2421 0c1e 8117      		cp r24,r17
 2422 0c20 01F4      		brne .+2
 2423 0c22 00C0      		rjmp .L125
 652:ratt.c        ****     if(alarming && snoozetimer)
 2425               	.LM275:
 2426 0c24 8091 0000 		lds r24,alarming
 2427 0c28 8823      		tst r24
 2428 0c2a 01F0      		breq .L126
 2429 0c2c 8091 0000 		lds r24,snoozetimer
 2430 0c30 9091 0000 		lds r25,(snoozetimer)+1
 2431 0c34 0097      		sbiw r24,0
 2432 0c36 01F0      		breq .L126
 653:ratt.c        **** 	  snoozetimer--;
 2434               	.LM276:
 2435 0c38 0197      		sbiw r24,1
 2436 0c3a 9093 0000 		sts (snoozetimer)+1,r25
 2437 0c3e 8093 0000 		sts snoozetimer,r24
 2438               	.L126:
 655:ratt.c        ****     if(score_mode_timeout) {
 2440               	.LM277:
 2441 0c42 8091 0000 		lds r24,score_mode_timeout
 2442 0c46 8823      		tst r24
 2443 0c48 01F0      		breq .L125
 656:ratt.c        **** 	  score_mode_timeout--;
 2445               	.LM278:
 2446 0c4a 8091 0000 		lds r24,score_mode_timeout
 2447 0c4e 8150      		subi r24,lo8(-(-1))
 2448 0c50 8093 0000 		sts score_mode_timeout,r24
 657:ratt.c        **** 	  if(!score_mode_timeout) {
 2450               	.LM279:
 2451 0c54 8091 0000 		lds r24,score_mode_timeout
 2452 0c58 8823      		tst r24
 2453 0c5a 01F4      		brne .L125
 658:ratt.c        **** 	  	last_score_mode = score_mode;
 2455               	.LM280:
 2456 0c5c 8091 0000 		lds r24,score_mode
 2457 0c60 8093 0000 		sts last_score_mode,r24
 660:ratt.c        **** 	  if (displaystyle == STYLE_DEATH) {
 2459               	.LM281:
 2460 0c64 8091 0000 		lds r24,displaystyle
 2461 0c68 833D      		cpi r24,lo8(-45)
 2462 0c6a 01F4      		brne .L127
 661:ratt.c        **** 	    if(score_mode >= SCORE_MODE_DEATH_TIME)
 2464               	.LM282:
 2465 0c6c 8091 0000 		lds r24,score_mode
 2466 0c70 8430      		cpi r24,lo8(4)
 2467 0c72 00F0      		brlo .L127
 662:ratt.c        **** 	      score_mode = SCORE_MODE_DEATH_TIME;
 2469               	.LM283:
 2470 0c74 84E0      		ldi r24,lo8(4)
 2471 0c76 8093 0000 		sts score_mode,r24
 2472 0c7a 00C0      		rjmp .L129
 2473               	.L127:
 668:ratt.c        **** 	    score_mode = SCORE_MODE_TIME;
 2475               	.LM284:
 2476 0c7c 1092 0000 		sts score_mode,__zero_reg__
 2477               	.L129:
 669:ratt.c        **** 	    if(hour_changed) {
 2479               	.LM285:
 2480 0c80 8091 0000 		lds r24,hour_changed
 2481 0c84 8823      		tst r24
 2482 0c86 01F0      		breq .L130
 670:ratt.c        **** 	      time_h = old_h;
 2484               	.LM286:
 2485 0c88 8091 0000 		lds r24,old_h
 2486 0c8c 8093 0000 		sts time_h,r24
 2487 0c90 00C0      		rjmp .L140
 2488               	.L130:
 672:ratt.c        **** 	    } else if (minute_changed) {
 2490               	.LM287:
 2491 0c92 8091 0000 		lds r24,minute_changed
 2492 0c96 8823      		tst r24
 2493 0c98 01F0      		breq .L131
 2494               	.L140:
 673:ratt.c        **** 	      time_m = old_m;
 2496               	.LM288:
 2497 0c9a 8091 0000 		lds r24,old_m
 2498 0c9e 8093 0000 		sts time_m,r24
 2499               	.L131:
 675:ratt.c        **** 	    if(hour_changed || minute_changed) {
 2501               	.LM289:
 2502 0ca2 8091 0000 		lds r24,hour_changed
 2503 0ca6 8823      		tst r24
 2504 0ca8 01F4      		brne .L132
 2505 0caa 8091 0000 		lds r24,minute_changed
 2506 0cae 8823      		tst r24
 2507 0cb0 01F0      		breq .L125
 2508               	.L132:
 676:ratt.c        **** 	      time_h = last_h;
 2510               	.LM290:
 2511 0cb2 F092 0000 		sts time_h,r15
 677:ratt.c        **** 	      time_m = last_m;
 2513               	.LM291:
 2514 0cb6 0093 0000 		sts time_m,r16
 2515               	.L125:
 693:ratt.c        ****   if (alarm_on && (time_s == 0) && (time_m == alarm_m) && (time_h == alarm_h)) {
 2517               	.LM292:
 2518 0cba 8091 0000 		lds r24,alarm_on
 2519 0cbe 8823      		tst r24
 2520 0cc0 01F0      		breq .L133
 2521 0cc2 8091 0000 		lds r24,time_s
 2522 0cc6 8823      		tst r24
 2523 0cc8 01F4      		brne .L133
 2524 0cca 9091 0000 		lds r25,time_m
 2525 0cce 8091 0000 		lds r24,alarm_m
 2526 0cd2 9817      		cp r25,r24
 2527 0cd4 01F4      		brne .L133
 2528 0cd6 9091 0000 		lds r25,time_h
 2529 0cda 8091 0000 		lds r24,alarm_h
 2530 0cde 9817      		cp r25,r24
 2531 0ce0 01F4      		brne .L133
 695:ratt.c        ****     alarm_tripped = 1;
 2533               	.LM293:
 2534 0ce2 81E0      		ldi r24,lo8(1)
 2535 0ce4 8093 0000 		sts alarm_tripped,r24
 2536               	.L133:
 699:ratt.c        ****   if(!minute_changed && !hour_changed && alarm_tripped) {
 2538               	.LM294:
 2539 0ce8 8091 0000 		lds r24,minute_changed
 2540 0cec 8823      		tst r24
 2541 0cee 01F4      		brne .L134
 2542 0cf0 8091 0000 		lds r24,hour_changed
 2543 0cf4 8823      		tst r24
 2544 0cf6 01F4      		brne .L134
 2545 0cf8 8091 0000 		lds r24,alarm_tripped
 2546 0cfc 8823      		tst r24
 2547 0cfe 01F0      		breq .L134
 701:ratt.c        ****   	 alarming = 1;
 2549               	.LM295:
 2550 0d00 81E0      		ldi r24,lo8(1)
 2551 0d02 8093 0000 		sts alarming,r24
 702:ratt.c        ****   	 alarm_tripped = 0;
 2553               	.LM296:
 2554 0d06 1092 0000 		sts alarm_tripped,__zero_reg__
 2555               	.L134:
 705:ratt.c        ****   if (t2divider2 == 6) {
 2557               	.LM297:
 2558 0d0a 8091 0000 		lds r24,t2divider2
 2559 0d0e 8630      		cpi r24,lo8(6)
 2560 0d10 01F4      		brne .L135
 706:ratt.c        ****     t2divider2 = 0;
 2562               	.LM298:
 2563 0d12 1092 0000 		sts t2divider2,__zero_reg__
 712:ratt.c        ****   if (buttonholdcounter) {
 2565               	.LM299:
 2566 0d16 8091 0000 		lds r24,buttonholdcounter
 2567 0d1a 8823      		tst r24
 2568 0d1c 01F4      		brne .L136
 2569 0d1e 00C0      		rjmp .L137
 2570               	.L135:
 708:ratt.c        ****     t2divider2++;
 2572               	.LM300:
 2573 0d20 8F5F      		subi r24,lo8(-(1))
 2574 0d22 8093 0000 		sts t2divider2,r24
 2575 0d26 00C0      		rjmp .L138
 2576               	.L136:
 713:ratt.c        ****     buttonholdcounter--;
 2578               	.LM301:
 2579 0d28 8091 0000 		lds r24,buttonholdcounter
 2580 0d2c 8150      		subi r24,lo8(-(-1))
 2581 0d2e 8093 0000 		sts buttonholdcounter,r24
 2582               	.L137:
 716:ratt.c        ****   if (timeoutcounter) {
 2584               	.LM302:
 2585 0d32 8091 0000 		lds r24,timeoutcounter
 2586 0d36 8823      		tst r24
 2587 0d38 01F0      		breq .L138
 717:ratt.c        ****     timeoutcounter--;
 2589               	.LM303:
 2590 0d3a 8091 0000 		lds r24,timeoutcounter
 2591 0d3e 8150      		subi r24,lo8(-(-1))
 2592 0d40 8093 0000 		sts timeoutcounter,r24
 2593               	.L138:
 2594               	/* epilogue start */
 719:ratt.c        **** }
 2596               	.LM304:
 2597 0d44 FF91      		pop r31
 2598 0d46 EF91      		pop r30
 2599 0d48 BF91      		pop r27
 2600 0d4a AF91      		pop r26
 2601 0d4c 9F91      		pop r25
 2602 0d4e 8F91      		pop r24
 2603 0d50 7F91      		pop r23
 2604 0d52 6F91      		pop r22
 2605 0d54 5F91      		pop r21
 2606 0d56 4F91      		pop r20
 2607 0d58 3F91      		pop r19
 2608 0d5a 2F91      		pop r18
 2609 0d5c 1F91      		pop r17
 2610 0d5e 0F91      		pop r16
 2611 0d60 FF90      		pop r15
 2612 0d62 0F90      		pop r0
 2613 0d64 0FBE      		out __SREG__,r0
 2614 0d66 0F90      		pop r0
 2615 0d68 1F90      		pop __zero_reg__
 2616 0d6a 1895      		reti
 2623               	.Lscope21:
 2625               		.stabd	78,0,0
 2630               	.global	drawArrow
 2632               	drawArrow:
 2633               		.stabd	46,0,0
 516:ratt.c        **** void drawArrow(uint8_t x, uint8_t y, uint8_t l) {
 2635               	.LM305:
 2636               	.LFBB22:
 2637 0d6c EF92      		push r14
 2638 0d6e FF92      		push r15
 2639 0d70 0F93      		push r16
 2640 0d72 1F93      		push r17
 2641               	/* prologue: function */
 2642               	/* frame size = 0 */
 2643 0d74 F82E      		mov r15,r24
 2644 0d76 162F      		mov r17,r22
 2645 0d78 E42E      		mov r14,r20
 517:ratt.c        ****   glcdFillRectangle(x, y, l, 1, ON);
 2647               	.LM306:
 2648 0d7a 21E0      		ldi r18,lo8(1)
 2649 0d7c 01E0      		ldi r16,lo8(1)
 2650 0d7e 0E94 0000 		call glcdFillRectangle
 518:ratt.c        ****   glcdSetDot(x+l-2,y-1);
 2652               	.LM307:
 2653 0d82 FE0C      		add r15,r14
 2654 0d84 0F2D      		mov r16,r15
 2655 0d86 0250      		subi r16,lo8(-(-2))
 2656 0d88 1150      		subi r17,lo8(-(-1))
 2657 0d8a 802F      		mov r24,r16
 2658 0d8c 612F      		mov r22,r17
 2659 0d8e 0E94 0000 		call glcdSetDot
 519:ratt.c        ****   glcdSetDot(x+l-2,y+1);
 2661               	.LM308:
 2662 0d92 1E5F      		subi r17,lo8(-(2))
 2663 0d94 802F      		mov r24,r16
 2664 0d96 612F      		mov r22,r17
 2665 0d98 0E94 0000 		call glcdSetDot
 520:ratt.c        ****   glcdSetDot(x+l-3,y-2);
 2667               	.LM309:
 2668 0d9c 0150      		subi r16,lo8(-(-1))
 2669 0d9e 1350      		subi r17,lo8(-(-3))
 2670 0da0 802F      		mov r24,r16
 2671 0da2 612F      		mov r22,r17
 2672 0da4 0E94 0000 		call glcdSetDot
 521:ratt.c        ****   glcdSetDot(x+l-3,y+2);
 2674               	.LM310:
 2675 0da8 1C5F      		subi r17,lo8(-(4))
 2676 0daa 802F      		mov r24,r16
 2677 0dac 612F      		mov r22,r17
 2678 0dae 0E94 0000 		call glcdSetDot
 2679               	/* epilogue start */
 522:ratt.c        **** }
 2681               	.LM311:
 2682 0db2 1F91      		pop r17
 2683 0db4 0F91      		pop r16
 2684 0db6 FF90      		pop r15
 2685 0db8 EF90      		pop r14
 2686 0dba 0895      		ret
 2688               	.Lscope22:
 2690               		.stabd	78,0,0
 2692               	.global	main
 2694               	main:
 2695               		.stabd	46,0,0
 163:ratt.c        **** int main(void) {
 2697               	.LM312:
 2698               	.LFBB23:
 2699 0dbc 6F92      		push r6
 2700 0dbe 7F92      		push r7
 2701 0dc0 8F92      		push r8
 2702 0dc2 9F92      		push r9
 2703 0dc4 AF92      		push r10
 2704 0dc6 BF92      		push r11
 2705 0dc8 CF92      		push r12
 2706 0dca DF92      		push r13
 2707 0dcc EF92      		push r14
 2708 0dce FF92      		push r15
 2709 0dd0 0F93      		push r16
 2710 0dd2 1F93      		push r17
 2711 0dd4 CF93      		push r28
 2712 0dd6 DF93      		push r29
 2713               	/* prologue: function */
 2714               	/* frame size = 0 */
 169:ratt.c        ****   mcustate = MCUSR;
 2716               	.LM313:
 2717 0dd8 84B7      		in r24,84-32
 170:ratt.c        ****   MCUSR = 0;
 2719               	.LM314:
 2720 0dda 14BE      		out 84-32,__zero_reg__
 176:ratt.c        ****   wdt_disable();
 2722               	.LM315:
 2723 0ddc 88E1      		ldi r24,lo8(24)
 2724               	/* #APP */
 2725               	 ;  176 "ratt.c" 1
 2726 0dde 0FB6      		in __tmp_reg__, __SREG__
 2727 0de0 F894      		cli
 2728 0de2 8093 6000 		sts 96, r24
 2729 0de6 1092 6000 		sts 96, __zero_reg__
 2730 0dea 0FBE      		out __SREG__,__tmp_reg__
 2731               		
 2732               	 ;  0 "" 2
 179:ratt.c        ****   uart_init(BRRL_4800);
 2734               	.LM316:
 2735               	/* #NOAPP */
 2736 0dec 87E6      		ldi r24,lo8(103)
 2737 0dee 90E0      		ldi r25,hi8(103)
 2738 0df0 0E94 0000 		call uart_init
 181:ratt.c        ****   UCSR0B |= _BV(TXEN0) | _BV(RXEN0) | _BV(RXCIE0);
 2740               	.LM317:
 2741 0df4 8091 C100 		lds r24,193
 2742 0df8 8869      		ori r24,lo8(-104)
 2743 0dfa 8093 C100 		sts 193,r24
 187:ratt.c        ****   PIEZO_DDR |= _BV(PIEZO);
 2745               	.LM318:
 2746 0dfe 3B9A      		sbi 39-32,3
 190:ratt.c        ****   clock_init();
 2748               	.LM319:
 2749 0e00 0E94 0000 		call clock_init
 194:ratt.c        ****   init_eeprom();
 2751               	.LM320:
 2752 0e04 0E94 0000 		call init_eeprom
 196:ratt.c        ****   region = eeprom_read_byte(&EE_REGION);
 2754               	.LM321:
 2755 0e08 80E0      		ldi r24,lo8(EE_REGION)
 2756 0e0a 90E0      		ldi r25,hi8(EE_REGION)
 2757 0e0c 0E94 0000 		call __eerd_byte_m328p
 2758 0e10 8093 0000 		sts region,r24
 197:ratt.c        ****   time_format = eeprom_read_byte(&EE_TIME_FORMAT);
 2760               	.LM322:
 2761 0e14 80E0      		ldi r24,lo8(EE_TIME_FORMAT)
 2762 0e16 90E0      		ldi r25,hi8(EE_TIME_FORMAT)
 2763 0e18 0E94 0000 		call __eerd_byte_m328p
 2764 0e1c 8093 0000 		sts time_format,r24
 199:ratt.c        ****   initbuttons();
 2766               	.LM323:
 2767 0e20 0E94 0000 		call initbuttons
 201:ratt.c        ****   setalarmstate();
 2769               	.LM324:
 2770 0e24 0E94 0000 		call setalarmstate
 204:ratt.c        ****   TCCR0A = _BV(WGM01);
 2772               	.LM325:
 2773 0e28 82E0      		ldi r24,lo8(2)
 2774 0e2a 84BD      		out 68-32,r24
 205:ratt.c        ****   TCCR0B = _BV(CS01) | _BV(CS00);
 2776               	.LM326:
 2777 0e2c 83E0      		ldi r24,lo8(3)
 2778 0e2e 85BD      		out 69-32,r24
 206:ratt.c        ****   OCR0A = 125;
 2780               	.LM327:
 2781 0e30 8DE7      		ldi r24,lo8(125)
 2782 0e32 87BD      		out 71-32,r24
 207:ratt.c        ****   TIMSK0 |= _BV(OCIE0A);
 2784               	.LM328:
 2785 0e34 8091 6E00 		lds r24,110
 2786 0e38 8260      		ori r24,lo8(2)
 2787 0e3a 8093 6E00 		sts 110,r24
 210:ratt.c        ****   DDRD |= _BV(3);
 2789               	.LM329:
 2790 0e3e 539A      		sbi 42-32,3
 214:ratt.c        ****   TCCR2A = _BV(COM2B1); // PWM output on pin D3
 2792               	.LM330:
 2793 0e40 80E2      		ldi r24,lo8(32)
 2794 0e42 8093 B000 		sts 176,r24
 215:ratt.c        ****   TCCR2A |= _BV(WGM21) | _BV(WGM20); // fast PWM
 2796               	.LM331:
 2797 0e46 8091 B000 		lds r24,176
 2798 0e4a 8360      		ori r24,lo8(3)
 2799 0e4c 8093 B000 		sts 176,r24
 216:ratt.c        ****   TCCR2B |= _BV(WGM22);
 2801               	.LM332:
 2802 0e50 8091 B100 		lds r24,177
 2803 0e54 8860      		ori r24,lo8(8)
 2804 0e56 8093 B100 		sts 177,r24
 217:ratt.c        ****   OCR2A = OCR2A_VALUE;
 2806               	.LM333:
 2807 0e5a 80E1      		ldi r24,lo8(16)
 2808 0e5c 8093 B300 		sts 179,r24
 218:ratt.c        ****   OCR2B = eeprom_read_byte(&EE_BRIGHT);
 2810               	.LM334:
 2811 0e60 80E0      		ldi r24,lo8(EE_BRIGHT)
 2812 0e62 90E0      		ldi r25,hi8(EE_BRIGHT)
 2813 0e64 0E94 0000 		call __eerd_byte_m328p
 2814 0e68 8093 B400 		sts 180,r24
 221:ratt.c        ****   DDRB |= _BV(5);
 2816               	.LM335:
 2817 0e6c 259A      		sbi 36-32,5
 222:ratt.c        ****   beep(4000, 100);
 2819               	.LM336:
 2820 0e6e 80EA      		ldi r24,lo8(4000)
 2821 0e70 9FE0      		ldi r25,hi8(4000)
 2822 0e72 64E6      		ldi r22,lo8(100)
 2823 0e74 0E94 0000 		call beep
 228:ratt.c        ****   wdt_enable(WDTO_2S);
 2825               	.LM337:
 2826 0e78 2FE0      		ldi r18,lo8(15)
 2827 0e7a 88E1      		ldi r24,lo8(24)
 2828 0e7c 90E0      		ldi r25,hi8(24)
 2829               	/* #APP */
 2830               	 ;  228 "ratt.c" 1
 2831 0e7e 0FB6      		in __tmp_reg__,__SREG__
 2832 0e80 F894      		cli
 2833 0e82 A895      		wdr
 2834 0e84 8093 6000 		sts 96,r24
 2835 0e88 0FBE      		out __SREG__,__tmp_reg__
 2836 0e8a 2093 6000 		sts 96,r18
 2837               		
 2838               	 ;  0 "" 2
 229:ratt.c        ****   glcdInit();
 2840               	.LM338:
 2841               	/* #NOAPP */
 2842 0e8e 0E94 0000 		call glcdInit
 230:ratt.c        ****   glcdClearScreen();
 2844               	.LM339:
 2845 0e92 0E94 0000 		call glcdClearScreen
 235:ratt.c        ****   displaystyle = eeprom_read_byte(&EE_STYLE);
 2847               	.LM340:
 2848 0e96 80E0      		ldi r24,lo8(EE_STYLE)
 2849 0e98 90E0      		ldi r25,hi8(EE_STYLE)
 2850 0e9a 0E94 0000 		call __eerd_byte_m328p
 2851 0e9e 8093 0000 		sts displaystyle,r24
 236:ratt.c        ****   if(displaystyle >= STYLE_ABOUT) {
 2853               	.LM341:
 2854 0ea2 8091 0000 		lds r24,displaystyle
 2855 0ea6 883D      		cpi r24,lo8(-40)
 2856 0ea8 00F0      		brlo .L144
 237:ratt.c        ****     displaystyle = STYLE_ROTATE;
 2858               	.LM342:
 2859 0eaa 85ED      		ldi r24,lo8(-43)
 2860 0eac 8093 0000 		sts displaystyle,r24
 238:ratt.c        ****     eeprom_write_byte(&EE_STYLE,displaystyle);
 2862               	.LM343:
 2863 0eb0 6091 0000 		lds r22,displaystyle
 2864 0eb4 80E0      		ldi r24,lo8(EE_STYLE)
 2865 0eb6 90E0      		ldi r25,hi8(EE_STYLE)
 2866 0eb8 0E94 0000 		call __eewr_byte_m328p
 2867               	.L144:
 240:ratt.c        ****   RotateFlag = 0;
 2869               	.LM344:
 2870 0ebc 1092 0000 		sts RotateFlag,__zero_reg__
 241:ratt.c        ****   initanim();
 2872               	.LM345:
 2873 0ec0 0E94 0000 		call initanim
 2874 0ec4 00E0      		ldi r16,lo8(0)
 2875 0ec6 10E0      		ldi r17,lo8(0)
 244:ratt.c        ****     animticker = ANIMTICK_MS;
 2877               	.LM346:
 2878 0ec8 6BE4      		ldi r22,lo8(75)
 2879 0eca C62E      		mov r12,r22
 2880 0ecc D12C      		mov r13,__zero_reg__
 2881               	.LBB38:
 2882               	.LBB39:
 782:ratt.c        ****   snoozetimer = MAXSNOOZE;
 2884               	.LM347:
 2885 0ece C8E5      		ldi r28,lo8(600)
 2886 0ed0 D2E0      		ldi r29,hi8(600)
 2887               	.LBE39:
 2888               	.LBE38:
 266:ratt.c        **** 	    score_mode_timeout = SCORE_MODE_TIMEOUT;
 2890               	.LM348:
 2891 0ed2 55E0      		ldi r21,lo8(5)
 2892 0ed4 952E      		mov r9,r21
 2893 0ed6 43E0      		ldi r20,lo8(3)
 2894 0ed8 642E      		mov r6,r20
 265:ratt.c        **** 		   score_mode = SCORE_MODE_YEAR;
 2896               	.LM349:
 2897 0eda 32E0      		ldi r19,lo8(2)
 2898 0edc F32E      		mov r15,r19
 259:ratt.c        **** 	      score_mode = SCORE_MODE_DEATH_YEAR;
 2900               	.LM350:
 2901 0ede 26E0      		ldi r18,lo8(6)
 2902 0ee0 B22E      		mov r11,r18
 334:ratt.c        **** 	      score_mode = SCORE_MODE_DEATH_TIME;
 2904               	.LM351:
 2905 0ee2 94E0      		ldi r25,lo8(4)
 2906 0ee4 A92E      		mov r10,r25
 358:ratt.c        **** 	  	score_mode = SCORE_MODE_DATE;
 2908               	.LM352:
 2909 0ee6 EE24      		clr r14
 2910 0ee8 E394      		inc r14
 406:ratt.c        **** 	displaymode = SET_REGION;
 2912               	.LM353:
 2913 0eea 88E0      		ldi r24,lo8(8)
 2914 0eec 882E      		mov r8,r24
 388:ratt.c        **** 	displaymode = SET_STYLE;
 2916               	.LM354:
 2917 0eee B8EC      		ldi r27,lo8(-56)
 2918 0ef0 7B2E      		mov r7,r27
 2919               	.L177:
 244:ratt.c        ****     animticker = ANIMTICK_MS;
 2921               	.LM355:
 2922 0ef2 D092 0000 		sts (animticker)+1,r13
 2923 0ef6 C092 0000 		sts animticker,r12
 247:ratt.c        **** 	if(just_pressed && alarming)
 2925               	.LM356:
 2926 0efa 8091 0000 		lds r24,just_pressed
 2927 0efe 8823      		tst r24
 2928 0f00 01F0      		breq .L145
 2929 0f02 8091 0000 		lds r24,alarming
 2930 0f06 8823      		tst r24
 2931 0f08 01F0      		breq .L145
 249:ratt.c        **** 	  just_pressed = 0;
 2933               	.LM357:
 2934 0f0a 1092 0000 		sts just_pressed,__zero_reg__
 2935               	.LBB41:
 2936               	.LBB40:
 782:ratt.c        ****   snoozetimer = MAXSNOOZE;
 2938               	.LM358:
 2939 0f0e D093 0000 		sts (snoozetimer)+1,r29
 2940 0f12 C093 0000 		sts snoozetimer,r28
 783:ratt.c        ****   TCCR1B = 0;
 2942               	.LM359:
 2943 0f16 1092 8100 		sts 129,__zero_reg__
 785:ratt.c        ****   PIEZO_PORT &= ~_BV(PIEZO);
 2945               	.LM360:
 2946 0f1a 4398      		cbi 40-32,3
 789:ratt.c        ****   displaymode = SHOW_TIME;
 2948               	.LM361:
 2949 0f1c 1092 0000 		sts displaymode,__zero_reg__
 2950               	.L145:
 2951               	.LBE40:
 2952               	.LBE41:
 253:ratt.c        **** 	if(display_date==3 && !score_mode_timeout)
 2954               	.LM362:
 2955 0f20 1330      		cpi r17,lo8(3)
 2956 0f22 01F4      		brne .L146
 2957 0f24 8091 0000 		lds r24,score_mode_timeout
 2958 0f28 8823      		tst r24
 2959 0f2a 01F4      		brne .L146
 257:ratt.c        **** 	  if (displaystyle == STYLE_DEATH) {
 2961               	.LM363:
 2962 0f2c 8091 0000 		lds r24,displaystyle
 2963 0f30 833D      		cpi r24,lo8(-45)
 2964 0f32 01F4      		brne .L147
 258:ratt.c        **** 	    if(score_mode >= SCORE_MODE_DEATH_TIME)
 2966               	.LM364:
 2967 0f34 8091 0000 		lds r24,score_mode
 2968 0f38 8430      		cpi r24,lo8(4)
 2969 0f3a 00F0      		brlo .L147
 259:ratt.c        **** 	      score_mode = SCORE_MODE_DEATH_YEAR;
 2971               	.LM365:
 2972 0f3c B092 0000 		sts score_mode,r11
 2973 0f40 00C0      		rjmp .L149
 2974               	.L147:
 265:ratt.c        **** 		   score_mode = SCORE_MODE_YEAR;
 2976               	.LM366:
 2977 0f42 F092 0000 		sts score_mode,r15
 2978               	.L149:
 266:ratt.c        **** 	    score_mode_timeout = SCORE_MODE_TIMEOUT;
 2980               	.LM367:
 2981 0f46 8091 0000 		lds r24,displaystyle
 2982 0f4a 8130      		cpi r24,lo8(1)
 2983 0f4c 01F0      		breq .L150
 2984 0f4e 83E0      		ldi r24,lo8(3)
 2985 0f50 00C0      		rjmp .L151
 2986               	.L150:
 2987 0f52 85E0      		ldi r24,lo8(5)
 2988               	.L151:
 2989 0f54 8093 0000 		sts score_mode_timeout,r24
 2990 0f58 10E0      		ldi r17,lo8(0)
 2991               	.L146:
 329:ratt.c        ****     if(just_pressed & 0x4) {
 2993               	.LM368:
 2994 0f5a 8091 0000 		lds r24,just_pressed
 2995 0f5e 82FF      		sbrs r24,2
 2996 0f60 00C0      		rjmp .L152
 331:ratt.c        **** 	  if (displaystyle == STYLE_DEATH) {
 2998               	.LM369:
 2999 0f62 8091 0000 		lds r24,displaystyle
 3000 0f66 833D      		cpi r24,lo8(-45)
 3001 0f68 01F4      		brne .L153
 332:ratt.c        **** 	    just_pressed = 0;
 3003               	.LM370:
 3004 0f6a 1092 0000 		sts just_pressed,__zero_reg__
 333:ratt.c        **** 	    if(score_mode < SCORE_MODE_DEATH_TIME)
 3006               	.LM371:
 3007 0f6e 8091 0000 		lds r24,score_mode
 3008 0f72 8430      		cpi r24,lo8(4)
 3009 0f74 00F4      		brsh .L154
 334:ratt.c        **** 	      score_mode = SCORE_MODE_DEATH_TIME;
 3011               	.LM372:
 3012 0f76 A092 0000 		sts score_mode,r10
 3013 0f7a 00C0      		rjmp .L152
 3014               	.L154:
 336:ratt.c        **** 	      score_mode = SCORE_MODE_TIME;
 3016               	.LM373:
 3017 0f7c 1092 0000 		sts score_mode,__zero_reg__
 3018 0f80 00C0      		rjmp .L152
 3019               	.L153:
 340:ratt.c        **** 	    just_pressed = 2;
 3021               	.LM374:
 3022 0f82 F092 0000 		sts just_pressed,r15
 3023               	.L152:
 343:ratt.c        **** 	if (just_pressed & 0x2) {
 3025               	.LM375:
 3026 0f86 8091 0000 		lds r24,just_pressed
 3027 0f8a 81FF      		sbrs r24,1
 3028 0f8c 00C0      		rjmp .L155
 344:ratt.c        **** 	  just_pressed = 0;
 3030               	.LM376:
 3031 0f8e 1092 0000 		sts just_pressed,__zero_reg__
 350:ratt.c        **** 	  if (displaystyle == STYLE_DEATH) {
 3033               	.LM377:
 3034 0f92 8091 0000 		lds r24,displaystyle
 3035 0f96 833D      		cpi r24,lo8(-45)
 3036 0f98 01F4      		brne .L156
 351:ratt.c        **** 	    if(score_mode >= SCORE_MODE_DEATH_TIME)
 3038               	.LM378:
 3039 0f9a 8091 0000 		lds r24,score_mode
 3040 0f9e 8430      		cpi r24,lo8(4)
 3041 0fa0 00F0      		brlo .L156
 352:ratt.c        **** 	      score_mode = SCORE_MODE_DEATH_DATE;
 3043               	.LM379:
 3044 0fa2 9092 0000 		sts score_mode,r9
 3045 0fa6 00C0      		rjmp .L158
 3046               	.L156:
 358:ratt.c        **** 	  	score_mode = SCORE_MODE_DATE;
 3048               	.LM380:
 3049 0fa8 E092 0000 		sts score_mode,r14
 3050               	.L158:
 374:ratt.c        **** 	  score_mode_timeout = SCORE_MODE_TIMEOUT;
 3052               	.LM381:
 3053 0fac 8091 0000 		lds r24,displaystyle
 3054 0fb0 8130      		cpi r24,lo8(1)
 3055 0fb2 01F0      		breq .L159
 3056 0fb4 83E0      		ldi r24,lo8(3)
 3057 0fb6 00C0      		rjmp .L160
 3058               	.L159:
 3059 0fb8 85E0      		ldi r24,lo8(5)
 3060               	.L160:
 3061 0fba 8093 0000 		sts score_mode_timeout,r24
 3062 0fbe 13E0      		ldi r17,lo8(3)
 3063               	.L155:
 378:ratt.c        ****     if (just_pressed & 0x1) {
 3065               	.LM382:
 3066 0fc0 8091 0000 		lds r24,just_pressed
 3067 0fc4 80FF      		sbrs r24,0
 3068 0fc6 00C0      		rjmp .L161
 379:ratt.c        ****       just_pressed = 0;
 3070               	.LM383:
 3071 0fc8 1092 0000 		sts just_pressed,__zero_reg__
 381:ratt.c        ****       score_mode = SCORE_MODE_TIME;
 3073               	.LM384:
 3074 0fcc 1092 0000 		sts score_mode,__zero_reg__
 382:ratt.c        ****       score_mode_timeout = 0;
 3076               	.LM385:
 3077 0fd0 1092 0000 		sts score_mode_timeout,__zero_reg__
 384:ratt.c        ****       switch(displaymode) {
 3079               	.LM386:
 3080 0fd4 8091 0000 		lds r24,displaymode
 3081 0fd8 8530      		cpi r24,lo8(5)
 3082 0fda 01F0      		breq .L166
 3083 0fdc 8630      		cpi r24,lo8(6)
 3084 0fde 00F4      		brsh .L169
 3085 0fe0 8330      		cpi r24,lo8(3)
 3086 0fe2 01F0      		breq .L164
 3087 0fe4 8430      		cpi r24,lo8(4)
 3088 0fe6 00F4      		brsh .L165
 3089 0fe8 8823      		tst r24
 3090 0fea 01F0      		breq .L163
 3091 0fec 00C0      		rjmp .L162
 3092               	.L169:
 3093 0fee 8236      		cpi r24,lo8(98)
 3094 0ff0 01F0      		breq .L163
 3095 0ff2 883C      		cpi r24,lo8(-56)
 3096 0ff4 01F0      		breq .L168
 3097 0ff6 8830      		cpi r24,lo8(8)
 3098 0ff8 01F4      		brne .L162
 3099 0ffa 00C0      		rjmp .L182
 3100               	.L163:
 388:ratt.c        **** 	displaymode = SET_STYLE;
 3102               	.LM387:
 3103 0ffc 7092 0000 		sts displaymode,r7
 389:ratt.c        **** 	set_style();
 3105               	.LM388:
 3106 1000 0E94 0000 		call set_style
 3107 1004 00C0      		rjmp .L170
 3108               	.L168:
 393:ratt.c        **** 	displaymode = SET_ALARM;
 3110               	.LM389:
 3111 1006 A092 0000 		sts displaymode,r10
 394:ratt.c        **** 	set_alarm();
 3113               	.LM390:
 3114 100a 0E94 0000 		call set_alarm
 3115 100e 00C0      		rjmp .L170
 3116               	.L165:
 397:ratt.c        **** 	displaymode = SET_TIME;
 3118               	.LM391:
 3119 1010 6092 0000 		sts displaymode,r6
 398:ratt.c        **** 	set_time();
 3121               	.LM392:
 3122 1014 0E94 0000 		call set_time
 399:ratt.c        **** 	timeunknown = 0;
 3124               	.LM393:
 3125 1018 1092 0000 		sts timeunknown,__zero_reg__
 3126 101c 00C0      		rjmp .L170
 3127               	.L164:
 402:ratt.c        **** 	displaymode = SET_DATE;
 3129               	.LM394:
 3130 101e 9092 0000 		sts displaymode,r9
 403:ratt.c        **** 	set_date();
 3132               	.LM395:
 3133 1022 0E94 0000 		call set_date
 3134 1026 00C0      		rjmp .L170
 3135               	.L166:
 406:ratt.c        **** 	displaymode = SET_REGION;
 3137               	.LM396:
 3138 1028 8092 0000 		sts displaymode,r8
 407:ratt.c        **** 	set_region();
 3140               	.LM397:
 3141 102c 0E94 0000 		call set_region
 3142 1030 00C0      		rjmp .L170
 3143               	.L182:
 411:ratt.c        **** 	displaymode = SET_BRIGHTNESS;
 3145               	.LM398:
 3146 1032 B092 0000 		sts displaymode,r11
 412:ratt.c        **** 	set_backlight();
 3148               	.LM399:
 3149 1036 0E94 0000 		call set_backlight
 3150 103a 00C0      		rjmp .L170
 3151               	.L162:
 416:ratt.c        **** 	displaymode = SHOW_TIME;
 3153               	.LM400:
 3154 103c 1092 0000 		sts displaymode,__zero_reg__
 3155               	.L170:
 423:ratt.c        ****       if (displaymode == SHOW_TIME) {
 3157               	.LM401:
 3158 1040 8091 0000 		lds r24,displaymode
 3159 1044 8823      		tst r24
 3160 1046 01F4      		brne .L181
 3161               	.L171:
 424:ratt.c        **** 	glcdClearScreen();
 3163               	.LM402:
 3164 1048 0E94 0000 		call glcdClearScreen
 427:ratt.c        **** 	initanim();
 3166               	.LM403:
 3167 104c 0E94 0000 		call initanim
 3168               	.L181:
 3169 1050 10E0      		ldi r17,lo8(0)
 3170               	.L161:
 431:ratt.c        ****     step();
 3172               	.LM404:
 3173 1052 0E94 0000 		call step
 432:ratt.c        ****     if (displaymode == SHOW_TIME) {
 3175               	.LM405:
 3176 1056 8091 0000 		lds r24,displaymode
 3177 105a 8823      		tst r24
 3178 105c 01F4      		brne .L179
 433:ratt.c        ****       if (! inverted && alarming && (time_s & 0x1)) {
 3180               	.LM406:
 3181 105e 0023      		tst r16
 3182 1060 01F4      		brne .L173
 3183 1062 8091 0000 		lds r24,alarming
 3184 1066 8823      		tst r24
 3185 1068 01F0      		breq .L174
 3186 106a 8091 0000 		lds r24,time_s
 3187 106e 80FF      		sbrs r24,0
 3188 1070 00C0      		rjmp .L174
 435:ratt.c        **** 	initdisplay(inverted);
 3190               	.LM407:
 3191 1072 81E0      		ldi r24,lo8(1)
 3192 1074 0E94 0000 		call initdisplay
 3193 1078 01E0      		ldi r16,lo8(1)
 3194 107a 00C0      		rjmp .L179
 3195               	.L173:
 437:ratt.c        ****       else if ((inverted && ! alarming) || (alarming && inverted && !(time_s & 0x1))) {
 3197               	.LM408:
 3198 107c 8091 0000 		lds r24,alarming
 3199 1080 8823      		tst r24
 3200 1082 01F0      		breq .L175
 3201               	.L174:
 3202 1084 8091 0000 		lds r24,alarming
 3203 1088 8823      		tst r24
 3204 108a 01F0      		breq .L176
 3205 108c 0023      		tst r16
 3206 108e 01F0      		breq .L176
 3207 1090 8091 0000 		lds r24,time_s
 3208 1094 80FD      		sbrc r24,0
 3209 1096 00C0      		rjmp .L176
 3210               	.L175:
 439:ratt.c        **** 	initdisplay(0);
 3212               	.LM409:
 3213 1098 80E0      		ldi r24,lo8(0)
 3214 109a 0E94 0000 		call initdisplay
 3215 109e 00E0      		ldi r16,lo8(0)
 3216 10a0 00C0      		rjmp .L179
 3217               	.L176:
 441:ratt.c        **** 	PORTB |= _BV(5);
 3219               	.LM410:
 3220 10a2 2D9A      		sbi 37-32,5
 442:ratt.c        **** 	drawdisplay(inverted);
 3222               	.LM411:
 3223 10a4 802F      		mov r24,r16
 3224 10a6 0E94 0000 		call drawdisplay
 443:ratt.c        **** 	PORTB &= ~_BV(5);
 3226               	.LM412:
 3227 10aa 2D98      		cbi 37-32,5
 3228               	.L179:
 447:ratt.c        ****     while (animticker);
 3230               	.LM413:
 3231 10ac 8091 0000 		lds r24,animticker
 3232 10b0 9091 0000 		lds r25,(animticker)+1
 3233 10b4 892B      		or r24,r25
 3234 10b6 01F4      		brne .L179
 3235 10b8 00C0      		rjmp .L177
 3242               	.Lscope23:
 3244               		.stabd	78,0,0
 3245               	.global	timeunknown
 3246               		.data
 3249               	timeunknown:
 3250 0014 01        		.byte	1
 3251               	.global	sleepmode
 3252               	.global	sleepmode
 3253               		.section .bss
 3256               	sleepmode:
 3257 0000 00        		.skip 1,0
 3258               	.global	minute_changed
 3259               	.global	minute_changed
 3262               	minute_changed:
 3263 0001 00        		.skip 1,0
 3264               	.global	hour_changed
 3265               	.global	hour_changed
 3268               	hour_changed:
 3269 0002 00        		.skip 1,0
 3270               	.global	second_changed
 3271               	.global	second_changed
 3274               	second_changed:
 3275 0003 00        		.skip 1,0
 3276               	.global	score_mode_timeout
 3277               	.global	score_mode_timeout
 3280               	score_mode_timeout:
 3281 0004 00        		.skip 1,0
 3282               	.global	score_mode
 3283               	.global	score_mode
 3286               	score_mode:
 3287 0005 00        		.skip 1,0
 3288               	.global	gpsenable
 3289               	.global	gpsenable
 3292               	gpsenable:
 3293 0006 00        		.skip 1,0
 3294               	.global	timezone
 3295               	.global	timezone
 3298               	timezone:
 3299 0007 00        		.skip 1,0
 3300               	.global	timezonehour
 3301               	.global	timezonehour
 3304               	timezonehour:
 3305 0008 00        		.skip 1,0
 3306               	.global	timezonemin
 3307               	.global	timezonemin
 3310               	timezonemin:
 3311 0009 00        		.skip 1,0
 3312               	.global	rx_buffer
 3313               	.global	rx_buffer
 3316               	rx_buffer:
 3317 000a 0000 0000 		.skip 132,0
 3317      0000 0000 
 3317      0000 0000 
 3317      0000 0000 
 3317      0000 0000 
 3318               	.global	snoozetimer
 3319               	.global	snoozetimer
 3322               	snoozetimer:
 3323 008e 0000      		.skip 2,0
 3324               	.global	millis
 3325               	.global	millis
 3328               	millis:
 3329 0090 0000      		.skip 2,0
 3330               	.global	t2divider1
 3331               	.global	t2divider1
 3334               	t2divider1:
 3335 0092 00        		.skip 1,0
 3336               	.global	t2divider2
 3337               	.global	t2divider2
 3340               	t2divider2:
 3341 0093 00        		.skip 1,0
 3342               		.lcomm scrpos.2665,1
 3343               		.lcomm dadjflag.2664,1
 3344               		.lcomm buffer.2663,11
 3345               		.lcomm blen.2662,1
 3346               		.lcomm soh.2661,1
 3347               		.data
 3350               	C.122.2689:
 3351 0015 1F        		.byte	31
 3352 0016 1C        		.byte	28
 3353 0017 1F        		.byte	31
 3354 0018 1E        		.byte	30
 3355 0019 1F        		.byte	31
 3356 001a 1E        		.byte	30
 3357 001b 1F        		.byte	31
 3358 001c 1F        		.byte	31
 3359 001d 1E        		.byte	30
 3360 001e 1F        		.byte	31
 3361 001f 1E        		.byte	30
 3362 0020 1F        		.byte	31
 3363               		.comm time_s,1,1
 3364               		.comm time_m,1,1
 3365               		.comm time_h,1,1
 3366               		.comm old_h,1,1
 3367               		.comm old_m,1,1
 3368               		.comm old_s,1,1
 3369               		.comm date_m,1,1
 3370               		.comm date_d,1,1
 3371               		.comm date_y,1,1
 3372               		.comm alarming,1,1
 3373               		.comm alarm_on,1,1
 3374               		.comm alarm_tripped,1,1
 3375               		.comm alarm_h,1,1
 3376               		.comm alarm_m,1,1
 3377               		.comm displaymode,1,1
 3378               		.comm volume,1,1
 3379               		.comm region,1,1
 3380               		.comm time_format,1,1
 3381               		.comm last_score_mode,1,1
 3382               		.comm displaystyle,1,1
 3383               		.comm RotateFlag,1,1
 3384               		.comm animticker,2,1
 3385               		.comm alarmticker,2,1
 3430               		.text
 3432               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 ratt.c
     /tmp/ccHu0yfj.s:2      *ABS*:0000003f __SREG__
     /tmp/ccHu0yfj.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccHu0yfj.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccHu0yfj.s:5      *ABS*:00000034 __CCP__
     /tmp/ccHu0yfj.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccHu0yfj.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccHu0yfj.s:143    .text:00000000 __vector_18
     /tmp/ccHu0yfj.s:3316   .bss:0000000a rx_buffer
     /tmp/ccHu0yfj.s:231    .text:0000007a char_available
     /tmp/ccHu0yfj.s:262    .text:0000009c char_read
     /tmp/ccHu0yfj.s:318    .text:000000da __vector_13
     /tmp/ccHu0yfj.s:355    .text:000000fe __vector_14
     /tmp/ccHu0yfj.s:3328   .bss:00000090 millis
                            *COM*:00000002 animticker
                            *COM*:00000001 alarming
     /tmp/ccHu0yfj.s:3322   .bss:0000008e snoozetimer
                            *COM*:00000002 alarmticker
     /tmp/ccHu0yfj.s:474    .text:000001c0 __vector_11
     /tmp/ccHu0yfj.s:511    .text:000001e4 setalarmstate
                            *COM*:00000001 alarm_on
                            *COM*:00000001 alarm_tripped
                            *COM*:00000001 displaystyle
     /tmp/ccHu0yfj.s:3286   .bss:00000005 score_mode
     /tmp/ccHu0yfj.s:3280   .bss:00000004 score_mode_timeout
     /tmp/ccHu0yfj.s:607    .text:00000258 leapyear
     /tmp/ccHu0yfj.s:652    .text:0000028a tick
     /tmp/ccHu0yfj.s:671    .text:0000028c i2bcd
     /tmp/ccHu0yfj.s:705    .text:000002ae setsnooze
                            *COM*:00000001 displaymode
     /tmp/ccHu0yfj.s:739    .text:000002c6 DecodeGPSBuffer
     /tmp/ccHu0yfj.s:770    .text:000002da printnumber
     /tmp/ccHu0yfj.s:819    .text:00000308 GPSRead
     /tmp/ccHu0yfj.s:3298   .bss:00000007 timezone
     /tmp/ccHu0yfj.s:3304   .bss:00000008 timezonehour
     /tmp/ccHu0yfj.s:3310   .bss:00000009 timezonemin
     /tmp/ccHu0yfj.s:3350   .data:00000015 C.122.2689
                             .bss:00000094 scrpos.2665
     /tmp/ccHu0yfj.s:3345   .bss:000000a2 soh.2661
     /tmp/ccHu0yfj.s:3344   .bss:000000a1 blen.2662
     /tmp/ccHu0yfj.s:3343   .bss:00000096 buffer.2663
                            *COM*:00000001 time_s
                            *COM*:00000001 time_m
                            *COM*:00000001 time_h
     /tmp/ccHu0yfj.s:3342   .bss:00000095 dadjflag.2664
                            *COM*:00000001 date_d
                            *COM*:00000001 date_m
                            *COM*:00000001 date_y
     /tmp/ccHu0yfj.s:1546   .text:00000768 beep
     /tmp/ccHu0yfj.s:1616   .text:000007b4 writei2ctime
     /tmp/ccHu0yfj.s:1769   .text:0000087a GPSCheck
     /tmp/ccHu0yfj.s:1832   .text:000008d8 init_eeprom
     /tmp/ccHu0yfj.s:1903   .text:00000924 readi2ctime
     /tmp/ccHu0yfj.s:2210   .text:00000afe clock_init
                            *COM*:00000001 alarm_m
                            *COM*:00000001 alarm_h
     /tmp/ccHu0yfj.s:2289   .text:00000b64 __vector_9
     /tmp/ccHu0yfj.s:3334   .bss:00000092 t2divider1
     /tmp/ccHu0yfj.s:3268   .bss:00000002 hour_changed
                            *COM*:00000001 old_h
     /tmp/ccHu0yfj.s:3262   .bss:00000001 minute_changed
                            *COM*:00000001 old_m
     /tmp/ccHu0yfj.s:3274   .bss:00000003 second_changed
                            *COM*:00000001 old_s
                            *COM*:00000001 last_score_mode
     /tmp/ccHu0yfj.s:3340   .bss:00000093 t2divider2
     /tmp/ccHu0yfj.s:2632   .text:00000d6c drawArrow
     /tmp/ccHu0yfj.s:2694   .text:00000dbc main
                            *COM*:00000001 region
                            *COM*:00000001 time_format
                            *COM*:00000001 RotateFlag
     /tmp/ccHu0yfj.s:3249   .data:00000014 timeunknown
     /tmp/ccHu0yfj.s:3256   .bss:00000000 sleepmode
     /tmp/ccHu0yfj.s:3292   .bss:00000006 gpsenable
                            *COM*:00000001 volume

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__divmodhi4
__udivmodhi4
__udivmodqi4
glcdWriteChar
EE_TIMEZONE
__eerd_byte_m328p
glcdSetAddress
strcmp
glcdPutStr_ram
__divmodsi4
delay_ms
i2cMasterSendNI
dotw
EE_INIT
EE_DATA
i2cMasterReceiveNI
i2cInit
EE_ALARM_MIN
EE_ALARM_HOUR
border_tick
buttonholdcounter
timeoutcounter
glcdFillRectangle
glcdSetDot
uart_init
EE_REGION
EE_TIME_FORMAT
initbuttons
EE_BRIGHT
glcdInit
glcdClearScreen
EE_STYLE
__eewr_byte_m328p
initanim
just_pressed
set_style
set_alarm
set_time
set_date
set_region
set_backlight
step
initdisplay
drawdisplay
