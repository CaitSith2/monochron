   1               		.file	"buttons.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  12               		.text
  13               	.Ltext0:
 131               	.global	initbuttons
 133               	initbuttons:
 134               		.stabd	46,0,0
   0:buttons.c     **** /* ***************************************************************************
   1:buttons.c     **** // buttons.c - the button debouncing/switches handling
   2:buttons.c     **** // This code is distributed under the GNU Public License
   3:buttons.c     **** //		which can be found at http://www.gnu.org/licenses/gpl.txt
   4:buttons.c     **** //
   5:buttons.c     **** **************************************************************************** */
   6:buttons.c     **** 
   7:buttons.c     **** #include <avr/io.h>      // this contains all the IO port definitions
   8:buttons.c     **** #include <avr/interrupt.h>
   9:buttons.c     **** #include <util/delay.h>
  10:buttons.c     **** #include <avr/pgmspace.h>
  11:buttons.c     **** #include <avr/eeprom.h>
  12:buttons.c     **** #include <string.h>
  13:buttons.c     **** #include "util.h"
  14:buttons.c     **** #include "ratt.h"
  15:buttons.c     **** #include "ks0108.h"
  16:buttons.c     **** #include "glcd.h"
  17:buttons.c     **** 
  18:buttons.c     **** // These store the current button states for all 3 buttons. We can 
  19:buttons.c     **** // then query whether the buttons are pressed and released or pressed
  20:buttons.c     **** // This allows for 'high speed incrementing' when setting the time
  21:buttons.c     **** volatile uint8_t last_buttonstate = 0, debounce = 0, just_pressed = 0, pressed = 0;
  22:buttons.c     **** volatile uint8_t buttonholdcounter = 0;
  23:buttons.c     **** 
  24:buttons.c     **** // whether hte alarm is going off
  25:buttons.c     **** extern volatile uint8_t alarming;
  26:buttons.c     **** 
  27:buttons.c     **** void initbuttons(void) {
 136               	.LM0:
 137               	.LFBB1:
 138               	/* prologue: function */
 139               	/* frame size = 0 */
  28:buttons.c     ****   // alarm pin requires a pullup
  29:buttons.c     ****   ALARM_DDR &= ~_BV(ALARM);
 141               	.LM1:
 142 0000 2698      		cbi 36-32,6
  30:buttons.c     ****   ALARM_PORT |= _BV(ALARM);
 144               	.LM2:
 145 0002 2E9A      		sbi 37-32,6
  31:buttons.c     **** 
  32:buttons.c     ****   // alarm switching is detected by using the pin change interrupt
  33:buttons.c     ****   PCICR =  _BV(PCIE0);
 147               	.LM3:
 148 0004 81E0      		ldi r24,lo8(1)
 149 0006 8093 6800 		sts 104,r24
  34:buttons.c     ****   PCMSK0 |= _BV(ALARM);
 151               	.LM4:
 152 000a EBE6      		ldi r30,lo8(107)
 153 000c F0E0      		ldi r31,hi8(107)
 154 000e 8081      		ld r24,Z
 155 0010 8064      		ori r24,lo8(64)
 156 0012 8083      		st Z,r24
  35:buttons.c     **** 
  36:buttons.c     ****   // The buttons are totem pole'd together so we can read the buttons with one pin
  37:buttons.c     ****   // set up ADC
  38:buttons.c     ****   ADMUX = 2;      // listen to ADC2 for button presses
 158               	.LM5:
 159 0014 82E0      		ldi r24,lo8(2)
 160 0016 8093 7C00 		sts 124,r24
  39:buttons.c     ****   ADCSRB = 0;     // free running mode
 162               	.LM6:
 163 001a 1092 7B00 		sts 123,__zero_reg__
  40:buttons.c     ****   // enable ADC and interrupts, prescale down to <200KHz
  41:buttons.c     ****   ADCSRA = _BV(ADEN) | _BV(ADIE) | _BV(ADPS2) | _BV(ADPS1); 
 165               	.LM7:
 166 001e EAE7      		ldi r30,lo8(122)
 167 0020 F0E0      		ldi r31,hi8(122)
 168 0022 8EE8      		ldi r24,lo8(-114)
 169 0024 8083      		st Z,r24
  42:buttons.c     ****   ADCSRA |= _BV(ADSC); // start a conversion
 171               	.LM8:
 172 0026 8081      		ld r24,Z
 173 0028 8064      		ori r24,lo8(64)
 174 002a 8083      		st Z,r24
 175               	/* epilogue start */
  43:buttons.c     **** }
 177               	.LM9:
 178 002c 0895      		ret
 180               	.Lscope1:
 182               		.stabd	78,0,0
 184               	.global	readADC
 186               	readADC:
 187               		.stabd	46,0,0
  44:buttons.c     **** 
  45:buttons.c     **** uint16_t readADC(void) {
 189               	.LM10:
 190               	.LFBB2:
 191               	/* prologue: function */
 192               	/* frame size = 0 */
  46:buttons.c     ****   // basically just the busy-wait code to read the ADC and return the value
  47:buttons.c     ****   ADCSRA &= ~_BV(ADIE); // no interrupt
 194               	.LM11:
 195 002e 8091 7A00 		lds r24,122
 196 0032 877F      		andi r24,lo8(-9)
 197 0034 8093 7A00 		sts 122,r24
  48:buttons.c     ****   ADCSRA |= _BV(ADSC); // start a conversion
 199               	.LM12:
 200 0038 8091 7A00 		lds r24,122
 201 003c 8064      		ori r24,lo8(64)
 202 003e 8093 7A00 		sts 122,r24
 203               	.L4:
  49:buttons.c     ****   while (! (ADCSRA & _BV(ADIF)));
 205               	.LM13:
 206 0042 8091 7A00 		lds r24,122
 207 0046 84FF      		sbrs r24,4
 208 0048 00C0      		rjmp .L4
  50:buttons.c     ****   return ADC;
 210               	.LM14:
 211 004a 2091 7800 		lds r18,120
 212 004e 3091 7900 		lds r19,(120)+1
  51:buttons.c     **** }
 214               	.LM15:
 215 0052 C901      		movw r24,r18
 216               	/* epilogue start */
 217 0054 0895      		ret
 219               	.Lscope2:
 221               		.stabd	78,0,0
 223               	.global	__vector_3
 225               	__vector_3:
 226               		.stabd	46,0,0
  52:buttons.c     **** 
  53:buttons.c     **** // Every time the ADC finishes a conversion, we'll see whether
  54:buttons.c     **** // the buttons have changed
  55:buttons.c     **** SIGNAL(ADC_vect) {
  56:buttons.c     ****   uint16_t reading, reading2;
  57:buttons.c     ****   sei();
  58:buttons.c     **** 
  59:buttons.c     ****   // We get called when ADC is ready so no need to request a conversion
  60:buttons.c     ****   reading = ADC;
  61:buttons.c     **** 
  62:buttons.c     ****   if (reading > 735) {
  63:buttons.c     ****     // no presses
  64:buttons.c     ****     pressed = 0;
  65:buttons.c     ****     last_buttonstate = 0;
  66:buttons.c     ****     
  67:buttons.c     ****     ADCSRA |= _BV(ADIE) | _BV(ADSC); // start next conversion  
  68:buttons.c     ****     return;
  69:buttons.c     ****   } else if (reading > 610) {
  70:buttons.c     ****     // button 3 "+" pressed
  71:buttons.c     ****     if (!last_buttonstate) { // was not pressed before
  72:buttons.c     ****       // debounce by taking a second reading 
  73:buttons.c     ****       delay_ms(10);
  74:buttons.c     ****       reading2 = readADC();
  75:buttons.c     ****       if ( (reading2 > 735) || (reading2 < 610)) {
  76:buttons.c     **** 	// was a bounce, ignore it
  77:buttons.c     **** 	ADCSRA |= _BV(ADIE) | _BV(ADSC); // start next conversion  	
  78:buttons.c     **** 	return;
  79:buttons.c     ****       }
  80:buttons.c     ****       buttonholdcounter = 2;
  81:buttons.c     ****       last_buttonstate = 0x4;
  82:buttons.c     ****       just_pressed = 0x4;
  83:buttons.c     **** 	  ADCSRA |= _BV(ADIE) | _BV(ADSC); // start next conversion  	
  84:buttons.c     **** 	  return;
  85:buttons.c     ****     } else {
  86:buttons.c     **** 
  87:buttons.c     ****       // the buttonholdcounter is decremented by a timer!
  88:buttons.c     ****       if (buttonholdcounter) {
  89:buttons.c     **** 	     ADCSRA |= _BV(ADIE) | _BV(ADSC); // start next conversion  	
  90:buttons.c     **** 	     return;
  91:buttons.c     ****       }
  92:buttons.c     ****       // 2 seconds later...
  93:buttons.c     ****       pressed = 0x4;                 // The button was held down (fast advance)
  94:buttons.c     ****     }
  95:buttons.c     **** 
  96:buttons.c     ****   } else if (reading > 270) {
  97:buttons.c     ****     // button 2 "SET" pressed
  98:buttons.c     ****     if (!last_buttonstate) { // was not pressed before
  99:buttons.c     ****       // debounce by taking a second reading 
 100:buttons.c     ****       delay_ms(10);
 101:buttons.c     ****       reading2 = readADC();
 102:buttons.c     ****       if ( (reading2 > 610) || (reading2 < 270)) {
 103:buttons.c     **** 	// was a bounce, ignore it
 104:buttons.c     **** 	ADCSRA |= _BV(ADIE) | _BV(ADSC); // start next conversion  	
 105:buttons.c     **** 	return;
 106:buttons.c     ****       }
 107:buttons.c     ****       DEBUG(putstring_nl("b2"));
 108:buttons.c     ****       just_pressed = 0x2;
 109:buttons.c     ****       last_buttonstate = 0x2;
 110:buttons.c     ****       pressed = 0x2;                 // held down
 111:buttons.c     ****     }
 112:buttons.c     ****   } else {
 113:buttons.c     ****     // button 1 "MENU" pressed
 114:buttons.c     ****     if (!last_buttonstate) { // was not pressed before
 115:buttons.c     ****       // debounce by taking a second reading 
 116:buttons.c     ****       delay_ms(10);
 117:buttons.c     ****       reading2 = readADC();
 118:buttons.c     ****       if (reading2 > 270) {
 119:buttons.c     **** 	// was a bounce, ignore it
 120:buttons.c     **** 	ADCSRA |= _BV(ADIE) | _BV(ADSC); // start next conversion  	
 121:buttons.c     **** 	return;
 122:buttons.c     ****       }
 123:buttons.c     ****       DEBUG(putstring_nl("b1"));
 124:buttons.c     ****       just_pressed = 0x1;
 125:buttons.c     ****       last_buttonstate = 0x1;
 126:buttons.c     ****       pressed = 0x1;                 // held down
 127:buttons.c     ****     }
 128:buttons.c     ****   }
 129:buttons.c     ****   ADCSRA |= _BV(ADIE) | _BV(ADSC); // start next conversion  
 130:buttons.c     **** }
 131:buttons.c     **** 
 132:buttons.c     **** // We use the pin change interrupts to detect when alarm changes
 133:buttons.c     **** SIGNAL(PCINT0_vect) {
 228               	.LM16:
 229               	.LFBB3:
 230 0056 1F92      		push __zero_reg__
 231 0058 0F92      		push r0
 232 005a 0FB6      		in r0,__SREG__
 233 005c 0F92      		push r0
 234 005e 1124      		clr __zero_reg__
 235 0060 2F93      		push r18
 236 0062 3F93      		push r19
 237 0064 4F93      		push r20
 238 0066 5F93      		push r21
 239 0068 6F93      		push r22
 240 006a 7F93      		push r23
 241 006c 8F93      		push r24
 242 006e 9F93      		push r25
 243 0070 AF93      		push r26
 244 0072 BF93      		push r27
 245 0074 EF93      		push r30
 246 0076 FF93      		push r31
 247               	/* prologue: Signal */
 248               	/* frame size = 0 */
 134:buttons.c     ****   // allow interrupts while we're doing this
 135:buttons.c     ****   sei();
 250               	.LM17:
 251               	/* #APP */
 252               	 ;  136 "buttons.c" 1
 253 0078 7894      		sei
 254               	 ;  0 "" 2
 136:buttons.c     ****   setalarmstate();
 256               	.LM18:
 257               	/* #NOAPP */
 258 007a 0E94 0000 		call setalarmstate
 259               	/* epilogue start */
 137:buttons.c     **** }
 261               	.LM19:
 262 007e FF91      		pop r31
 263 0080 EF91      		pop r30
 264 0082 BF91      		pop r27
 265 0084 AF91      		pop r26
 266 0086 9F91      		pop r25
 267 0088 8F91      		pop r24
 268 008a 7F91      		pop r23
 269 008c 6F91      		pop r22
 270 008e 5F91      		pop r21
 271 0090 4F91      		pop r20
 272 0092 3F91      		pop r19
 273 0094 2F91      		pop r18
 274 0096 0F90      		pop r0
 275 0098 0FBE      		out __SREG__,r0
 276 009a 0F90      		pop r0
 277 009c 1F90      		pop __zero_reg__
 278 009e 1895      		reti
 280               	.Lscope3:
 282               		.stabd	78,0,0
 284               	.global	__vector_21
 286               	__vector_21:
 287               		.stabd	46,0,0
  56:buttons.c     **** SIGNAL(ADC_vect) {
 289               	.LM20:
 290               	.LFBB4:
 291 00a0 1F92      		push __zero_reg__
 292 00a2 0F92      		push r0
 293 00a4 0FB6      		in r0,__SREG__
 294 00a6 0F92      		push r0
 295 00a8 1124      		clr __zero_reg__
 296 00aa 2F93      		push r18
 297 00ac 3F93      		push r19
 298 00ae 4F93      		push r20
 299 00b0 5F93      		push r21
 300 00b2 6F93      		push r22
 301 00b4 7F93      		push r23
 302 00b6 8F93      		push r24
 303 00b8 9F93      		push r25
 304 00ba AF93      		push r26
 305 00bc BF93      		push r27
 306 00be EF93      		push r30
 307 00c0 FF93      		push r31
 308               	/* prologue: Signal */
 309               	/* frame size = 0 */
  58:buttons.c     ****   sei();
 311               	.LM21:
 312               	/* #APP */
 313               	 ;  58 "buttons.c" 1
 314 00c2 7894      		sei
 315               	 ;  0 "" 2
  61:buttons.c     ****   reading = ADC;
 317               	.LM22:
 318               	/* #NOAPP */
 319 00c4 8091 7800 		lds r24,120
 320 00c8 9091 7900 		lds r25,(120)+1
  63:buttons.c     ****   if (reading > 735) {
 322               	.LM23:
 323 00cc 22E0      		ldi r18,hi8(736)
 324 00ce 803E      		cpi r24,lo8(736)
 325 00d0 9207      		cpc r25,r18
 326 00d2 00F0      		brlo .L10
  65:buttons.c     ****     pressed = 0;
 328               	.LM24:
 329 00d4 1092 0000 		sts pressed,__zero_reg__
  66:buttons.c     ****     last_buttonstate = 0;
 331               	.LM25:
 332 00d8 1092 0000 		sts last_buttonstate,__zero_reg__
 333 00dc 00C0      		rjmp .L17
 334               	.L10:
  70:buttons.c     ****   } else if (reading > 610) {
 336               	.LM26:
 337 00de 22E0      		ldi r18,hi8(611)
 338 00e0 8336      		cpi r24,lo8(611)
 339 00e2 9207      		cpc r25,r18
 340 00e4 00F0      		brlo .L12
  72:buttons.c     ****     if (!last_buttonstate) { // was not pressed before
 342               	.LM27:
 343 00e6 8091 0000 		lds r24,last_buttonstate
 344 00ea 8823      		tst r24
 345 00ec 01F4      		brne .L13
  74:buttons.c     ****       delay_ms(10);
 347               	.LM28:
 348 00ee 8AE0      		ldi r24,lo8(10)
 349 00f0 90E0      		ldi r25,hi8(10)
 350 00f2 0E94 0000 		call delay_ms
 351               	.LBB8:
 352               	.LBB9:
  48:buttons.c     ****   ADCSRA &= ~_BV(ADIE); // no interrupt
 354               	.LM29:
 355 00f6 8091 7A00 		lds r24,122
 356 00fa 877F      		andi r24,lo8(-9)
 357 00fc 8093 7A00 		sts 122,r24
  49:buttons.c     ****   ADCSRA |= _BV(ADSC); // start a conversion
 359               	.LM30:
 360 0100 8091 7A00 		lds r24,122
 361 0104 8064      		ori r24,lo8(64)
 362 0106 8093 7A00 		sts 122,r24
 363               	.L14:
  50:buttons.c     ****   while (! (ADCSRA & _BV(ADIF)));
 365               	.LM31:
 366 010a 8091 7A00 		lds r24,122
 367 010e 84FF      		sbrs r24,4
 368 0110 00C0      		rjmp .L14
  51:buttons.c     ****   return ADC;
 370               	.LM32:
 371 0112 8091 7800 		lds r24,120
 372 0116 9091 7900 		lds r25,(120)+1
 373               	.LBE9:
 374               	.LBE8:
  76:buttons.c     ****       if ( (reading2 > 735) || (reading2 < 610)) {
 376               	.LM33:
 377 011a 8256      		subi r24,lo8(-(-610))
 378 011c 9240      		sbci r25,hi8(-(-610))
 379 011e 8E37      		cpi r24,126
 380 0120 9105      		cpc r25,__zero_reg__
 381 0122 00F0      		brlo .+2
 382 0124 00C0      		rjmp .L17
 383               	.L15:
  81:buttons.c     ****       buttonholdcounter = 2;
 385               	.LM34:
 386 0126 82E0      		ldi r24,lo8(2)
 387 0128 8093 0000 		sts buttonholdcounter,r24
  82:buttons.c     ****       last_buttonstate = 0x4;
 389               	.LM35:
 390 012c 84E0      		ldi r24,lo8(4)
 391 012e 8093 0000 		sts last_buttonstate,r24
  83:buttons.c     ****       just_pressed = 0x4;
 393               	.LM36:
 394 0132 8093 0000 		sts just_pressed,r24
 395 0136 00C0      		rjmp .L17
 396               	.L13:
  89:buttons.c     ****       if (buttonholdcounter) {
 398               	.LM37:
 399 0138 8091 0000 		lds r24,buttonholdcounter
 400 013c 8823      		tst r24
 401 013e 01F0      		breq .+2
 402 0140 00C0      		rjmp .L17
 403               	.L16:
  94:buttons.c     ****       pressed = 0x4;                 // The button was held down (fast advance)
 405               	.LM38:
 406 0142 84E0      		ldi r24,lo8(4)
 407 0144 00C0      		rjmp .L27
 408               	.L12:
  97:buttons.c     ****   } else if (reading > 270) {
 410               	.LM39:
 411 0146 8F50      		subi r24,lo8(271)
 412 0148 9140      		sbci r25,hi8(271)
 413 014a 00F0      		brlo .L18
  99:buttons.c     ****     if (!last_buttonstate) { // was not pressed before
 415               	.LM40:
 416 014c 8091 0000 		lds r24,last_buttonstate
 417 0150 8823      		tst r24
 418 0152 01F0      		breq .+2
 419 0154 00C0      		rjmp .L17
 101:buttons.c     ****       delay_ms(10);
 421               	.LM41:
 422 0156 8AE0      		ldi r24,lo8(10)
 423 0158 90E0      		ldi r25,hi8(10)
 424 015a 0E94 0000 		call delay_ms
 425               	.LBB10:
 426               	.LBB11:
  48:buttons.c     ****   ADCSRA &= ~_BV(ADIE); // no interrupt
 428               	.LM42:
 429 015e 8091 7A00 		lds r24,122
 430 0162 877F      		andi r24,lo8(-9)
 431 0164 8093 7A00 		sts 122,r24
  49:buttons.c     ****   ADCSRA |= _BV(ADSC); // start a conversion
 433               	.LM43:
 434 0168 8091 7A00 		lds r24,122
 435 016c 8064      		ori r24,lo8(64)
 436 016e 8093 7A00 		sts 122,r24
 437               	.L19:
  50:buttons.c     ****   while (! (ADCSRA & _BV(ADIF)));
 439               	.LM44:
 440 0172 8091 7A00 		lds r24,122
 441 0176 84FF      		sbrs r24,4
 442 0178 00C0      		rjmp .L19
  51:buttons.c     ****   return ADC;
 444               	.LM45:
 445 017a 8091 7800 		lds r24,120
 446 017e 9091 7900 		lds r25,(120)+1
 447               	.LBE11:
 448               	.LBE10:
 103:buttons.c     ****       if ( (reading2 > 610) || (reading2 < 270)) {
 450               	.LM46:
 451 0182 8E50      		subi r24,lo8(-(-270))
 452 0184 9140      		sbci r25,hi8(-(-270))
 453 0186 8555      		subi r24,lo8(341)
 454 0188 9140      		sbci r25,hi8(341)
 455 018a 00F4      		brsh .L17
 456               	.L20:
 109:buttons.c     ****       just_pressed = 0x2;
 458               	.LM47:
 459 018c 82E0      		ldi r24,lo8(2)
 460 018e 00C0      		rjmp .L28
 461               	.L18:
 115:buttons.c     ****     if (!last_buttonstate) { // was not pressed before
 463               	.LM48:
 464 0190 8091 0000 		lds r24,last_buttonstate
 465 0194 8823      		tst r24
 466 0196 01F4      		brne .L17
 117:buttons.c     ****       delay_ms(10);
 468               	.LM49:
 469 0198 8AE0      		ldi r24,lo8(10)
 470 019a 90E0      		ldi r25,hi8(10)
 471 019c 0E94 0000 		call delay_ms
 472               	.LBB12:
 473               	.LBB13:
  48:buttons.c     ****   ADCSRA &= ~_BV(ADIE); // no interrupt
 475               	.LM50:
 476 01a0 8091 7A00 		lds r24,122
 477 01a4 877F      		andi r24,lo8(-9)
 478 01a6 8093 7A00 		sts 122,r24
  49:buttons.c     ****   ADCSRA |= _BV(ADSC); // start a conversion
 480               	.LM51:
 481 01aa 8091 7A00 		lds r24,122
 482 01ae 8064      		ori r24,lo8(64)
 483 01b0 8093 7A00 		sts 122,r24
 484               	.L21:
  50:buttons.c     ****   while (! (ADCSRA & _BV(ADIF)));
 486               	.LM52:
 487 01b4 8091 7A00 		lds r24,122
 488 01b8 84FF      		sbrs r24,4
 489 01ba 00C0      		rjmp .L21
  51:buttons.c     ****   return ADC;
 491               	.LM53:
 492 01bc 8091 7800 		lds r24,120
 493 01c0 9091 7900 		lds r25,(120)+1
 494               	.LBE13:
 495               	.LBE12:
 119:buttons.c     ****       if (reading2 > 270) {
 497               	.LM54:
 498 01c4 8F50      		subi r24,lo8(271)
 499 01c6 9140      		sbci r25,hi8(271)
 500 01c8 00F4      		brsh .L17
 501               	.L22:
 125:buttons.c     ****       just_pressed = 0x1;
 503               	.LM55:
 504 01ca 81E0      		ldi r24,lo8(1)
 505               	.L28:
 506 01cc 8093 0000 		sts just_pressed,r24
 126:buttons.c     ****       last_buttonstate = 0x1;
 508               	.LM56:
 509 01d0 8093 0000 		sts last_buttonstate,r24
 510               	.L27:
 127:buttons.c     ****       pressed = 0x1;                 // held down
 512               	.LM57:
 513 01d4 8093 0000 		sts pressed,r24
 514               	.L17:
 130:buttons.c     ****   ADCSRA |= _BV(ADIE) | _BV(ADSC); // start next conversion  
 516               	.LM58:
 517 01d8 8091 7A00 		lds r24,122
 518 01dc 8864      		ori r24,lo8(72)
 519 01de 8093 7A00 		sts 122,r24
 520               	/* epilogue start */
 131:buttons.c     **** }
 522               	.LM59:
 523 01e2 FF91      		pop r31
 524 01e4 EF91      		pop r30
 525 01e6 BF91      		pop r27
 526 01e8 AF91      		pop r26
 527 01ea 9F91      		pop r25
 528 01ec 8F91      		pop r24
 529 01ee 7F91      		pop r23
 530 01f0 6F91      		pop r22
 531 01f2 5F91      		pop r21
 532 01f4 4F91      		pop r20
 533 01f6 3F91      		pop r19
 534 01f8 2F91      		pop r18
 535 01fa 0F90      		pop r0
 536 01fc 0FBE      		out __SREG__,r0
 537 01fe 0F90      		pop r0
 538 0200 1F90      		pop __zero_reg__
 539 0202 1895      		reti
 545               	.Lscope4:
 547               		.stabd	78,0,0
 548               	.global	last_buttonstate
 549               	.global	last_buttonstate
 550               		.section .bss
 553               	last_buttonstate:
 554 0000 00        		.skip 1,0
 555               	.global	debounce
 556               	.global	debounce
 559               	debounce:
 560 0001 00        		.skip 1,0
 561               	.global	just_pressed
 562               	.global	just_pressed
 565               	just_pressed:
 566 0002 00        		.skip 1,0
 567               	.global	pressed
 568               	.global	pressed
 571               	pressed:
 572 0003 00        		.skip 1,0
 573               	.global	buttonholdcounter
 574               	.global	buttonholdcounter
 577               	buttonholdcounter:
 578 0004 00        		.skip 1,0
 584               		.text
 586               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 buttons.c
     /tmp/ccxph9x4.s:2      *ABS*:0000003f __SREG__
     /tmp/ccxph9x4.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccxph9x4.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccxph9x4.s:5      *ABS*:00000034 __CCP__
     /tmp/ccxph9x4.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccxph9x4.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccxph9x4.s:133    .text:00000000 initbuttons
     /tmp/ccxph9x4.s:186    .text:0000002e readADC
     /tmp/ccxph9x4.s:225    .text:00000056 __vector_3
     /tmp/ccxph9x4.s:286    .text:000000a0 __vector_21
     /tmp/ccxph9x4.s:571    .bss:00000003 pressed
     /tmp/ccxph9x4.s:553    .bss:00000000 last_buttonstate
     /tmp/ccxph9x4.s:577    .bss:00000004 buttonholdcounter
     /tmp/ccxph9x4.s:565    .bss:00000002 just_pressed
     /tmp/ccxph9x4.s:559    .bss:00000001 debounce

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
setalarmstate
delay_ms
