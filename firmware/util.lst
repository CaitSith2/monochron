   1               		.file	"util.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  12               		.text
  13               	.Ltext0:
 137               	.global	uart_init
 139               	uart_init:
 140               		.stabd	46,0,0
   0:util.c        **** #include <avr/io.h>
   1:util.c        **** #include <avr/interrupt.h>
   2:util.c        **** #include <util/delay.h>
   3:util.c        **** #include <avr/pgmspace.h>
   4:util.c        **** #include <avr/eeprom.h>
   5:util.c        **** #include <avr/wdt.h>
   6:util.c        **** #include <stdlib.h>
   7:util.c        **** #include "ratt.h"
   8:util.c        **** #include "util.h"
   9:util.c        **** #include "ks0108.h"
  10:util.c        **** #include "glcd.h"
  11:util.c        **** 
  12:util.c        **** extern volatile uint8_t time_format;
  13:util.c        **** extern volatile uint8_t displaystyle;
  14:util.c        **** extern volatile uint8_t timeoutcounter;
  15:util.c        **** extern volatile uint8_t screenmutex;
  16:util.c        **** extern volatile uint8_t displaymode;
  17:util.c        **** extern volatile uint8_t last_buttonstate, just_pressed, pressed;
  18:util.c        **** 
  19:util.c        **** 
  20:util.c        **** // Creates a 8N1 UART connect
  21:util.c        **** // remember that the BBR is #defined for each F_CPU in util.h
  22:util.c        **** void uart_init(uint16_t BRR) {
 142               	.LM0:
 143               	.LFBB1:
 144               	/* prologue: function */
 145               	/* frame size = 0 */
  23:util.c        ****   UBRR0 = BRR;               // set baudrate counter
 147               	.LM1:
 148 0000 9093 C500 		sts (196)+1,r25
 149 0004 8093 C400 		sts 196,r24
  24:util.c        **** 
  25:util.c        ****   UCSR0B = _BV(RXEN0) | _BV(TXEN0);
 151               	.LM2:
 152 0008 88E1      		ldi r24,lo8(24)
 153 000a 8093 C100 		sts 193,r24
  26:util.c        ****   UCSR0C = _BV(USBS0) | (3<<UCSZ00);
 155               	.LM3:
 156 000e 8EE0      		ldi r24,lo8(14)
 157 0010 8093 C200 		sts 194,r24
  27:util.c        ****   DDRD |= _BV(1);
 159               	.LM4:
 160 0014 519A      		sbi 42-32,1
  28:util.c        ****   DDRD &= ~_BV(0);
 162               	.LM5:
 163 0016 5098      		cbi 42-32,0
 164               	/* epilogue start */
  29:util.c        **** }
 166               	.LM6:
 167 0018 0895      		ret
 169               	.Lscope1:
 171               		.stabd	78,0,0
 174               	.global	delay_10us
 176               	delay_10us:
 177               		.stabd	46,0,0
  30:util.c        **** 
  31:util.c        **** // Some basic delays...
  32:util.c        **** void delay_10us(uint8_t ns)
  33:util.c        **** {
 179               	.LM7:
 180               	.LFBB2:
 181               	/* prologue: function */
 182               	/* frame size = 0 */
 183 001a 00C0      		rjmp .L4
 184               	.L6:
  34:util.c        ****   uint8_t i;
  35:util.c        **** 
  36:util.c        ****   while (ns != 0) {
 186               	.LM8:
 187 001c 90E0      		ldi r25,lo8(0)
 188               	.L5:
  37:util.c        ****     ns--;
  38:util.c        ****     for (i=0; i< 30; i++) {
  39:util.c        ****       nop;
 190               	.LM9:
 191               	/* #APP */
 192               	 ;  40 "util.c" 1
 193 001e 0000      		nop
 194               		
 195               	 ;  0 "" 2
  39:util.c        ****       nop;
 197               	.LM10:
 198               	/* #NOAPP */
 199 0020 9F5F      		subi r25,lo8(-(1))
 200 0022 9E31      		cpi r25,lo8(30)
 201 0024 01F4      		brne .L5
  38:util.c        ****     ns--;
 203               	.LM11:
 204 0026 8150      		subi r24,lo8(-(-1))
 205               	.L4:
  37:util.c        ****     ns--;
 207               	.LM12:
 208 0028 8823      		tst r24
 209 002a 01F4      		brne .L6
 210               	/* epilogue start */
  40:util.c        ****     }
  41:util.c        ****   }
  42:util.c        **** }
 212               	.LM13:
 213 002c 0895      		ret
 218               	.Lscope2:
 220               		.stabd	78,0,0
 222               	.global	delay_ms
 224               	delay_ms:
 225               		.stabd	46,0,0
  43:util.c        **** 
  44:util.c        **** void delay_ms(uint16_t ms)
  45:util.c        **** {
 227               	.LM14:
 228               	.LFBB3:
 229               	/* prologue: function */
 230               	/* frame size = 0 */
 231               	.LBB48:
 232               	.LBB49:
 233               	.LBB50:
 234               	.LBB51:
 236               	.Ltext1:
   0:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   1:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   2:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    All rights reserved.
   3:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
   4:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
   7:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  10:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      distribution.
  14:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  15:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  18:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  19:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  30:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  31:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  32:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  33:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  34:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  35:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  36:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  37:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  38:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \file */
  39:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  40:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     \code
  41:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  42:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     \endcode
  43:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  44:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  45:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  46:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  47:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  48:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  49:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  50:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  51:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  52:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  53:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  54:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  55:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  56:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  57:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  58:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  59:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  60:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  61:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** */
  62:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  63:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  64:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  65:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  66:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #endif
  67:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  68:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  69:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  70:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  71:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  72:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  73:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  74:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     register.
  75:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  76:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  77:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     can be achieved.
  78:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** */
  79:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** void
  80:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  81:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** {
  82:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  83:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  84:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  85:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  86:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  87:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 	);
  88:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** }
  89:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  90:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  91:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  92:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  93:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  94:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  95:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  96:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     counter register pair.
  97:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  98:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
  99:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 100:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****  */
 101:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** void
 102:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 103:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** {
 104:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 238               	.LM15:
 239 002e 20E2      		ldi r18,lo8(20000)
 240 0030 3EE4      		ldi r19,hi8(20000)
 241 0032 00C0      		rjmp .L10
 242               	.L12:
 243 0034 F901      		movw r30,r18
 244               	/* #APP */
 245               	 ;  105 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h" 1
 246 0036 3197      		1: sbiw r30,1
 247 0038 01F4      		brne 1b
 248               	 ;  0 "" 2
 249               	/* #NOAPP */
 250               	.LBE51:
 251               	.LBE50:
 252               	.LBE49:
 253               	.LBE48:
 255               	.Ltext2:
  46:util.c        **** 	uint16_t temp = ms;
  47:util.c        **** 	while(temp)
  48:util.c        **** 	{
  49:util.c        **** 		_delay_ms(10);
  50:util.c        **** 		if(temp >= 10)
 257               	.LM16:
 258 003a 8A30      		cpi r24,10
 259 003c 9105      		cpc r25,__zero_reg__
 260 003e 00F0      		brlo .L13
  51:util.c        **** 			temp-=10;
 262               	.LM17:
 263 0040 0A97      		sbiw r24,10
 264               	.L10:
  48:util.c        **** 	while(temp)
 266               	.LM18:
 267 0042 0097      		sbiw r24,0
 268 0044 01F4      		brne .L12
 269               	.L13:
 270 0046 0895      		ret
 275               	.Lscope3:
 277               		.stabd	78,0,0
 280               	.global	delay_s
 282               	delay_s:
 283               		.stabd	46,0,0
  52:util.c        **** 		else
  53:util.c        **** 			temp=0;
  54:util.c        **** 	}
  55:util.c        **** }
  56:util.c        **** 
  57:util.c        **** void delay_s(uint8_t s) {
 285               	.LM19:
 286               	.LFBB4:
 287               	/* prologue: function */
 288               	/* frame size = 0 */
 289               	.LBB52:
 290               	.LBB53:
 291               	.LBB54:
 292               	.LBB55:
 293               	.LBB56:
 294               	.LBB57:
 296               	.Ltext3:
 298               	.LM20:
 299 0048 40E2      		ldi r20,lo8(20000)
 300 004a 5EE4      		ldi r21,hi8(20000)
 301 004c 00C0      		rjmp .L15
 302               	.L18:
 303               	.LBE57:
 304               	.LBE56:
 305               	.LBE55:
 306               	.LBE54:
 307               	.LBE53:
 308               	.LBE52:
 310               	.Ltext4:
  58:util.c        ****   while (s--) {
 312               	.LM21:
 313 004e 28EE      		ldi r18,lo8(1000)
 314 0050 33E0      		ldi r19,hi8(1000)
 315               	.L17:
 316               	.LBB63:
 317               	.LBB62:
 318               	.LBB61:
 319               	.LBB60:
 320               	.LBB59:
 321               	.LBB58:
 323               	.Ltext5:
 325               	.LM22:
 326 0052 FA01      		movw r30,r20
 327               	/* #APP */
 328               	 ;  105 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h" 1
 329 0054 3197      		1: sbiw r30,1
 330 0056 01F4      		brne 1b
 331               	 ;  0 "" 2
 332               	/* #NOAPP */
 333               	.LBE58:
 334               	.LBE59:
 335               	.LBE60:
 336               	.LBE61:
 338               	.Ltext6:
  51:util.c        **** 		if(temp >= 10)
 340               	.LM23:
 341 0058 2A30      		cpi r18,10
 342 005a 3105      		cpc r19,__zero_reg__
 343 005c 00F0      		brlo .L16
  52:util.c        **** 		else
 345               	.LM24:
 346 005e 2A50      		subi r18,lo8(-(-10))
 347 0060 3040      		sbci r19,hi8(-(-10))
  48:util.c        **** 	while(temp)
 349               	.LM25:
 350 0062 01F4      		brne .L17
 351               	.L16:
 352 0064 8150      		subi r24,lo8(-(-1))
 353               	.L15:
 354               	.LBE62:
 355               	.LBE63:
 357               	.LM26:
 358 0066 8823      		tst r24
 359 0068 01F4      		brne .L18
 360               	/* epilogue start */
  59:util.c        ****     delay_ms(1000);
  60:util.c        ****   }
  61:util.c        **** }
 362               	.LM27:
 363 006a 0895      		ret
 371               	.Lscope4:
 373               		.stabd	78,0,0
 376               	.global	uart_putchar
 378               	uart_putchar:
 379               		.stabd	46,0,0
  62:util.c        **** 
  63:util.c        **** // Some uart functions for debugging help
  64:util.c        **** int uart_putchar(char c)
  65:util.c        **** {
 381               	.LM28:
 382               	.LFBB5:
 383               	/* prologue: function */
 384               	/* frame size = 0 */
 385 006c 982F      		mov r25,r24
 386               	.L22:
  66:util.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
 388               	.LM29:
 389 006e 8091 C000 		lds r24,192
 390 0072 85FF      		sbrs r24,5
 391 0074 00C0      		rjmp .L22
  67:util.c        ****   UDR0 = c;
 393               	.LM30:
 394 0076 9093 C600 		sts 198,r25
  68:util.c        ****   return 0;
  69:util.c        **** }
 396               	.LM31:
 397 007a 80E0      		ldi r24,lo8(0)
 398 007c 90E0      		ldi r25,hi8(0)
 399               	/* epilogue start */
 400 007e 0895      		ret
 402               	.Lscope5:
 404               		.stabd	78,0,0
 406               	.global	uart_getchar
 408               	uart_getchar:
 409               		.stabd	46,0,0
  70:util.c        **** 
  71:util.c        **** char uart_getchar(void) {
 411               	.LM32:
 412               	.LFBB6:
 413               	/* prologue: function */
 414               	/* frame size = 0 */
 415               	.L26:
  72:util.c        ****   while (!(UCSR0A & _BV(RXC0)));
 417               	.LM33:
 418 0080 8091 C000 		lds r24,192
 419 0084 87FF      		sbrs r24,7
 420 0086 00C0      		rjmp .L26
  73:util.c        ****   return UDR0;
 422               	.LM34:
 423 0088 8091 C600 		lds r24,198
 424               	/* epilogue start */
  74:util.c        **** }
 426               	.LM35:
 427 008c 0895      		ret
 429               	.Lscope6:
 431               		.stabd	78,0,0
 433               	.global	uart_getch
 435               	uart_getch:
 436               		.stabd	46,0,0
  75:util.c        **** 
  76:util.c        **** char uart_getch(void) {
 438               	.LM36:
 439               	.LFBB7:
 440               	/* prologue: function */
 441               	/* frame size = 0 */
  77:util.c        ****   return (UCSR0A & _BV(RXC0));
 443               	.LM37:
 444 008e 8091 C000 		lds r24,192
  78:util.c        **** }
 446               	.LM38:
 447 0092 8078      		andi r24,lo8(-128)
 448               	/* epilogue start */
 449 0094 0895      		ret
 451               	.Lscope7:
 453               		.stabd	78,0,0
 457               	.global	ROM_putstring
 459               	ROM_putstring:
 460               		.stabd	46,0,0
  79:util.c        **** 
  80:util.c        **** void ROM_putstring(const char *str, uint8_t nl) {
 462               	.LM39:
 463               	.LFBB8:
 464               	/* prologue: function */
 465               	/* frame size = 0 */
 466 0096 AC01      		movw r20,r24
 468               	.LM40:
 469 0098 20E0      		ldi r18,lo8(0)
 470 009a 00C0      		rjmp .L32
 471               	.L40:
 472               	.LBB64:
 473               	.LBB65:
  67:util.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
 475               	.LM41:
 476 009c 8091 C000 		lds r24,192
 477 00a0 85FF      		sbrs r24,5
 478 00a2 00C0      		rjmp .L40
  68:util.c        ****   UDR0 = c;
 480               	.LM42:
 481 00a4 3093 C600 		sts 198,r19
 482               	.LBE65:
 483               	.LBE64:
  81:util.c        ****   uint8_t i;
  82:util.c        **** 
  83:util.c        ****   for (i=0; pgm_read_byte(&str[i]); i++) {
 485               	.LM43:
 486 00a8 2F5F      		subi r18,lo8(-(1))
 487               	.L32:
 488               	.LBB66:
 489 00aa FA01      		movw r30,r20
 490 00ac E20F      		add r30,r18
 491 00ae F11D      		adc r31,__zero_reg__
 492               	/* #APP */
 493               	 ;  84 "util.c" 1
 494 00b0 3491      		lpm r19, Z
 495               		
 496               	 ;  0 "" 2
 497               	/* #NOAPP */
 498               	.LBE66:
 499 00b2 3323      		tst r19
 500 00b4 01F4      		brne .L40
  84:util.c        ****     uart_putchar(pgm_read_byte(&str[i]));
  85:util.c        ****   }
  86:util.c        ****   if (nl) {
 502               	.LM44:
 503 00b6 6623      		tst r22
 504 00b8 01F0      		breq .L38
 505               	.L39:
 506               	.LBB67:
 507               	.LBB68:
  67:util.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
 509               	.LM45:
 510 00ba 8091 C000 		lds r24,192
 511 00be 85FF      		sbrs r24,5
 512 00c0 00C0      		rjmp .L39
  68:util.c        ****   UDR0 = c;
 514               	.LM46:
 515 00c2 8AE0      		ldi r24,lo8(10)
 516 00c4 8093 C600 		sts 198,r24
 517               	.L37:
 518               	.LBE68:
 519               	.LBE67:
 520               	.LBB69:
 521               	.LBB70:
  67:util.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
 523               	.LM47:
 524 00c8 8091 C000 		lds r24,192
 525 00cc 85FF      		sbrs r24,5
 526 00ce 00C0      		rjmp .L37
  68:util.c        ****   UDR0 = c;
 528               	.LM48:
 529 00d0 8DE0      		ldi r24,lo8(13)
 530 00d2 8093 C600 		sts 198,r24
 531               	.L38:
 532 00d6 0895      		ret
 533               	.LBE70:
 534               	.LBE69:
 543               	.Lscope8:
 545               		.stabd	78,0,0
 548               	.global	uart_puts
 550               	uart_puts:
 551               		.stabd	46,0,0
  87:util.c        ****     uart_putchar('\n'); uart_putchar('\r');
  88:util.c        ****   }
  89:util.c        **** }
  90:util.c        **** 
  91:util.c        **** void uart_puts(const char* str)
  92:util.c        **** {
 553               	.LM49:
 554               	.LFBB9:
 555               	/* prologue: function */
 556               	/* frame size = 0 */
 557 00d8 FC01      		movw r30,r24
 558 00da 00C0      		rjmp .L45
 559               	.L48:
 560               	.LBB71:
 561               	.LBB72:
  67:util.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
 563               	.LM50:
 564 00dc 8091 C000 		lds r24,192
 565 00e0 85FF      		sbrs r24,5
 566 00e2 00C0      		rjmp .L48
 567               	.LBE72:
 568               	.LBE71:
  93:util.c        ****   while(*str)
  94:util.c        ****     uart_putc(*str++);
 570               	.LM51:
 571 00e4 3196      		adiw r30,1
 572               	.LBB74:
 573               	.LBB73:
  68:util.c        ****   UDR0 = c;
 575               	.LM52:
 576 00e6 9093 C600 		sts 198,r25
 577               	.L45:
 578               	.LBE73:
 579               	.LBE74:
  94:util.c        ****   while(*str)
 581               	.LM53:
 582 00ea 9081      		ld r25,Z
 583 00ec 9923      		tst r25
 584 00ee 01F4      		brne .L48
 585               	/* epilogue start */
  95:util.c        **** }
 587               	.LM54:
 588 00f0 0895      		ret
 590               	.Lscope9:
 592               		.stabd	78,0,0
 595               	.global	uart_putc_hex
 597               	uart_putc_hex:
 598               		.stabd	46,0,0
  96:util.c        **** 
  97:util.c        **** 
  98:util.c        **** void uart_putc_hex(uint8_t b)
  99:util.c        **** {
 600               	.LM55:
 601               	.LFBB10:
 602               	/* prologue: function */
 603               	/* frame size = 0 */
 604 00f2 282F      		mov r18,r24
 100:util.c        ****   /* upper nibble */
 101:util.c        ****   if((b >> 4) < 0x0a)
 606               	.LM56:
 607 00f4 982F      		mov r25,r24
 608 00f6 9295      		swap r25
 609 00f8 9F70      		andi r25,0x0f
 610 00fa 9A30      		cpi r25,lo8(10)
 611 00fc 00F4      		brsh .L61
 612               	.L60:
 613               	.LBB75:
 614               	.LBB76:
  67:util.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
 616               	.LM57:
 617 00fe 8091 C000 		lds r24,192
 618 0102 85FF      		sbrs r24,5
 619 0104 00C0      		rjmp .L60
 620               	.LBE76:
 621               	.LBE75:
 102:util.c        ****     uart_putc((b >> 4) + '0');
 623               	.LM58:
 624 0106 905D      		subi r25,lo8(-(48))
 625 0108 00C0      		rjmp .L66
 626               	.L61:
 627               	.LBB77:
 628               	.LBB78:
  67:util.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
 630               	.LM59:
 631 010a 8091 C000 		lds r24,192
 632 010e 85FF      		sbrs r24,5
 633 0110 00C0      		rjmp .L61
 634               	.LBE78:
 635               	.LBE77:
 103:util.c        ****   else
 104:util.c        ****     uart_putc((b >> 4) - 0x0a + 'a');
 637               	.LM60:
 638 0112 995A      		subi r25,lo8(-(87))
 639               	.L66:
 640               	.LBB80:
 641               	.LBB79:
  68:util.c        ****   UDR0 = c;
 643               	.LM61:
 644 0114 9093 C600 		sts 198,r25
 645               	.LBE79:
 646               	.LBE80:
 105:util.c        **** 
 106:util.c        ****   /* lower nibble */
 107:util.c        ****   if((b & 0x0f) < 0x0a)
 648               	.LM62:
 649 0118 822F      		mov r24,r18
 650 011a 90E0      		ldi r25,lo8(0)
 651 011c 8F70      		andi r24,lo8(15)
 652 011e 9070      		andi r25,hi8(15)
 653 0120 0A97      		sbiw r24,10
 654 0122 04F4      		brge .L59
 655               	.L58:
 656               	.LBB81:
 657               	.LBB82:
  67:util.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
 659               	.LM63:
 660 0124 8091 C000 		lds r24,192
 661 0128 85FF      		sbrs r24,5
 662 012a 00C0      		rjmp .L58
 663               	.LBE82:
 664               	.LBE81:
 108:util.c        ****     uart_putc((b & 0x0f) + '0');
 666               	.LM64:
 667 012c 2F70      		andi r18,lo8(15)
 668 012e 205D      		subi r18,lo8(-(48))
 669 0130 00C0      		rjmp .L67
 670               	.L59:
 671               	.LBB83:
 672               	.LBB84:
  67:util.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
 674               	.LM65:
 675 0132 8091 C000 		lds r24,192
 676 0136 85FF      		sbrs r24,5
 677 0138 00C0      		rjmp .L59
 678               	.LBE84:
 679               	.LBE83:
 109:util.c        ****   else
 110:util.c        ****     uart_putc((b & 0x0f) - 0x0a + 'a');
 681               	.LM66:
 682 013a 2F70      		andi r18,lo8(15)
 683 013c 295A      		subi r18,lo8(-(87))
 684               	.L67:
 685               	.LBB86:
 686               	.LBB85:
  68:util.c        ****   UDR0 = c;
 688               	.LM67:
 689 013e 2093 C600 		sts 198,r18
 690 0142 0895      		ret
 691               	.LBE85:
 692               	.LBE86:
 694               	.Lscope10:
 696               		.stabd	78,0,0
 698               	.global	uart_putw_hex
 700               	uart_putw_hex:
 701               		.stabd	46,0,0
 111:util.c        **** }
 112:util.c        **** 
 113:util.c        **** void uart_putw_hex(uint16_t w)
 114:util.c        **** {
 703               	.LM68:
 704               	.LFBB11:
 705 0144 1F93      		push r17
 706               	/* prologue: function */
 707               	/* frame size = 0 */
 708 0146 182F      		mov r17,r24
 115:util.c        ****   uart_putc_hex((uint8_t) (w >> 8));
 710               	.LM69:
 711 0148 892F      		mov r24,r25
 712 014a 0E94 0000 		call uart_putc_hex
 116:util.c        ****   uart_putc_hex((uint8_t) (w & 0xff));
 714               	.LM70:
 715 014e 812F      		mov r24,r17
 716 0150 0E94 0000 		call uart_putc_hex
 717               	/* epilogue start */
 117:util.c        **** }
 719               	.LM71:
 720 0154 1F91      		pop r17
 721 0156 0895      		ret
 723               	.Lscope11:
 725               		.stabd	78,0,0
 728               	.global	uart_putdw_hex
 730               	uart_putdw_hex:
 731               		.stabd	46,0,0
 118:util.c        **** 
 119:util.c        **** void uart_putdw_hex(uint32_t dw)
 120:util.c        **** {
 733               	.LM72:
 734               	.LFBB12:
 735 0158 EF92      		push r14
 736 015a FF92      		push r15
 737 015c 0F93      		push r16
 738 015e 1F93      		push r17
 739               	/* prologue: function */
 740               	/* frame size = 0 */
 741 0160 7B01      		movw r14,r22
 742 0162 8C01      		movw r16,r24
 121:util.c        ****   uart_putw_hex((uint16_t) (dw >> 16));
 744               	.LM73:
 745 0164 C801      		movw r24,r16
 746 0166 AA27      		clr r26
 747 0168 BB27      		clr r27
 748 016a 0E94 0000 		call uart_putw_hex
 122:util.c        ****   uart_putw_hex((uint16_t) (dw & 0xffff));
 750               	.LM74:
 751 016e C701      		movw r24,r14
 752 0170 0E94 0000 		call uart_putw_hex
 753               	/* epilogue start */
 123:util.c        **** }
 755               	.LM75:
 756 0174 1F91      		pop r17
 757 0176 0F91      		pop r16
 758 0178 FF90      		pop r15
 759 017a EF90      		pop r14
 760 017c 0895      		ret
 762               	.Lscope12:
 764               		.stabd	78,0,0
 767               	.global	uart_putw_dec
 769               	uart_putw_dec:
 770               		.stabd	46,0,0
 124:util.c        **** 
 125:util.c        **** void uart_putw_dec(uint16_t w)
 126:util.c        **** {
 772               	.LM76:
 773               	.LFBB13:
 774 017e 0F93      		push r16
 775 0180 1F93      		push r17
 776 0182 CF93      		push r28
 777 0184 DF93      		push r29
 778               	/* prologue: function */
 779               	/* frame size = 0 */
 780 0186 8C01      		movw r16,r24
 782               	.LM77:
 783 0188 E0E1      		ldi r30,lo8(10000)
 784 018a F7E2      		ldi r31,hi8(10000)
 785 018c 40E0      		ldi r20,lo8(0)
 786 018e C0E0      		ldi r28,lo8(0)
 787 0190 D0E0      		ldi r29,hi8(0)
 788               	.L76:
 789               	.LBB87:
 127:util.c        ****   uint16_t num = 10000;
 128:util.c        ****   uint8_t started = 0;
 129:util.c        **** 
 130:util.c        ****   while(num > 0)
 131:util.c        ****     {
 132:util.c        ****       uint8_t b = w / num;
 791               	.LM78:
 792 0192 C801      		movw r24,r16
 793 0194 BF01      		movw r22,r30
 794 0196 0E94 0000 		call __udivmodhi4
 795 019a 262F      		mov r18,r22
 133:util.c        ****       if(b > 0 || started || num == 1)
 797               	.LM79:
 798 019c 6623      		tst r22
 799 019e 01F4      		brne .L78
 800 01a0 4423      		tst r20
 801 01a2 01F4      		brne .L78
 802 01a4 E130      		cpi r30,1
 803 01a6 F105      		cpc r31,__zero_reg__
 804 01a8 01F4      		brne .L74
 805               	.L78:
 806               	.LBB89:
 807               	.LBB90:
  67:util.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
 809               	.LM80:
 810 01aa 8091 C000 		lds r24,192
 811 01ae 85FF      		sbrs r24,5
 812 01b0 00C0      		rjmp .L78
 813               	.LBE90:
 814               	.LBE89:
 134:util.c        **** 	{
 135:util.c        **** 	  uart_putc('0' + b);
 816               	.LM81:
 817 01b2 205D      		subi r18,lo8(-(48))
 818               	.LBB88:
 819               	.LBB91:
  68:util.c        ****   UDR0 = c;
 821               	.LM82:
 822 01b4 2093 C600 		sts 198,r18
 823 01b8 2053      		subi r18,lo8(-(-48))
 824 01ba 41E0      		ldi r20,lo8(1)
 825               	.L74:
 826               	.LBE91:
 827               	.LBE88:
 136:util.c        **** 	  started = 1;
 137:util.c        **** 	}
 138:util.c        ****       w -= b * num;
 139:util.c        **** 
 140:util.c        ****       num /= 10;
 829               	.LM83:
 830 01bc CF01      		movw r24,r30
 831 01be 6AE0      		ldi r22,lo8(10)
 832 01c0 70E0      		ldi r23,hi8(10)
 833 01c2 0E94 0000 		call __udivmodhi4
 834 01c6 2196      		adiw r28,1
 835               	.LBE87:
 131:util.c        ****   while(num > 0)
 837               	.LM84:
 838 01c8 C530      		cpi r28,5
 839 01ca D105      		cpc r29,__zero_reg__
 840 01cc 01F0      		breq .L77
 841               	.LBB92:
 139:util.c        ****       w -= b * num;
 843               	.LM85:
 844 01ce 822F      		mov r24,r18
 845 01d0 90E0      		ldi r25,lo8(0)
 846 01d2 9C01      		movw r18,r24
 847 01d4 2E9F      		mul r18,r30
 848 01d6 C001      		movw r24,r0
 849 01d8 2F9F      		mul r18,r31
 850 01da 900D      		add r25,r0
 851 01dc 3E9F      		mul r19,r30
 852 01de 900D      		add r25,r0
 853 01e0 1124      		clr r1
 854 01e2 081B      		sub r16,r24
 855 01e4 190B      		sbc r17,r25
 856 01e6 FB01      		movw r30,r22
 857 01e8 00C0      		rjmp .L76
 858               	.L77:
 859               	/* epilogue start */
 860               	.LBE92:
 141:util.c        ****     }
 142:util.c        **** }
 862               	.LM86:
 863 01ea DF91      		pop r29
 864 01ec CF91      		pop r28
 865 01ee 1F91      		pop r17
 866 01f0 0F91      		pop r16
 867 01f2 0895      		ret
 878               	.Lscope13:
 880               		.stabd	78,0,0
 883               	.global	uart_put_dec
 885               	uart_put_dec:
 886               		.stabd	46,0,0
 143:util.c        **** 
 144:util.c        **** void uart_put_dec(int8_t w)
 145:util.c        **** {
 888               	.LM87:
 889               	.LFBB14:
 890 01f4 1F93      		push r17
 891 01f6 CF93      		push r28
 892 01f8 DF93      		push r29
 893               	/* prologue: function */
 894               	/* frame size = 0 */
 895 01fa 482F      		mov r20,r24
 146:util.c        ****   uint16_t num = 100;
 147:util.c        ****   uint8_t started = 0;
 148:util.c        **** 
 149:util.c        ****   if (w <0 ) {
 897               	.LM88:
 898 01fc 87FF      		sbrs r24,7
 899 01fe 00C0      		rjmp .L81
 900               	.L89:
 901               	.LBB93:
 902               	.LBB94:
  67:util.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
 904               	.LM89:
 905 0200 8091 C000 		lds r24,192
 906 0204 85FF      		sbrs r24,5
 907 0206 00C0      		rjmp .L89
  68:util.c        ****   UDR0 = c;
 909               	.LM90:
 910 0208 8DE2      		ldi r24,lo8(45)
 911 020a 8093 C600 		sts 198,r24
 912               	.LBE94:
 913               	.LBE93:
 150:util.c        ****     uart_putc('-');
 151:util.c        ****     w *= -1;
 915               	.LM91:
 916 020e 4195      		neg r20
 917               	.L81:
 918 0210 E4E6      		ldi r30,lo8(100)
 919 0212 F0E0      		ldi r31,hi8(100)
 920 0214 10E0      		ldi r17,lo8(0)
 921 0216 C0E0      		ldi r28,lo8(0)
 922 0218 D0E0      		ldi r29,hi8(0)
 923               	.L86:
 924               	.LBB95:
 152:util.c        ****   }
 153:util.c        ****   while(num > 0)
 154:util.c        ****     {
 155:util.c        ****       int8_t b = w / num;
 926               	.LM92:
 927 021a 842F      		mov r24,r20
 928 021c 9927      		clr r25
 929 021e 87FD      		sbrc r24,7
 930 0220 9095      		com r25
 931 0222 BF01      		movw r22,r30
 932 0224 0E94 0000 		call __udivmodhi4
 933 0228 262F      		mov r18,r22
 156:util.c        ****       if(b > 0 || started || num == 1)
 935               	.LM93:
 936 022a 1616      		cp __zero_reg__,r22
 937 022c 04F0      		brlt .L88
 938 022e 1123      		tst r17
 939 0230 01F4      		brne .L88
 940 0232 E130      		cpi r30,1
 941 0234 F105      		cpc r31,__zero_reg__
 942 0236 01F4      		brne .L84
 943               	.L88:
 944               	.LBB97:
 945               	.LBB98:
  67:util.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
 947               	.LM94:
 948 0238 8091 C000 		lds r24,192
 949 023c 85FF      		sbrs r24,5
 950 023e 00C0      		rjmp .L88
 951               	.LBE98:
 952               	.LBE97:
 157:util.c        **** 	{
 158:util.c        **** 	  uart_putc('0' + b);
 954               	.LM95:
 955 0240 205D      		subi r18,lo8(-(48))
 956               	.LBB96:
 957               	.LBB99:
  68:util.c        ****   UDR0 = c;
 959               	.LM96:
 960 0242 2093 C600 		sts 198,r18
 961 0246 2053      		subi r18,lo8(-(-48))
 962 0248 11E0      		ldi r17,lo8(1)
 963               	.L84:
 964               	.LBE99:
 965               	.LBE96:
 159:util.c        **** 	  started = 1;
 160:util.c        **** 	}
 161:util.c        ****       w -= b * num;
 162:util.c        **** 
 163:util.c        ****       num /= 10;
 967               	.LM97:
 968 024a CF01      		movw r24,r30
 969 024c 6AE0      		ldi r22,lo8(10)
 970 024e 70E0      		ldi r23,hi8(10)
 971 0250 0E94 0000 		call __udivmodhi4
 972 0254 2196      		adiw r28,1
 973               	.LBE95:
 154:util.c        ****   while(num > 0)
 975               	.LM98:
 976 0256 C330      		cpi r28,3
 977 0258 D105      		cpc r29,__zero_reg__
 978 025a 01F0      		breq .L87
 979               	.LBB100:
 162:util.c        ****       w -= b * num;
 981               	.LM99:
 982 025c 2E9F      		mul r18,r30
 983 025e 802D      		mov r24,r0
 984 0260 1124      		clr r1
 985 0262 481B      		sub r20,r24
 986 0264 FB01      		movw r30,r22
 987 0266 00C0      		rjmp .L86
 988               	.L87:
 989               	/* epilogue start */
 990               	.LBE100:
 164:util.c        ****     }
 165:util.c        **** }
 992               	.LM100:
 993 0268 DF91      		pop r29
 994 026a CF91      		pop r28
 995 026c 1F91      		pop r17
 996 026e 0895      		ret
 1007               	.Lscope14:
 1009               		.stabd	78,0,0
 1012               	.global	uart_putdw_dec
 1014               	uart_putdw_dec:
 1015               		.stabd	46,0,0
 166:util.c        **** 
 167:util.c        **** void uart_putdw_dec(uint32_t dw)
 168:util.c        **** {
 1017               	.LM101:
 1018               	.LFBB15:
 1019 0270 4F92      		push r4
 1020 0272 5F92      		push r5
 1021 0274 6F92      		push r6
 1022 0276 7F92      		push r7
 1023 0278 8F92      		push r8
 1024 027a 9F92      		push r9
 1025 027c AF92      		push r10
 1026 027e BF92      		push r11
 1027 0280 CF92      		push r12
 1028 0282 DF92      		push r13
 1029 0284 EF92      		push r14
 1030 0286 FF92      		push r15
 1031 0288 0F93      		push r16
 1032 028a 1F93      		push r17
 1033 028c CF93      		push r28
 1034 028e DF93      		push r29
 1035               	/* prologue: function */
 1036               	/* frame size = 0 */
 1037 0290 4B01      		movw r8,r22
 1038 0292 5C01      		movw r10,r24
 1040               	.LM102:
 1041 0294 E12C      		mov r14,__zero_reg__
 1042 0296 9AEC      		ldi r25,hi8(1000000000)
 1043 0298 F92E      		mov r15,r25
 1044 029a 9AE9      		ldi r25,hlo8(1000000000)
 1045 029c 092F      		mov r16,r25
 1046 029e 9BE3      		ldi r25,hhi8(1000000000)
 1047 02a0 192F      		mov r17,r25
 1048 02a2 4424      		clr r4
 1049 02a4 C0E0      		ldi r28,lo8(0)
 1050 02a6 D0E0      		ldi r29,hi8(0)
 1051               	.L96:
 1052               	.LBB101:
 169:util.c        ****   uint32_t num = 1000000000;
 170:util.c        ****   uint8_t started = 0;
 171:util.c        **** 
 172:util.c        ****   while(num > 0)
 173:util.c        ****     {
 174:util.c        ****       uint8_t b = dw / num;
 1054               	.LM103:
 1055 02a8 C501      		movw r24,r10
 1056 02aa B401      		movw r22,r8
 1057 02ac A801      		movw r20,r16
 1058 02ae 9701      		movw r18,r14
 1059 02b0 0E94 0000 		call __udivmodsi4
 1060 02b4 D22E      		mov r13,r18
 175:util.c        ****       if(b > 0 || started || num == 1)
 1062               	.LM104:
 1063 02b6 2223      		tst r18
 1064 02b8 01F4      		brne .L98
 1065 02ba 4420      		tst r4
 1066 02bc 01F4      		brne .L98
 1067 02be 81E0      		ldi r24,lo8(1)
 1068 02c0 E816      		cp r14,r24
 1069 02c2 F104      		cpc r15,__zero_reg__
 1070 02c4 0105      		cpc r16,__zero_reg__
 1071 02c6 1105      		cpc r17,__zero_reg__
 1072 02c8 01F4      		brne .L94
 1073               	.L98:
 1074               	.LBB103:
 1075               	.LBB104:
  67:util.c        ****   loop_until_bit_is_set(UCSR0A, UDRE0);
 1077               	.LM105:
 1078 02ca 8091 C000 		lds r24,192
 1079 02ce 85FF      		sbrs r24,5
 1080 02d0 00C0      		rjmp .L98
 1081               	.LBE104:
 1082               	.LBE103:
 176:util.c        **** 	{
 177:util.c        **** 	  uart_putc('0' + b);
 1084               	.LM106:
 1085 02d2 80E3      		ldi r24,lo8(48)
 1086 02d4 D80E      		add r13,r24
 1087               	.LBB102:
 1088               	.LBB105:
  68:util.c        ****   UDR0 = c;
 1090               	.LM107:
 1091 02d6 D092 C600 		sts 198,r13
 1092 02da 80ED      		ldi r24,lo8(-48)
 1093 02dc D80E      		add r13,r24
 1094 02de 4424      		clr r4
 1095 02e0 4394      		inc r4
 1096               	.L94:
 1097               	.LBE105:
 1098               	.LBE102:
 178:util.c        **** 	  started = 1;
 179:util.c        **** 	}
 180:util.c        ****       dw -= b * num;
 181:util.c        **** 
 182:util.c        ****       num /= 10;
 1100               	.LM108:
 1101 02e2 C801      		movw r24,r16
 1102 02e4 B701      		movw r22,r14
 1103 02e6 2AE0      		ldi r18,lo8(10)
 1104 02e8 30E0      		ldi r19,hi8(10)
 1105 02ea 40E0      		ldi r20,hlo8(10)
 1106 02ec 50E0      		ldi r21,hhi8(10)
 1107 02ee 0E94 0000 		call __udivmodsi4
 1108 02f2 C22E      		mov r12,r18
 1109 02f4 732E      		mov r7,r19
 1110 02f6 642E      		mov r6,r20
 1111 02f8 552E      		mov r5,r21
 1112 02fa 2196      		adiw r28,1
 1113               	.LBE101:
 173:util.c        ****   while(num > 0)
 1115               	.LM109:
 1116 02fc CA30      		cpi r28,10
 1117 02fe D105      		cpc r29,__zero_reg__
 1118 0300 01F0      		breq .L97
 1119               	.LBB106:
 181:util.c        ****       dw -= b * num;
 1121               	.LM110:
 1122 0302 6D2D      		mov r22,r13
 1123 0304 70E0      		ldi r23,lo8(0)
 1124 0306 80E0      		ldi r24,lo8(0)
 1125 0308 90E0      		ldi r25,hi8(0)
 1126 030a A801      		movw r20,r16
 1127 030c 9701      		movw r18,r14
 1128 030e 0E94 0000 		call __mulsi3
 1129 0312 861A      		sub r8,r22
 1130 0314 970A      		sbc r9,r23
 1131 0316 A80A      		sbc r10,r24
 1132 0318 B90A      		sbc r11,r25
 1133 031a 2C2D      		mov r18,r12
 1134 031c 372D      		mov r19,r7
 1135 031e 462D      		mov r20,r6
 1136 0320 552D      		mov r21,r5
 1137 0322 C901      		movw r24,r18
 1138 0324 DA01      		movw r26,r20
 1139 0326 7C01      		movw r14,r24
 1140 0328 8D01      		movw r16,r26
 1141 032a 00C0      		rjmp .L96
 1142               	.L97:
 1143               	/* epilogue start */
 1144               	.LBE106:
 183:util.c        ****     }
 184:util.c        **** }
 1146               	.LM111:
 1147 032c DF91      		pop r29
 1148 032e CF91      		pop r28
 1149 0330 1F91      		pop r17
 1150 0332 0F91      		pop r16
 1151 0334 FF90      		pop r15
 1152 0336 EF90      		pop r14
 1153 0338 DF90      		pop r13
 1154 033a CF90      		pop r12
 1155 033c BF90      		pop r11
 1156 033e AF90      		pop r10
 1157 0340 9F90      		pop r9
 1158 0342 8F90      		pop r8
 1159 0344 7F90      		pop r7
 1160 0346 6F90      		pop r6
 1161 0348 5F90      		pop r5
 1162 034a 4F90      		pop r4
 1163 034c 0895      		ret
 1174               	.Lscope15:
 1176               		.stabd	78,0,0
 1181               	.global	dotw
 1183               	dotw:
 1184               		.stabd	46,0,0
 185:util.c        **** 
 186:util.c        **** #ifdef OPTION_DOW_DATELONG
 187:util.c        **** // Date / Time Routines
 188:util.c        **** 
 189:util.c        **** uint8_t dotw(uint8_t mon, uint8_t day, uint8_t yr)
 190:util.c        **** {
 191:util.c        ****   uint16_t month, year;
 192:util.c        **** 
 193:util.c        ****     // Calculate day of the week
 194:util.c        ****     
 195:util.c        ****     month = mon;
 196:util.c        ****     year = 2000 + yr;
 197:util.c        ****     if (mon < 3)  {
 198:util.c        ****       month += 12;
 199:util.c        ****       year -= 1;
 200:util.c        ****     }
 201:util.c        ****     return (day + (2 * month) + (6 * (month+1)/10) + year + (year/4) - (year/100) + (year/400) + 1)
 202:util.c        **** }
 203:util.c        **** 
 204:util.c        **** extern uint8_t DOWText[];
 205:util.c        **** extern uint8_t MonthText[];
 206:util.c        **** 
 207:util.c        **** uint8_t sdotw(uint8_t dow, uint8_t ix) {
 208:util.c        ****  return eeprom_read_byte(&DOWText[(dow*3) + ix]);
 209:util.c        **** }
 210:util.c        **** 
 211:util.c        **** uint8_t smon(uint8_t date_m, uint8_t ix) {
 212:util.c        ****  return eeprom_read_byte(&MonthText[(date_m*3) + ix]);
 213:util.c        **** }
 214:util.c        **** #else
 215:util.c        ****  // GPS Needs the DOTW function
 216:util.c        ****  // This includes DOTW for GPS if DateLong disabled
 217:util.c        ****  #ifdef GPSENABLE
 218:util.c        ****  uint8_t dotw(uint8_t mon, uint8_t day, uint8_t yr)
 219:util.c        ****   {
 1186               	.LM112:
 1187               	.LFBB16:
 1188 034e CF93      		push r28
 1189 0350 DF93      		push r29
 1190               	/* prologue: function */
 1191               	/* frame size = 0 */
 220:util.c        ****    uint16_t month, year; 
 221:util.c        **** 
 222:util.c        ****     // Calculate day of the week
 223:util.c        ****     
 224:util.c        ****     month = mon;
 1193               	.LM113:
 1194 0352 C82F      		mov r28,r24
 1195 0354 D0E0      		ldi r29,lo8(0)
 225:util.c        ****     year = 2000 + yr;
 1197               	.LM114:
 1198 0356 E42F      		mov r30,r20
 1199 0358 F0E0      		ldi r31,lo8(0)
 1200 035a E053      		subi r30,lo8(-(2000))
 1201 035c F84F      		sbci r31,hi8(-(2000))
 226:util.c        ****     if (mon < 3)  {
 1203               	.LM115:
 1204 035e 8330      		cpi r24,lo8(3)
 1205 0360 00F4      		brsh .L101
 227:util.c        ****       month += 12;
 1207               	.LM116:
 1208 0362 2C96      		adiw r28,12
 228:util.c        ****       year -= 1;
 1210               	.LM117:
 1211 0364 3197      		sbiw r30,1
 1212               	.L101:
 1213 0366 262F      		mov r18,r22
 1214 0368 30E0      		ldi r19,lo8(0)
 1215 036a 2F5F      		subi r18,lo8(-(1))
 1216 036c 3F4F      		sbci r19,hi8(-(1))
 1217 036e 2E0F      		add r18,r30
 1218 0370 3F1F      		adc r19,r31
 1219 0372 CE01      		movw r24,r28
 1220 0374 880F      		lsl r24
 1221 0376 991F      		rol r25
 1222 0378 280F      		add r18,r24
 1223 037a 391F      		adc r19,r25
 1224 037c CF01      		movw r24,r30
 1225 037e 9695      		lsr r25
 1226 0380 8795      		ror r24
 1227 0382 9695      		lsr r25
 1228 0384 8795      		ror r24
 1229 0386 280F      		add r18,r24
 1230 0388 391F      		adc r19,r25
 1231 038a CF01      		movw r24,r30
 1232 038c 60E9      		ldi r22,lo8(400)
 1233 038e 71E0      		ldi r23,hi8(400)
 1234 0390 0E94 0000 		call __udivmodhi4
 1235 0394 260F      		add r18,r22
 1236 0396 371F      		adc r19,r23
 1237 0398 CF01      		movw r24,r30
 1238 039a 64E6      		ldi r22,lo8(100)
 1239 039c 70E0      		ldi r23,hi8(100)
 1240 039e 0E94 0000 		call __udivmodhi4
 1241 03a2 261B      		sub r18,r22
 1242 03a4 370B      		sbc r19,r23
 1243 03a6 AE01      		movw r20,r28
 1244 03a8 4F5F      		subi r20,lo8(-(1))
 1245 03aa 5F4F      		sbci r21,hi8(-(1))
 1246 03ac CA01      		movw r24,r20
 1247 03ae 880F      		lsl r24
 1248 03b0 991F      		rol r25
 1249 03b2 840F      		add r24,r20
 1250 03b4 951F      		adc r25,r21
 1251 03b6 880F      		lsl r24
 1252 03b8 991F      		rol r25
 1253 03ba 6AE0      		ldi r22,lo8(10)
 1254 03bc 70E0      		ldi r23,hi8(10)
 1255 03be 0E94 0000 		call __udivmodhi4
 1256 03c2 C901      		movw r24,r18
 1257 03c4 860F      		add r24,r22
 1258 03c6 971F      		adc r25,r23
 1259 03c8 67E0      		ldi r22,lo8(7)
 1260 03ca 70E0      		ldi r23,hi8(7)
 1261 03cc 0E94 0000 		call __udivmodhi4
 1262               	/* epilogue start */
 229:util.c        ****     }
 230:util.c        ****     return (day + (2 * month) + (6 * (month+1)/10) + year + (year/4) - (year/100) + (year/400) + 1)
 231:util.c        ****  }
 1264               	.LM118:
 1265 03d0 DF91      		pop r29
 1266 03d2 CF91      		pop r28
 1267 03d4 0895      		ret
 1273               	.Lscope16:
 1275               		.stabd	78,0,0
 1278               	.global	hours
 1280               	hours:
 1281               		.stabd	46,0,0
 232:util.c        ****  #endif
 233:util.c        **** #endif
 234:util.c        **** 
 235:util.c        **** 
 236:util.c        **** uint8_t hours(uint8_t h)
 237:util.c        **** {
 1283               	.LM119:
 1284               	.LFBB17:
 1285               	/* prologue: function */
 1286               	/* frame size = 0 */
 1287 03d6 982F      		mov r25,r24
 238:util.c        **** 	return (time_format == TIME_12H ? ((h + 23) % 12 + 1) : h);
 1289               	.LM120:
 1290 03d8 8091 0000 		lds r24,time_format
 1291 03dc 8823      		tst r24
 1292 03de 01F4      		brne .L104
 1293 03e0 892F      		mov r24,r25
 1294 03e2 90E0      		ldi r25,lo8(0)
 1295 03e4 4796      		adiw r24,23
 1296 03e6 6CE0      		ldi r22,lo8(12)
 1297 03e8 70E0      		ldi r23,hi8(12)
 1298 03ea 0E94 0000 		call __divmodhi4
 1299 03ee 982F      		mov r25,r24
 1300 03f0 9F5F      		subi r25,lo8(-(1))
 1301               	.L104:
 239:util.c        **** }
 1303               	.LM121:
 1304 03f2 892F      		mov r24,r25
 1305               	/* epilogue start */
 1306 03f4 0895      		ret
 1308               	.Lscope17:
 1310               		.stabd	78,0,0
 1312               	.global	encipher
 1314               	encipher:
 1315               		.stabd	46,0,0
 240:util.c        **** 
 241:util.c        **** extern volatile uint8_t time_s, time_m, time_h;
 242:util.c        **** uint32_t rval[2]={0,0};
 243:util.c        **** uint32_t key[4];
 244:util.c        **** 
 245:util.c        **** void encipher(void) {  // Using 32 rounds of XTea encryption as a PRNG.
 1317               	.LM122:
 1318               	.LFBB18:
 1319 03f6 2F92      		push r2
 1320 03f8 3F92      		push r3
 1321 03fa 4F92      		push r4
 1322 03fc 5F92      		push r5
 1323 03fe 6F92      		push r6
 1324 0400 7F92      		push r7
 1325 0402 8F92      		push r8
 1326 0404 9F92      		push r9
 1327 0406 AF92      		push r10
 1328 0408 BF92      		push r11
 1329 040a CF92      		push r12
 1330 040c DF92      		push r13
 1331 040e EF92      		push r14
 1332 0410 FF92      		push r15
 1333 0412 0F93      		push r16
 1334 0414 1F93      		push r17
 1335               	/* prologue: function */
 1336               	/* frame size = 0 */
 246:util.c        ****   uint32_t v0=rval[0], v1=rval[1], sum=0, delta=0x9E3779B9;
 1338               	.LM123:
 1339 0416 2090 0000 		lds r2,rval
 1340 041a 3090 0000 		lds r3,(rval)+1
 1341 041e 4090 0000 		lds r4,(rval)+2
 1342 0422 5090 0000 		lds r5,(rval)+3
 1343 0426 6090 0000 		lds r6,rval+4
 1344 042a 7090 0000 		lds r7,(rval+4)+1
 1345 042e 8090 0000 		lds r8,(rval+4)+2
 1346 0432 9090 0000 		lds r9,(rval+4)+3
 1347 0436 AA24      		clr r10
 1348 0438 BB24      		clr r11
 1349 043a 6501      		movw r12,r10
 1350               	.L107:
 1351               	.LBB107:
 247:util.c        ****   for (unsigned int i=0; i < 32; i++) {
 248:util.c        ****     v0 += (((v1 << 4) ^ (v1 >> 5)) + v1) ^ (sum + key[sum & 3]);
 1353               	.LM124:
 1354 043c F501      		movw r30,r10
 1355 043e E370      		andi r30,lo8(3)
 1356 0440 F070      		andi r31,hi8(3)
 1357 0442 EE0F      		lsl r30
 1358 0444 FF1F      		rol r31
 1359 0446 EE0F      		lsl r30
 1360 0448 FF1F      		rol r31
 1361 044a E050      		subi r30,lo8(-(key))
 1362 044c F040      		sbci r31,hi8(-(key))
 1363 044e E080      		ld r14,Z
 1364 0450 F180      		ldd r15,Z+1
 1365 0452 0281      		ldd r16,Z+2
 1366 0454 1381      		ldd r17,Z+3
 1367 0456 EA0C      		add r14,r10
 1368 0458 FB1C      		adc r15,r11
 1369 045a 0C1D      		adc r16,r12
 1370 045c 1D1D      		adc r17,r13
 1371 045e D401      		movw r26,r8
 1372 0460 C301      		movw r24,r6
 1373 0462 75E0      		ldi r23,5
 1374 0464 B695      	1:	lsr r27
 1375 0466 A795      		ror r26
 1376 0468 9795      		ror r25
 1377 046a 8795      		ror r24
 1378 046c 7A95      		dec r23
 1379 046e 01F4      		brne 1b
 1380 0470 A401      		movw r20,r8
 1381 0472 9301      		movw r18,r6
 1382 0474 64E0      		ldi r22,4
 1383 0476 220F      	1:	lsl r18
 1384 0478 331F      		rol r19
 1385 047a 441F      		rol r20
 1386 047c 551F      		rol r21
 1387 047e 6A95      		dec r22
 1388 0480 01F4      		brne 1b
 1389 0482 8227      		eor r24,r18
 1390 0484 9327      		eor r25,r19
 1391 0486 A427      		eor r26,r20
 1392 0488 B527      		eor r27,r21
 1393 048a 860D      		add r24,r6
 1394 048c 971D      		adc r25,r7
 1395 048e A81D      		adc r26,r8
 1396 0490 B91D      		adc r27,r9
 1397 0492 E826      		eor r14,r24
 1398 0494 F926      		eor r15,r25
 1399 0496 0A27      		eor r16,r26
 1400 0498 1B27      		eor r17,r27
 1401 049a 2E0C      		add r2,r14
 1402 049c 3F1C      		adc r3,r15
 1403 049e 401E      		adc r4,r16
 1404 04a0 511E      		adc r5,r17
 249:util.c        ****     sum += delta;
 1406               	.LM125:
 1407 04a2 89EB      		ldi r24,lo8(-1640531527)
 1408 04a4 99E7      		ldi r25,hi8(-1640531527)
 1409 04a6 A7E3      		ldi r26,hlo8(-1640531527)
 1410 04a8 BEE9      		ldi r27,hhi8(-1640531527)
 1411 04aa A80E      		add r10,r24
 1412 04ac B91E      		adc r11,r25
 1413 04ae CA1E      		adc r12,r26
 1414 04b0 DB1E      		adc r13,r27
 250:util.c        ****     v1 += (((v0 << 4) ^ (v0 >> 5)) + v0) ^ (sum + key[(sum>>11) & 3]);
 1416               	.LM126:
 1417 04b2 A201      		movw r20,r4
 1418 04b4 9101      		movw r18,r2
 1419 04b6 85E0      		ldi r24,5
 1420 04b8 5695      	1:	lsr r21
 1421 04ba 4795      		ror r20
 1422 04bc 3795      		ror r19
 1423 04be 2795      		ror r18
 1424 04c0 8A95      		dec r24
 1425 04c2 01F4      		brne 1b
 1426 04c4 D201      		movw r26,r4
 1427 04c6 C101      		movw r24,r2
 1428 04c8 04E0      		ldi r16,4
 1429 04ca 880F      	1:	lsl r24
 1430 04cc 991F      		rol r25
 1431 04ce AA1F      		rol r26
 1432 04d0 BB1F      		rol r27
 1433 04d2 0A95      		dec r16
 1434 04d4 01F4      		brne 1b
 1435 04d6 2827      		eor r18,r24
 1436 04d8 3927      		eor r19,r25
 1437 04da 4A27      		eor r20,r26
 1438 04dc 5B27      		eor r21,r27
 1439 04de 220D      		add r18,r2
 1440 04e0 331D      		adc r19,r3
 1441 04e2 441D      		adc r20,r4
 1442 04e4 551D      		adc r21,r5
 1443 04e6 D601      		movw r26,r12
 1444 04e8 C501      		movw r24,r10
 1445 04ea 1BE0      		ldi r17,11
 1446 04ec B695      	1:	lsr r27
 1447 04ee A795      		ror r26
 1448 04f0 9795      		ror r25
 1449 04f2 8795      		ror r24
 1450 04f4 1A95      		dec r17
 1451 04f6 01F4      		brne 1b
 1452 04f8 8370      		andi r24,lo8(3)
 1453 04fa 9070      		andi r25,hi8(3)
 1454 04fc 880F      		lsl r24
 1455 04fe 991F      		rol r25
 1456 0500 880F      		lsl r24
 1457 0502 991F      		rol r25
 1458 0504 8050      		subi r24,lo8(-(key))
 1459 0506 9040      		sbci r25,hi8(-(key))
 1460 0508 FC01      		movw r30,r24
 1461 050a 8081      		ld r24,Z
 1462 050c 9181      		ldd r25,Z+1
 1463 050e A281      		ldd r26,Z+2
 1464 0510 B381      		ldd r27,Z+3
 1465 0512 8A0D      		add r24,r10
 1466 0514 9B1D      		adc r25,r11
 1467 0516 AC1D      		adc r26,r12
 1468 0518 BD1D      		adc r27,r13
 1469 051a 2827      		eor r18,r24
 1470 051c 3927      		eor r19,r25
 1471 051e 4A27      		eor r20,r26
 1472 0520 5B27      		eor r21,r27
 1473 0522 620E      		add r6,r18
 1474 0524 731E      		adc r7,r19
 1475 0526 841E      		adc r8,r20
 1476 0528 951E      		adc r9,r21
 248:util.c        ****   for (unsigned int i=0; i < 32; i++) {
 1478               	.LM127:
 1479 052a F0E2      		ldi r31,lo8(-957401312)
 1480 052c AF16      		cp r10,r31
 1481 052e F7E3      		ldi r31,hi8(-957401312)
 1482 0530 BF06      		cpc r11,r31
 1483 0532 FFEE      		ldi r31,hlo8(-957401312)
 1484 0534 CF06      		cpc r12,r31
 1485 0536 F6EC      		ldi r31,hhi8(-957401312)
 1486 0538 DF06      		cpc r13,r31
 1487 053a 01F0      		breq .+2
 1488 053c 00C0      		rjmp .L107
 1489               	.LBE107:
 251:util.c        ****   }
 252:util.c        ****   rval[0]=v0; rval[1]=v1;
 1491               	.LM128:
 1492 053e 2092 0000 		sts rval,r2
 1493 0542 3092 0000 		sts (rval)+1,r3
 1494 0546 4092 0000 		sts (rval)+2,r4
 1495 054a 5092 0000 		sts (rval)+3,r5
 1496 054e 6092 0000 		sts rval+4,r6
 1497 0552 7092 0000 		sts (rval+4)+1,r7
 1498 0556 8092 0000 		sts (rval+4)+2,r8
 1499 055a 9092 0000 		sts (rval+4)+3,r9
 1500               	/* epilogue start */
 253:util.c        **** }
 1502               	.LM129:
 1503 055e 1F91      		pop r17
 1504 0560 0F91      		pop r16
 1505 0562 FF90      		pop r15
 1506 0564 EF90      		pop r14
 1507 0566 DF90      		pop r13
 1508 0568 CF90      		pop r12
 1509 056a BF90      		pop r11
 1510 056c AF90      		pop r10
 1511 056e 9F90      		pop r9
 1512 0570 8F90      		pop r8
 1513 0572 7F90      		pop r7
 1514 0574 6F90      		pop r6
 1515 0576 5F90      		pop r5
 1516 0578 4F90      		pop r4
 1517 057a 3F90      		pop r3
 1518 057c 2F90      		pop r2
 1519 057e 0895      		ret
 1526               	.Lscope18:
 1528               		.stabd	78,0,0
 1533               	.global	init_crand_consistent
 1535               	init_crand_consistent:
 1536               		.stabd	46,0,0
 254:util.c        **** 
 255:util.c        **** void init_crand_consistent(uint8_t h, uint8_t m, uint8_t s)
 256:util.c        **** {
 1538               	.LM130:
 1539               	.LFBB19:
 1540 0580 CF92      		push r12
 1541 0582 DF92      		push r13
 1542 0584 EF92      		push r14
 1543 0586 FF92      		push r15
 1544 0588 0F93      		push r16
 1545 058a 1F93      		push r17
 1546               	/* prologue: function */
 1547               	/* frame size = 0 */
 1548 058c C62E      		mov r12,r22
 257:util.c        ****   key[0]=0x2DE9716E;  //Initial XTEA key. Grabbed from the first 16 bytes
 258:util.c        ****   key[1]=0x993FDDD1;  //of grc.com/password.  1 in 2^128 chance of seeing
 259:util.c        ****   key[2]=0x2A77FB57;  //that key again there.
 260:util.c        ****   key[3]=0xB172E6B0;
 1550               	.LM131:
 1551 058e 00EB      		ldi r16,lo8(-1317869904)
 1552 0590 16EE      		ldi r17,hi8(-1317869904)
 1553 0592 22E7      		ldi r18,hlo8(-1317869904)
 1554 0594 31EB      		ldi r19,hhi8(-1317869904)
 1555 0596 0093 0000 		sts key+12,r16
 1556 059a 1093 0000 		sts (key+12)+1,r17
 1557 059e 2093 0000 		sts (key+12)+2,r18
 1558 05a2 3093 0000 		sts (key+12)+3,r19
 261:util.c        ****   key[0]^=s;
 1560               	.LM132:
 1561 05a6 50E0      		ldi r21,lo8(0)
 1562 05a8 60E0      		ldi r22,lo8(0)
 1563 05aa 70E0      		ldi r23,hi8(0)
 1564 05ac 0EE6      		ldi r16,lo8(770273646)
 1565 05ae 11E7      		ldi r17,hi8(770273646)
 1566 05b0 29EE      		ldi r18,hlo8(770273646)
 1567 05b2 3DE2      		ldi r19,hhi8(770273646)
 1568 05b4 4027      		eor r20,r16
 1569 05b6 5127      		eor r21,r17
 1570 05b8 6227      		eor r22,r18
 1571 05ba 7327      		eor r23,r19
 1572 05bc 4093 0000 		sts key,r20
 1573 05c0 5093 0000 		sts (key)+1,r21
 1574 05c4 6093 0000 		sts (key)+2,r22
 1575 05c8 7093 0000 		sts (key)+3,r23
 262:util.c        ****   key[1]^=m;
 1577               	.LM133:
 1578 05cc DD24      		clr r13
 1579 05ce EE24      		clr r14
 1580 05d0 FF24      		clr r15
 1581 05d2 21ED      		ldi r18,lo8(-1723867695)
 1582 05d4 3DED      		ldi r19,hi8(-1723867695)
 1583 05d6 4FE3      		ldi r20,hlo8(-1723867695)
 1584 05d8 59E9      		ldi r21,hhi8(-1723867695)
 1585 05da C226      		eor r12,r18
 1586 05dc D326      		eor r13,r19
 1587 05de E426      		eor r14,r20
 1588 05e0 F526      		eor r15,r21
 1589 05e2 C092 0000 		sts key+4,r12
 1590 05e6 D092 0000 		sts (key+4)+1,r13
 1591 05ea E092 0000 		sts (key+4)+2,r14
 1592 05ee F092 0000 		sts (key+4)+3,r15
 263:util.c        ****   key[2]^=h;
 1594               	.LM134:
 1595 05f2 90E0      		ldi r25,lo8(0)
 1596 05f4 A0E0      		ldi r26,lo8(0)
 1597 05f6 B0E0      		ldi r27,hi8(0)
 1598 05f8 27E5      		ldi r18,lo8(712506199)
 1599 05fa 3BEF      		ldi r19,hi8(712506199)
 1600 05fc 47E7      		ldi r20,hlo8(712506199)
 1601 05fe 5AE2      		ldi r21,hhi8(712506199)
 1602 0600 8227      		eor r24,r18
 1603 0602 9327      		eor r25,r19
 1604 0604 A427      		eor r26,r20
 1605 0606 B527      		eor r27,r21
 1606 0608 8093 0000 		sts key+8,r24
 1607 060c 9093 0000 		sts (key+8)+1,r25
 1608 0610 A093 0000 		sts (key+8)+2,r26
 1609 0614 B093 0000 		sts (key+8)+3,r27
 264:util.c        ****   rval[0]=0;
 1611               	.LM135:
 1612 0618 1092 0000 		sts rval,__zero_reg__
 1613 061c 1092 0000 		sts (rval)+1,__zero_reg__
 1614 0620 1092 0000 		sts (rval)+2,__zero_reg__
 1615 0624 1092 0000 		sts (rval)+3,__zero_reg__
 265:util.c        ****   rval[1]=0;
 1617               	.LM136:
 1618 0628 1092 0000 		sts rval+4,__zero_reg__
 1619 062c 1092 0000 		sts (rval+4)+1,__zero_reg__
 1620 0630 1092 0000 		sts (rval+4)+2,__zero_reg__
 1621 0634 1092 0000 		sts (rval+4)+3,__zero_reg__
 266:util.c        ****   encipher();
 1623               	.LM137:
 1624 0638 0E94 0000 		call encipher
 1625               	/* epilogue start */
 267:util.c        **** }
 1627               	.LM138:
 1628 063c 1F91      		pop r17
 1629 063e 0F91      		pop r16
 1630 0640 FF90      		pop r15
 1631 0642 EF90      		pop r14
 1632 0644 DF90      		pop r13
 1633 0646 CF90      		pop r12
 1634 0648 0895      		ret
 1636               	.Lscope19:
 1638               		.stabd	78,0,0
 1640               	.global	init_crand
 1642               	init_crand:
 1643               		.stabd	46,0,0
 268:util.c        **** 
 269:util.c        **** void init_crand(void) {
 1645               	.LM139:
 1646               	.LFBB20:
 1647               	/* prologue: function */
 1648               	/* frame size = 0 */
 270:util.c        ****   //uint32_t temp;
 271:util.c        ****   init_crand_consistent(time_h,time_m,time_s);
 1650               	.LM140:
 1651 064a 8091 0000 		lds r24,time_h
 1652 064e 6091 0000 		lds r22,time_m
 1653 0652 4091 0000 		lds r20,time_s
 1654 0656 0E94 0000 		call init_crand_consistent
 1655               	/* epilogue start */
 272:util.c        **** }
 1657               	.LM141:
 1658 065a 0895      		ret
 1660               	.Lscope20:
 1662               		.stabd	78,0,0
 1665               	.global	crand
 1667               	crand:
 1668               		.stabd	46,0,0
 273:util.c        **** 
 274:util.c        **** uint16_t crand(uint8_t type) {
 1670               	.LM142:
 1671               	.LFBB21:
 1672               	/* prologue: function */
 1673               	/* frame size = 0 */
 275:util.c        **** // Dataman - Compiler didn't like this logic, and I don't blame it,
 276:util.c        **** // Code path could be simplified.
 277:util.c        **** //  if((type==0)||(type>2)) {
 278:util.c        **** //    wdt_reset();
 279:util.c        **** //    encipher();
 280:util.c        **** //    return (rval[0]^rval[1])&RAND_MAX;
 281:util.c        **** //  } 
 282:util.c        **** //   else
 283:util.c        ****  if (type==1) {
 1675               	.LM143:
 1676 065c 8130      		cpi r24,lo8(1)
 1677 065e 01F4      		brne .L115
 284:util.c        ****   	return ((rval[0]^rval[1])>>15)&3;
 1679               	.LM144:
 1680 0660 8091 0000 		lds r24,rval+4
 1681 0664 9091 0000 		lds r25,(rval+4)+1
 1682 0668 A091 0000 		lds r26,(rval+4)+2
 1683 066c B091 0000 		lds r27,(rval+4)+3
 1684 0670 2091 0000 		lds r18,rval
 1685 0674 3091 0000 		lds r19,(rval)+1
 1686 0678 4091 0000 		lds r20,(rval)+2
 1687 067c 5091 0000 		lds r21,(rval)+3
 1688 0680 8227      		eor r24,r18
 1689 0682 9327      		eor r25,r19
 1690 0684 A427      		eor r26,r20
 1691 0686 B527      		eor r27,r21
 1692 0688 3FE0      		ldi r19,15
 1693 068a B695      	1:	lsr r27
 1694 068c A795      		ror r26
 1695 068e 9795      		ror r25
 1696 0690 8795      		ror r24
 1697 0692 3A95      		dec r19
 1698 0694 01F4      		brne 1b
 1699 0696 9C01      		movw r18,r24
 1700 0698 2370      		andi r18,lo8(3)
 1701 069a 3070      		andi r19,hi8(3)
 1702 069c 00C0      		rjmp .L116
 1703               	.L115:
 285:util.c        ****   } 
 286:util.c        ****     else if (type==2) {
 1705               	.LM145:
 1706 069e 8230      		cpi r24,lo8(2)
 1707 06a0 01F4      		brne .L117
 287:util.c        ****    return ((rval[0]^rval[1])>>17)&1;
 1709               	.LM146:
 1710 06a2 8091 0000 		lds r24,rval+4
 1711 06a6 9091 0000 		lds r25,(rval+4)+1
 1712 06aa A091 0000 		lds r26,(rval+4)+2
 1713 06ae B091 0000 		lds r27,(rval+4)+3
 1714 06b2 2091 0000 		lds r18,rval
 1715 06b6 3091 0000 		lds r19,(rval)+1
 1716 06ba 4091 0000 		lds r20,(rval)+2
 1717 06be 5091 0000 		lds r21,(rval)+3
 1718 06c2 8227      		eor r24,r18
 1719 06c4 9327      		eor r25,r19
 1720 06c6 A427      		eor r26,r20
 1721 06c8 B527      		eor r27,r21
 1722 06ca 21E1      		ldi r18,17
 1723 06cc B695      	1:	lsr r27
 1724 06ce A795      		ror r26
 1725 06d0 9795      		ror r25
 1726 06d2 8795      		ror r24
 1727 06d4 2A95      		dec r18
 1728 06d6 01F4      		brne 1b
 1729 06d8 9C01      		movw r18,r24
 1730 06da 2170      		andi r18,lo8(1)
 1731 06dc 3070      		andi r19,hi8(1)
 1732 06de 00C0      		rjmp .L116
 1733               	.L117:
 288:util.c        ****   }
 289:util.c        ****   wdt_reset();
 1735               	.LM147:
 1736               	/* #APP */
 1737               	 ;  290 "util.c" 1
 1738 06e0 A895      		wdr
 1739               	 ;  0 "" 2
 290:util.c        ****   encipher();
 1741               	.LM148:
 1742               	/* #NOAPP */
 1743 06e2 0E94 0000 		call encipher
 291:util.c        ****   return (rval[0]^rval[1])&RAND_MAX; 
 1745               	.LM149:
 1746 06e6 2091 0000 		lds r18,rval+4
 1747 06ea 3091 0000 		lds r19,(rval+4)+1
 1748 06ee 8091 0000 		lds r24,rval
 1749 06f2 9091 0000 		lds r25,(rval)+1
 1750 06f6 2827      		eor r18,r24
 1751 06f8 3927      		eor r19,r25
 1752 06fa 3F77      		andi r19,hi8(32767)
 1753               	.L116:
 292:util.c        **** }
 1755               	.LM150:
 1756 06fc C901      		movw r24,r18
 1757               	/* epilogue start */
 1758 06fe 0895      		ret
 1760               	.Lscope21:
 1762               		.stabd	78,0,0
 1772               	.global	intersectrect
 1774               	intersectrect:
 1775               		.stabd	46,0,0
 293:util.c        **** 
 294:util.c        **** #ifdef RATTDEATH
 295:util.c        **** extern unsigned char BigFont[];
 296:util.c        **** void drawbigdigit(uint8_t x, uint8_t y, uint8_t n, uint8_t inverted) {
 297:util.c        ****   uint8_t i, j;
 298:util.c        ****   uint8_t sizex=2, sizey=2;
 299:util.c        ****   
 300:util.c        **** #ifdef DEATHCHRON
 301:util.c        ****   if(displaystyle == STYLE_DEATH)
 302:util.c        ****   {
 303:util.c        ****   	  sizex = 3; sizey = 5;
 304:util.c        ****   }
 305:util.c        **** #endif
 306:util.c        ****   
 307:util.c        ****   for (i = 0; i < 4; i++) {
 308:util.c        ****     uint8_t d = eeprom_read_byte(&BigFont[(n*4)+i]);
 309:util.c        ****     for (j=0; j<8; j++) {
 310:util.c        ****       if (d & _BV(7-j)) {
 311:util.c        **** 	glcdFillRectangle(x+i*sizex, y+j*sizey, sizex, sizey, !inverted);
 312:util.c        ****       } else {
 313:util.c        **** 	glcdFillRectangle(x+i*sizex, y+j*sizey, sizex, sizey, inverted);
 314:util.c        ****       }
 315:util.c        ****     }
 316:util.c        ****   }
 317:util.c        **** }
 318:util.c        **** 
 319:util.c        **** uint8_t intersectrect(uint8_t x1, uint8_t y1, uint8_t w1, uint8_t h1,
 320:util.c        **** 		      uint8_t x2, uint8_t y2, uint8_t w2, uint8_t h2) {
 1777               	.LM151:
 1778               	.LFBB22:
 1779 0700 AF92      		push r10
 1780 0702 CF92      		push r12
 1781 0704 EF92      		push r14
 1782 0706 0F93      		push r16
 1783               	/* prologue: function */
 1784               	/* frame size = 0 */
 321:util.c        ****   // yer everyday intersection tester
 322:util.c        ****   // check x coord first
 323:util.c        ****   if (x1+w1 < x2)
 1786               	.LM152:
 1787 0708 A82F      		mov r26,r24
 1788 070a B0E0      		ldi r27,lo8(0)
 1789 070c E02F      		mov r30,r16
 1790 070e F0E0      		ldi r31,lo8(0)
 1791 0710 CD01      		movw r24,r26
 1792 0712 840F      		add r24,r20
 1793 0714 911D      		adc r25,__zero_reg__
 1794 0716 8E17      		cp r24,r30
 1795 0718 9F07      		cpc r25,r31
 1796 071a 04F0      		brlt .L120
 324:util.c        ****     return 0;
 325:util.c        ****   if (x2+w2 < x1)
 1798               	.LM153:
 1799 071c EC0D      		add r30,r12
 1800 071e F11D      		adc r31,__zero_reg__
 1801 0720 EA17      		cp r30,r26
 1802 0722 FB07      		cpc r31,r27
 1803 0724 04F0      		brlt .L120
 326:util.c        ****     return 0;
 327:util.c        **** 
 328:util.c        ****   // check the y coord second
 329:util.c        ****   if (y1+h1 < y2)
 1805               	.LM154:
 1806 0726 70E0      		ldi r23,lo8(0)
 1807 0728 4E2D      		mov r20,r14
 1808 072a 50E0      		ldi r21,lo8(0)
 1809 072c CB01      		movw r24,r22
 1810 072e 820F      		add r24,r18
 1811 0730 911D      		adc r25,__zero_reg__
 1812 0732 8417      		cp r24,r20
 1813 0734 9507      		cpc r25,r21
 1814 0736 04F0      		brlt .L120
 1815 0738 80E0      		ldi r24,lo8(0)
 1816 073a 4A0D      		add r20,r10
 1817 073c 511D      		adc r21,__zero_reg__
 1818 073e 4617      		cp r20,r22
 1819 0740 5707      		cpc r21,r23
 1820 0742 04F0      		brlt .L122
 1821 0744 81E0      		ldi r24,lo8(1)
 1822 0746 00C0      		rjmp .L122
 1823               	.L120:
 1824 0748 80E0      		ldi r24,lo8(0)
 1825               	.L122:
 1826               	/* epilogue start */
 330:util.c        ****     return 0;
 331:util.c        ****   if (y2+h2 < y1)
 332:util.c        ****     return 0;
 333:util.c        **** 
 334:util.c        ****   return 1;
 335:util.c        **** }
 1828               	.LM155:
 1829 074a 0F91      		pop r16
 1830 074c EF90      		pop r14
 1831 074e CF90      		pop r12
 1832 0750 AF90      		pop r10
 1833 0752 0895      		ret
 1835               	.Lscope22:
 1837               		.stabd	78,0,0
 1842               	.global	add_month
 1844               	add_month:
 1845               		.stabd	46,0,0
 336:util.c        **** #endif
 337:util.c        **** 
 338:util.c        **** //Config menu related functions
 339:util.c        **** void print_menu_advance(){
 340:util.c        ****   print_menu("MENU","advance","SET","set");
 341:util.c        ****   // Press MENU to avance
 342:util.c        ****   // Press SET to set
 343:util.c        **** }
 344:util.c        **** 
 345:util.c        **** void print_menu_exit(){
 346:util.c        ****   print_menu("MENU","exit","SET","save");
 347:util.c        ****   //Press MENU to exit
 348:util.c        ****   //Press SET to set
 349:util.c        **** }
 350:util.c        **** 
 351:util.c        **** void print_menu_change(){
 352:util.c        ****  print_menu_opts("change","save");
 353:util.c        ****  // Press + to change
 354:util.c        ****  // Press SET to save
 355:util.c        **** }
 356:util.c        **** 
 357:util.c        **** void PRINT_MENU_OPTS(const char *Opt1, const char *Opt2){
 358:util.c        ****  PRINT_MENU(PSTR("+"),Opt1,PSTR("SET"),Opt2);
 359:util.c        ****  // Press + to X
 360:util.c        ****  // Press SET to X
 361:util.c        **** }
 362:util.c        **** 
 363:util.c        **** void PRINT_MENU(const char *Button1, const char *Opt1, const char *Button2, const char *Opt2){
 364:util.c        ****  glcdFillRectangle(0, 48, GLCD_XPIXELS, 16, NORMAL);
 365:util.c        ****  PRINT_MENU_LINE(6,Button1,Opt1);
 366:util.c        ****  PRINT_MENU_LINE(7,Button2,Opt2);
 367:util.c        **** }
 368:util.c        **** 
 369:util.c        **** void PRINT_MENU_LINE(uint8_t line, const char *Button, const char *Action){
 370:util.c        ****   glcdSetAddress(0, line);
 371:util.c        ****   glcdPutStr("Press ",NORMAL);
 372:util.c        ****   glcdPutStr_rom(Button,NORMAL);
 373:util.c        ****   glcdPutStr(" to ",NORMAL);
 374:util.c        ****   glcdPutStr_rom(Action,NORMAL);
 375:util.c        **** }
 376:util.c        **** 
 377:util.c        **** uint8_t check_timeout(void)
 378:util.c        **** {
 379:util.c        **** 	if((displaymode != SET_TIME)&&(displaystyle<=STYLE_ROTATE))
 380:util.c        **** 	{
 381:util.c        **** 		screenmutex++;
 382:util.c        **** 		print_time(time_h, time_m, time_s, SET_TIME);
 383:util.c        **** 		screenmutex--;
 384:util.c        **** 	}
 385:util.c        **** 	if (just_pressed & 0x1) { // mode change
 386:util.c        ****       return 1;
 387:util.c        ****     }
 388:util.c        ****     if (just_pressed || pressed) {
 389:util.c        ****       timeoutcounter = INACTIVITYTIMEOUT;  
 390:util.c        ****       // timeout w/no buttons pressed after 3 seconds?
 391:util.c        ****     } else if (!timeoutcounter) {
 392:util.c        ****       //timed out!
 393:util.c        ****       displaymode = SHOW_TIME;     
 394:util.c        ****       return 2;
 395:util.c        ****     }
 396:util.c        ****     return 0;
 397:util.c        **** }
 398:util.c        **** 
 399:util.c        **** void add_month(volatile uint8_t *month, volatile uint8_t *day, uint16_t year)
 400:util.c        **** {
 1847               	.LM156:
 1848               	.LFBB23:
 1849 0754 0F93      		push r16
 1850 0756 1F93      		push r17
 1851 0758 CF93      		push r28
 1852 075a DF93      		push r29
 1853               	/* prologue: function */
 1854               	/* frame size = 0 */
 1855 075c FC01      		movw r30,r24
 1856 075e EB01      		movw r28,r22
 1857 0760 8A01      		movw r16,r20
 401:util.c        **** 	if (*month >= 13)
 1859               	.LM157:
 1860 0762 8081      		ld r24,Z
 1861 0764 8D30      		cpi r24,lo8(13)
 1862 0766 00F0      		brlo .L125
 402:util.c        **** 	  *month = 1;
 1864               	.LM158:
 1865 0768 81E0      		ldi r24,lo8(1)
 1866 076a 8083      		st Z,r24
 1867               	.L125:
 403:util.c        **** 	if(*month == 2) {
 1869               	.LM159:
 1870 076c 8081      		ld r24,Z
 1871 076e 8230      		cpi r24,lo8(2)
 1872 0770 01F4      		brne .L126
 404:util.c        **** 	  if(leapyear(year) && (*day > 29))
 1874               	.LM160:
 1875 0772 C801      		movw r24,r16
 1876 0774 0E94 0000 		call leapyear
 1877 0778 8823      		tst r24
 1878 077a 01F0      		breq .L127
 1879 077c 8881      		ld r24,Y
 1880 077e 8E31      		cpi r24,lo8(30)
 1881 0780 00F0      		brlo .L127
 405:util.c        **** 	  	*day = 29;
 1883               	.LM161:
 1884 0782 8DE1      		ldi r24,lo8(29)
 1885 0784 00C0      		rjmp .L131
 1886               	.L127:
 406:util.c        **** 	  else if (!leapyear(year) && (*day > 28))
 1888               	.LM162:
 1889 0786 C801      		movw r24,r16
 1890 0788 0E94 0000 		call leapyear
 1891 078c 8823      		tst r24
 1892 078e 01F4      		brne .L130
 1893 0790 8881      		ld r24,Y
 1894 0792 8D31      		cpi r24,lo8(29)
 1895 0794 00F0      		brlo .L130
 407:util.c        **** 	    *day = 28;
 1897               	.LM163:
 1898 0796 8CE1      		ldi r24,lo8(28)
 1899 0798 00C0      		rjmp .L131
 1900               	.L126:
 408:util.c        **** 	} else if ((*month == 4) || (*month == 6) || (*month == 9) || (*month == 11)) {
 1902               	.LM164:
 1903 079a 8081      		ld r24,Z
 1904 079c 8430      		cpi r24,lo8(4)
 1905 079e 01F0      		breq .L129
 1906 07a0 8081      		ld r24,Z
 1907 07a2 8630      		cpi r24,lo8(6)
 1908 07a4 01F0      		breq .L129
 1909 07a6 8081      		ld r24,Z
 1910 07a8 8930      		cpi r24,lo8(9)
 1911 07aa 01F0      		breq .L129
 1912 07ac 8081      		ld r24,Z
 1913 07ae 8B30      		cpi r24,lo8(11)
 1914 07b0 01F4      		brne .L130
 1915               	.L129:
 409:util.c        ****       if(*day > 30)
 1917               	.LM165:
 1918 07b2 8881      		ld r24,Y
 1919 07b4 8F31      		cpi r24,lo8(31)
 1920 07b6 00F0      		brlo .L130
 410:util.c        ****       	*day = 30;
 1922               	.LM166:
 1923 07b8 8EE1      		ldi r24,lo8(30)
 1924               	.L131:
 1925 07ba 8883      		st Y,r24
 1926               	.L130:
 1927               	/* epilogue start */
 411:util.c        ****   }
 412:util.c        **** }
 1929               	.LM167:
 1930 07bc DF91      		pop r29
 1931 07be CF91      		pop r28
 1932 07c0 1F91      		pop r17
 1933 07c2 0F91      		pop r16
 1934 07c4 0895      		ret
 1936               	.Lscope23:
 1938               		.stabd	78,0,0
 1940               	.global	check_timeout
 1942               	check_timeout:
 1943               		.stabd	46,0,0
 379:util.c        **** {
 1945               	.LM168:
 1946               	.LFBB24:
 1947               	/* prologue: function */
 1948               	/* frame size = 0 */
 380:util.c        **** 	if((displaymode != SET_TIME)&&(displaystyle<=STYLE_ROTATE))
 1950               	.LM169:
 1951 07c6 8091 0000 		lds r24,displaymode
 1952 07ca 8330      		cpi r24,lo8(3)
 1953 07cc 01F0      		breq .L133
 1954 07ce 8091 0000 		lds r24,displaystyle
 1955 07d2 863D      		cpi r24,lo8(-42)
 1956 07d4 00F4      		brsh .L133
 382:util.c        **** 		screenmutex++;
 1958               	.LM170:
 1959 07d6 8091 0000 		lds r24,screenmutex
 1960 07da 8F5F      		subi r24,lo8(-(1))
 1961 07dc 8093 0000 		sts screenmutex,r24
 383:util.c        **** 		print_time(time_h, time_m, time_s, SET_TIME);
 1963               	.LM171:
 1964 07e0 8091 0000 		lds r24,time_h
 1965 07e4 6091 0000 		lds r22,time_m
 1966 07e8 4091 0000 		lds r20,time_s
 1967 07ec 23E0      		ldi r18,lo8(3)
 1968 07ee 0E94 0000 		call print_time
 384:util.c        **** 		screenmutex--;
 1970               	.LM172:
 1971 07f2 8091 0000 		lds r24,screenmutex
 1972 07f6 8150      		subi r24,lo8(-(-1))
 1973 07f8 8093 0000 		sts screenmutex,r24
 1974               	.L133:
 386:util.c        **** 	if (just_pressed & 0x1) { // mode change
 1976               	.LM173:
 1977 07fc 8091 0000 		lds r24,just_pressed
 1978 0800 80FF      		sbrs r24,0
 1979 0802 00C0      		rjmp .L134
 1980 0804 81E0      		ldi r24,lo8(1)
 1981 0806 0895      		ret
 1982               	.L134:
 389:util.c        ****     if (just_pressed || pressed) {
 1984               	.LM174:
 1985 0808 8091 0000 		lds r24,just_pressed
 1986 080c 8823      		tst r24
 1987 080e 01F4      		brne .L136
 1988 0810 8091 0000 		lds r24,pressed
 1989 0814 8823      		tst r24
 1990 0816 01F0      		breq .L137
 1991               	.L136:
 390:util.c        ****       timeoutcounter = INACTIVITYTIMEOUT;  
 1993               	.LM175:
 1994 0818 8AE0      		ldi r24,lo8(10)
 1995 081a 8093 0000 		sts timeoutcounter,r24
 1996 081e 00C0      		rjmp .L140
 1997               	.L137:
 392:util.c        ****     } else if (!timeoutcounter) {
 1999               	.LM176:
 2000 0820 8091 0000 		lds r24,timeoutcounter
 2001 0824 8823      		tst r24
 2002 0826 01F0      		breq .L138
 2003               	.L140:
 2004 0828 80E0      		ldi r24,lo8(0)
 2005 082a 0895      		ret
 2006               	.L138:
 394:util.c        ****       displaymode = SHOW_TIME;     
 2008               	.LM177:
 2009 082c 1092 0000 		sts displaymode,__zero_reg__
 2010 0830 82E0      		ldi r24,lo8(2)
 398:util.c        **** }
 2012               	.LM178:
 2013 0832 0895      		ret
 2015               	.Lscope24:
 2017               		.stabd	78,0,0
 2022               	.global	PRINT_MENU_LINE
 2024               	PRINT_MENU_LINE:
 2025               		.stabd	46,0,0
 370:util.c        **** void PRINT_MENU_LINE(uint8_t line, const char *Button, const char *Action){
 2027               	.LM179:
 2028               	.LFBB25:
 2029 0834 EF92      		push r14
 2030 0836 FF92      		push r15
 2031 0838 0F93      		push r16
 2032 083a 1F93      		push r17
 2033               	/* prologue: function */
 2034               	/* frame size = 0 */
 2035 083c 982F      		mov r25,r24
 2036 083e 8B01      		movw r16,r22
 2037 0840 7A01      		movw r14,r20
 371:util.c        ****   glcdSetAddress(0, line);
 2039               	.LM180:
 2040 0842 80E0      		ldi r24,lo8(0)
 2041 0844 692F      		mov r22,r25
 2042 0846 0E94 0000 		call glcdSetAddress
 372:util.c        ****   glcdPutStr("Press ",NORMAL);
 2044               	.LM181:
 2045 084a 80E0      		ldi r24,lo8(__c.2260)
 2046 084c 90E0      		ldi r25,hi8(__c.2260)
 2047 084e 60E0      		ldi r22,lo8(0)
 2048 0850 0E94 0000 		call glcdPutStr_rom
 373:util.c        ****   glcdPutStr_rom(Button,NORMAL);
 2050               	.LM182:
 2051 0854 C801      		movw r24,r16
 2052 0856 60E0      		ldi r22,lo8(0)
 2053 0858 0E94 0000 		call glcdPutStr_rom
 374:util.c        ****   glcdPutStr(" to ",NORMAL);
 2055               	.LM183:
 2056 085c 80E0      		ldi r24,lo8(__c.2262)
 2057 085e 90E0      		ldi r25,hi8(__c.2262)
 2058 0860 60E0      		ldi r22,lo8(0)
 2059 0862 0E94 0000 		call glcdPutStr_rom
 375:util.c        ****   glcdPutStr_rom(Action,NORMAL);
 2061               	.LM184:
 2062 0866 C701      		movw r24,r14
 2063 0868 60E0      		ldi r22,lo8(0)
 2064 086a 0E94 0000 		call glcdPutStr_rom
 2065               	/* epilogue start */
 376:util.c        **** }
 2067               	.LM185:
 2068 086e 1F91      		pop r17
 2069 0870 0F91      		pop r16
 2070 0872 FF90      		pop r15
 2071 0874 EF90      		pop r14
 2072 0876 0895      		ret
 2074               	.Lscope25:
 2076               		.stabd	78,0,0
 2082               	.global	PRINT_MENU
 2084               	PRINT_MENU:
 2085               		.stabd	46,0,0
 364:util.c        **** void PRINT_MENU(const char *Button1, const char *Opt1, const char *Button2, const char *Opt2){
 2087               	.LM186:
 2088               	.LFBB26:
 2089 0878 8F92      		push r8
 2090 087a 9F92      		push r9
 2091 087c AF92      		push r10
 2092 087e BF92      		push r11
 2093 0880 CF92      		push r12
 2094 0882 DF92      		push r13
 2095 0884 EF92      		push r14
 2096 0886 FF92      		push r15
 2097 0888 0F93      		push r16
 2098               	/* prologue: function */
 2099               	/* frame size = 0 */
 2100 088a 7C01      		movw r14,r24
 2101 088c 6B01      		movw r12,r22
 2102 088e 5A01      		movw r10,r20
 2103 0890 4901      		movw r8,r18
 365:util.c        ****  glcdFillRectangle(0, 48, GLCD_XPIXELS, 16, NORMAL);
 2105               	.LM187:
 2106 0892 80E0      		ldi r24,lo8(0)
 2107 0894 60E3      		ldi r22,lo8(48)
 2108 0896 40E8      		ldi r20,lo8(-128)
 2109 0898 20E1      		ldi r18,lo8(16)
 2110 089a 00E0      		ldi r16,lo8(0)
 2111 089c 0E94 0000 		call glcdFillRectangle
 366:util.c        ****  PRINT_MENU_LINE(6,Button1,Opt1);
 2113               	.LM188:
 2114 08a0 86E0      		ldi r24,lo8(6)
 2115 08a2 B701      		movw r22,r14
 2116 08a4 A601      		movw r20,r12
 2117 08a6 0E94 0000 		call PRINT_MENU_LINE
 367:util.c        ****  PRINT_MENU_LINE(7,Button2,Opt2);
 2119               	.LM189:
 2120 08aa 87E0      		ldi r24,lo8(7)
 2121 08ac B501      		movw r22,r10
 2122 08ae A401      		movw r20,r8
 2123 08b0 0E94 0000 		call PRINT_MENU_LINE
 2124               	/* epilogue start */
 368:util.c        **** }
 2126               	.LM190:
 2127 08b4 0F91      		pop r16
 2128 08b6 FF90      		pop r15
 2129 08b8 EF90      		pop r14
 2130 08ba DF90      		pop r13
 2131 08bc CF90      		pop r12
 2132 08be BF90      		pop r11
 2133 08c0 AF90      		pop r10
 2134 08c2 9F90      		pop r9
 2135 08c4 8F90      		pop r8
 2136 08c6 0895      		ret
 2138               	.Lscope26:
 2140               		.stabd	78,0,0
 2144               	.global	PRINT_MENU_OPTS
 2146               	PRINT_MENU_OPTS:
 2147               		.stabd	46,0,0
 358:util.c        **** void PRINT_MENU_OPTS(const char *Opt1, const char *Opt2){
 2149               	.LM191:
 2150               	.LFBB27:
 2151               	/* prologue: function */
 2152               	/* frame size = 0 */
 2153 08c8 AC01      		movw r20,r24
 2154 08ca 9B01      		movw r18,r22
 359:util.c        ****  PRINT_MENU(PSTR("+"),Opt1,PSTR("SET"),Opt2);
 2156               	.LM192:
 2157 08cc 80E0      		ldi r24,lo8(__c.2245)
 2158 08ce 90E0      		ldi r25,hi8(__c.2245)
 2159 08d0 BA01      		movw r22,r20
 2160 08d2 40E0      		ldi r20,lo8(__c.2247)
 2161 08d4 50E0      		ldi r21,hi8(__c.2247)
 2162 08d6 0E94 0000 		call PRINT_MENU
 2163               	/* epilogue start */
 362:util.c        **** }
 2165               	.LM193:
 2166 08da 0895      		ret
 2168               	.Lscope27:
 2170               		.stabd	78,0,0
 2172               	.global	print_menu_change
 2174               	print_menu_change:
 2175               		.stabd	46,0,0
 352:util.c        **** void print_menu_change(){
 2177               	.LM194:
 2178               	.LFBB28:
 2179               	/* prologue: function */
 2180               	/* frame size = 0 */
 353:util.c        ****  print_menu_opts("change","save");
 2182               	.LM195:
 2183 08dc 80E0      		ldi r24,lo8(__c.2237)
 2184 08de 90E0      		ldi r25,hi8(__c.2237)
 2185 08e0 60E0      		ldi r22,lo8(__c.2239)
 2186 08e2 70E0      		ldi r23,hi8(__c.2239)
 2187 08e4 0E94 0000 		call PRINT_MENU_OPTS
 2188               	/* epilogue start */
 356:util.c        **** }
 2190               	.LM196:
 2191 08e8 0895      		ret
 2193               	.Lscope28:
 2195               		.stabd	78,0,0
 2197               	.global	print_menu_exit
 2199               	print_menu_exit:
 2200               		.stabd	46,0,0
 346:util.c        **** void print_menu_exit(){
 2202               	.LM197:
 2203               	.LFBB29:
 2204               	/* prologue: function */
 2205               	/* frame size = 0 */
 347:util.c        ****   print_menu("MENU","exit","SET","save");
 2207               	.LM198:
 2208 08ea 80E0      		ldi r24,lo8(__c.2227)
 2209 08ec 90E0      		ldi r25,hi8(__c.2227)
 2210 08ee 60E0      		ldi r22,lo8(__c.2229)
 2211 08f0 70E0      		ldi r23,hi8(__c.2229)
 2212 08f2 40E0      		ldi r20,lo8(__c.2231)
 2213 08f4 50E0      		ldi r21,hi8(__c.2231)
 2214 08f6 20E0      		ldi r18,lo8(__c.2233)
 2215 08f8 30E0      		ldi r19,hi8(__c.2233)
 2216 08fa 0E94 0000 		call PRINT_MENU
 2217               	/* epilogue start */
 350:util.c        **** }
 2219               	.LM199:
 2220 08fe 0895      		ret
 2222               	.Lscope29:
 2224               		.stabd	78,0,0
 2226               	.global	print_menu_advance
 2228               	print_menu_advance:
 2229               		.stabd	46,0,0
 340:util.c        **** void print_menu_advance(){
 2231               	.LM200:
 2232               	.LFBB30:
 2233               	/* prologue: function */
 2234               	/* frame size = 0 */
 341:util.c        ****   print_menu("MENU","advance","SET","set");
 2236               	.LM201:
 2237 0900 80E0      		ldi r24,lo8(__c.2217)
 2238 0902 90E0      		ldi r25,hi8(__c.2217)
 2239 0904 60E0      		ldi r22,lo8(__c.2219)
 2240 0906 70E0      		ldi r23,hi8(__c.2219)
 2241 0908 40E0      		ldi r20,lo8(__c.2221)
 2242 090a 50E0      		ldi r21,hi8(__c.2221)
 2243 090c 20E0      		ldi r18,lo8(__c.2223)
 2244 090e 30E0      		ldi r19,hi8(__c.2223)
 2245 0910 0E94 0000 		call PRINT_MENU
 2246               	/* epilogue start */
 344:util.c        **** }
 2248               	.LM202:
 2249 0914 0895      		ret
 2251               	.Lscope30:
 2253               		.stabd	78,0,0
 2259               	.global	drawbigdigit
 2261               	drawbigdigit:
 2262               		.stabd	46,0,0
 297:util.c        **** void drawbigdigit(uint8_t x, uint8_t y, uint8_t n, uint8_t inverted) {
 2264               	.LM203:
 2265               	.LFBB31:
 2266 0916 6F92      		push r6
 2267 0918 7F92      		push r7
 2268 091a 8F92      		push r8
 2269 091c 9F92      		push r9
 2270 091e AF92      		push r10
 2271 0920 BF92      		push r11
 2272 0922 CF92      		push r12
 2273 0924 DF92      		push r13
 2274 0926 EF92      		push r14
 2275 0928 FF92      		push r15
 2276 092a 0F93      		push r16
 2277 092c 1F93      		push r17
 2278 092e CF93      		push r28
 2279 0930 DF93      		push r29
 2280               	/* prologue: function */
 2281               	/* frame size = 0 */
 2282 0932 A82E      		mov r10,r24
 2283 0934 662E      		mov r6,r22
 2284 0936 722E      		mov r7,r18
 302:util.c        ****   if(displaystyle == STYLE_DEATH)
 2286               	.LM204:
 2287 0938 8091 0000 		lds r24,displaystyle
 2288 093c 833D      		cpi r24,lo8(-45)
 2289 093e 01F4      		brne .L154
 2290 0940 F3E0      		ldi r31,lo8(3)
 2291 0942 CF2E      		mov r12,r31
 2292 0944 E5E0      		ldi r30,lo8(5)
 2293 0946 DE2E      		mov r13,r30
 2294 0948 00C0      		rjmp .L155
 2295               	.L154:
 2296 094a 72E0      		ldi r23,lo8(2)
 2297 094c C72E      		mov r12,r23
 2298 094e 62E0      		ldi r22,lo8(2)
 2299 0950 D62E      		mov r13,r22
 2300               	.L155:
 2301 0952 C42F      		mov r28,r20
 2302 0954 D0E0      		ldi r29,lo8(0)
 2303 0956 CC0F      		lsl r28
 2304 0958 DD1F      		rol r29
 2305 095a CC0F      		lsl r28
 2306 095c DD1F      		rol r29
 2307 095e C050      		subi r28,lo8(-(BigFont))
 2308 0960 D040      		sbci r29,hi8(-(BigFont))
 2309 0962 BB24      		clr r11
 2310               	.L160:
 2311               	.LBB108:
 309:util.c        ****     uint8_t d = eeprom_read_byte(&BigFont[(n*4)+i]);
 2313               	.LM205:
 2314 0964 CE01      		movw r24,r28
 2315 0966 0E94 0000 		call __eerd_byte_m328p
 2316 096a 162D      		mov r17,r6
 2317 096c 47E0      		ldi r20,lo8(7)
 2318 096e E42E      		mov r14,r20
 2319 0970 F12C      		mov r15,__zero_reg__
 311:util.c        ****       if (d & _BV(7-j)) {
 2321               	.LM206:
 2322 0972 882E      		mov r8,r24
 2323 0974 9924      		clr r9
 2324               	.L159:
 2325 0976 C401      		movw r24,r8
 2326 0978 0E2C      		mov r0,r14
 2327 097a 00C0      		rjmp 2f
 2328 097c 9595      	1:	asr r25
 2329 097e 8795      		ror r24
 2330 0980 0A94      	2:	dec r0
 2331 0982 02F4      		brpl 1b
 2332 0984 80FF      		sbrs r24,0
 2333 0986 00C0      		rjmp .L156
 312:util.c        **** 	glcdFillRectangle(x+i*sizex, y+j*sizey, sizex, sizey, !inverted);
 2335               	.LM207:
 2336 0988 00E0      		ldi r16,lo8(0)
 2337 098a 7720      		tst r7
 2338 098c 01F4      		brne .L157
 2339 098e 01E0      		ldi r16,lo8(1)
 2340               	.L157:
 2341 0990 8A2D      		mov r24,r10
 2342 0992 612F      		mov r22,r17
 2343 0994 4C2D      		mov r20,r12
 2344 0996 2D2D      		mov r18,r13
 2345 0998 00C0      		rjmp .L164
 2346               	.L156:
 314:util.c        **** 	glcdFillRectangle(x+i*sizex, y+j*sizey, sizex, sizey, inverted);
 2348               	.LM208:
 2349 099a 8A2D      		mov r24,r10
 2350 099c 612F      		mov r22,r17
 2351 099e 4C2D      		mov r20,r12
 2352 09a0 2D2D      		mov r18,r13
 2353 09a2 072D      		mov r16,r7
 2354               	.L164:
 2355 09a4 0E94 0000 		call glcdFillRectangle
 2356 09a8 0894      		sec
 2357 09aa E108      		sbc r14,__zero_reg__
 2358 09ac F108      		sbc r15,__zero_reg__
 2359 09ae 1D0D      		add r17,r13
 310:util.c        ****     for (j=0; j<8; j++) {
 2361               	.LM209:
 2362 09b0 8FEF      		ldi r24,lo8(-1)
 2363 09b2 E816      		cp r14,r24
 2364 09b4 8FEF      		ldi r24,hi8(-1)
 2365 09b6 F806      		cpc r15,r24
 2366 09b8 01F4      		brne .L159
 2367               	.LBE108:
 308:util.c        ****   for (i = 0; i < 4; i++) {
 2369               	.LM210:
 2370 09ba B394      		inc r11
 2371 09bc 2196      		adiw r28,1
 2372 09be AC0C      		add r10,r12
 2373 09c0 84E0      		ldi r24,lo8(4)
 2374 09c2 B816      		cp r11,r24
 2375 09c4 01F4      		brne .L160
 2376               	/* epilogue start */
 318:util.c        **** }
 2378               	.LM211:
 2379 09c6 DF91      		pop r29
 2380 09c8 CF91      		pop r28
 2381 09ca 1F91      		pop r17
 2382 09cc 0F91      		pop r16
 2383 09ce FF90      		pop r15
 2384 09d0 EF90      		pop r14
 2385 09d2 DF90      		pop r13
 2386 09d4 CF90      		pop r12
 2387 09d6 BF90      		pop r11
 2388 09d8 AF90      		pop r10
 2389 09da 9F90      		pop r9
 2390 09dc 8F90      		pop r8
 2391 09de 7F90      		pop r7
 2392 09e0 6F90      		pop r6
 2393 09e2 0895      		ret
 2400               	.Lscope31:
 2402               		.stabd	78,0,0
 2403               	.global	rval
 2404               	.global	rval
 2405               		.section .bss
 2408               	rval:
 2409 0000 0000 0000 		.skip 8,0
 2409      0000 0000 
 2410               		.section	.progmem.data,"a",@progbits
 2413               	__c.2262:
 2414 0000 2074 6F20 		.string	" to "
 2414      00
 2417               	__c.2260:
 2418 0005 5072 6573 		.string	"Press "
 2418      7320 00
 2421               	__c.2247:
 2422 000c 5345 5400 		.string	"SET"
 2425               	__c.2245:
 2426 0010 2B00      		.string	"+"
 2429               	__c.2239:
 2430 0012 7361 7665 		.string	"save"
 2430      00
 2433               	__c.2237:
 2434 0017 6368 616E 		.string	"change"
 2434      6765 00
 2437               	__c.2233:
 2438 001e 7361 7665 		.string	"save"
 2438      00
 2441               	__c.2231:
 2442 0023 5345 5400 		.string	"SET"
 2445               	__c.2229:
 2446 0027 6578 6974 		.string	"exit"
 2446      00
 2449               	__c.2227:
 2450 002c 4D45 4E55 		.string	"MENU"
 2450      00
 2453               	__c.2223:
 2454 0031 7365 7400 		.string	"set"
 2457               	__c.2221:
 2458 0035 5345 5400 		.string	"SET"
 2461               	__c.2219:
 2462 0039 6164 7661 		.string	"advance"
 2462      6E63 6500 
 2465               	__c.2217:
 2466 0041 4D45 4E55 		.string	"MENU"
 2466      00
 2467               		.comm key,16,1
 2484               		.text
 2486               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 util.c
     /tmp/ccgaV6bq.s:2      *ABS*:0000003f __SREG__
     /tmp/ccgaV6bq.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccgaV6bq.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccgaV6bq.s:5      *ABS*:00000034 __CCP__
     /tmp/ccgaV6bq.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccgaV6bq.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccgaV6bq.s:139    .text:00000000 uart_init
     /tmp/ccgaV6bq.s:176    .text:0000001a delay_10us
     /tmp/ccgaV6bq.s:224    .text:0000002e delay_ms
     /tmp/ccgaV6bq.s:282    .text:00000048 delay_s
     /tmp/ccgaV6bq.s:378    .text:0000006c uart_putchar
     /tmp/ccgaV6bq.s:408    .text:00000080 uart_getchar
     /tmp/ccgaV6bq.s:435    .text:0000008e uart_getch
     /tmp/ccgaV6bq.s:459    .text:00000096 ROM_putstring
     /tmp/ccgaV6bq.s:550    .text:000000d8 uart_puts
     /tmp/ccgaV6bq.s:597    .text:000000f2 uart_putc_hex
     /tmp/ccgaV6bq.s:700    .text:00000144 uart_putw_hex
     /tmp/ccgaV6bq.s:730    .text:00000158 uart_putdw_hex
     /tmp/ccgaV6bq.s:769    .text:0000017e uart_putw_dec
     /tmp/ccgaV6bq.s:885    .text:000001f4 uart_put_dec
     /tmp/ccgaV6bq.s:1014   .text:00000270 uart_putdw_dec
     /tmp/ccgaV6bq.s:1183   .text:0000034e dotw
     /tmp/ccgaV6bq.s:1280   .text:000003d6 hours
     /tmp/ccgaV6bq.s:1314   .text:000003f6 encipher
     /tmp/ccgaV6bq.s:2408   .bss:00000000 rval
                            *COM*:00000010 key
     /tmp/ccgaV6bq.s:1535   .text:00000580 init_crand_consistent
     /tmp/ccgaV6bq.s:1642   .text:0000064a init_crand
     /tmp/ccgaV6bq.s:1667   .text:0000065c crand
     /tmp/ccgaV6bq.s:1774   .text:00000700 intersectrect
     /tmp/ccgaV6bq.s:1844   .text:00000754 add_month
     /tmp/ccgaV6bq.s:1942   .text:000007c6 check_timeout
     /tmp/ccgaV6bq.s:2024   .text:00000834 PRINT_MENU_LINE
     /tmp/ccgaV6bq.s:2417   .progmem.data:00000005 __c.2260
     /tmp/ccgaV6bq.s:2413   .progmem.data:00000000 __c.2262
     /tmp/ccgaV6bq.s:2084   .text:00000878 PRINT_MENU
     /tmp/ccgaV6bq.s:2146   .text:000008c8 PRINT_MENU_OPTS
     /tmp/ccgaV6bq.s:2425   .progmem.data:00000010 __c.2245
     /tmp/ccgaV6bq.s:2421   .progmem.data:0000000c __c.2247
     /tmp/ccgaV6bq.s:2174   .text:000008dc print_menu_change
     /tmp/ccgaV6bq.s:2433   .progmem.data:00000017 __c.2237
     /tmp/ccgaV6bq.s:2429   .progmem.data:00000012 __c.2239
     /tmp/ccgaV6bq.s:2199   .text:000008ea print_menu_exit
     /tmp/ccgaV6bq.s:2449   .progmem.data:0000002c __c.2227
     /tmp/ccgaV6bq.s:2445   .progmem.data:00000027 __c.2229
     /tmp/ccgaV6bq.s:2441   .progmem.data:00000023 __c.2231
     /tmp/ccgaV6bq.s:2437   .progmem.data:0000001e __c.2233
     /tmp/ccgaV6bq.s:2228   .text:00000900 print_menu_advance
     /tmp/ccgaV6bq.s:2465   .progmem.data:00000041 __c.2217
     /tmp/ccgaV6bq.s:2461   .progmem.data:00000039 __c.2219
     /tmp/ccgaV6bq.s:2457   .progmem.data:00000035 __c.2221
     /tmp/ccgaV6bq.s:2453   .progmem.data:00000031 __c.2223
     /tmp/ccgaV6bq.s:2261   .text:00000916 drawbigdigit

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__udivmodhi4
__udivmodsi4
__mulsi3
time_format
__divmodhi4
time_h
time_m
time_s
leapyear
displaymode
displaystyle
screenmutex
print_time
just_pressed
pressed
timeoutcounter
glcdSetAddress
glcdPutStr_rom
glcdFillRectangle
BigFont
__eerd_byte_m328p
