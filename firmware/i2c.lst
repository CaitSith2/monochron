   1               		.file	"i2c.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  12               		.text
  13               	.Ltext0:
 117               	.global	i2cInit
 119               	i2cInit:
 120               		.stabd	46,0,0
   0:i2c.c         **** /*! \file i2c.c \brief I2C interface using AVR Two-Wire Interface (TWI) hardware. */
   1:i2c.c         **** //*****************************************************************************
   2:i2c.c         **** //
   3:i2c.c         **** // File Name	: 'i2c.c'
   4:i2c.c         **** // Title		: I2C interface using AVR Two-Wire Interface (TWI) hardware
   5:i2c.c         **** // Author		: Pascal Stang - Copyright (C) 2002-2003
   6:i2c.c         **** // Created		: 2002.06.25
   7:i2c.c         **** // Revised		: 2003.03.02
   8:i2c.c         **** // Version		: 0.9
   9:i2c.c         **** // Target MCU	: Atmel AVR series
  10:i2c.c         **** // Editor Tabs	: 4
  11:i2c.c         **** //
  12:i2c.c         **** // This code is distributed under the GNU Public License
  13:i2c.c         **** //		which can be found at http://www.gnu.org/licenses/gpl.txt
  14:i2c.c         **** //
  15:i2c.c         **** //*****************************************************************************
  16:i2c.c         **** 
  17:i2c.c         **** #include <avr/io.h>
  18:i2c.c         **** #include <avr/interrupt.h>
  19:i2c.c         **** 
  20:i2c.c         **** #include "i2c.h"
  21:i2c.c         **** #include "util.h"
  22:i2c.c         **** 
  23:i2c.c         **** // Standard I2C bit rates are:
  24:i2c.c         **** // 100KHz for slow speed
  25:i2c.c         **** // 400KHz for high speed
  26:i2c.c         **** 
  27:i2c.c         **** #define I2C_DEBUG 1
  28:i2c.c         **** 
  29:i2c.c         **** // I2C state and address variables
  30:i2c.c         **** static volatile eI2cStateType I2cState;
  31:i2c.c         **** /*static u08 I2cDeviceAddrRW;
  32:i2c.c         **** // send/transmit buffer (outgoing data)
  33:i2c.c         **** static u08 I2cSendData[I2C_SEND_DATA_BUFFER_SIZE];
  34:i2c.c         **** static u08 I2cSendDataIndex;
  35:i2c.c         **** static u08 I2cSendDataLength;
  36:i2c.c         **** // receive buffer (incoming data)
  37:i2c.c         **** static u08 I2cReceiveData[I2C_RECEIVE_DATA_BUFFER_SIZE];
  38:i2c.c         **** static u08 I2cReceiveDataIndex;
  39:i2c.c         **** static u08 I2cReceiveDataLength;*/
  40:i2c.c         **** 
  41:i2c.c         **** // function pointer to i2c receive routine
  42:i2c.c         **** //! I2cSlaveReceive is called when this processor
  43:i2c.c         **** // is addressed as a slave for writing
  44:i2c.c         **** static void (*i2cSlaveReceive)(u08 receiveDataLength, u08* recieveData);
  45:i2c.c         **** //! I2cSlaveTransmit is called when this processor
  46:i2c.c         **** // is addressed as a slave for reading
  47:i2c.c         **** static u08 (*i2cSlaveTransmit)(u08 transmitDataLengthMax, u08* transmitData);
  48:i2c.c         **** 
  49:i2c.c         **** // functions
  50:i2c.c         **** void i2cInit(void)
  51:i2c.c         **** {
 122               	.LM0:
 123               	.LFBB1:
 124               	/* prologue: function */
 125               	/* frame size = 0 */
  52:i2c.c         **** 	// set pull-up resistors on I2C bus pins
  53:i2c.c         **** 	// TODO: should #ifdef these
  54:i2c.c         **** 	sbi(PORTC, 5);	// i2c SCL on ATmegaxx8
 127               	.LM1:
 128 0000 459A      		sbi 40-32,5
  55:i2c.c         **** 	sbi(PORTC, 4);	// i2c SDA on ATmegaxx8
 130               	.LM2:
 131 0002 449A      		sbi 40-32,4
  56:i2c.c         **** 
  57:i2c.c         **** 	// clear SlaveReceive and SlaveTransmit handler to null
  58:i2c.c         **** 	i2cSlaveReceive = 0;
 133               	.LM3:
 134 0004 1092 0000 		sts (i2cSlaveReceive)+1,__zero_reg__
 135 0008 1092 0000 		sts i2cSlaveReceive,__zero_reg__
  59:i2c.c         **** 	i2cSlaveTransmit = 0;
 137               	.LM4:
 138 000c 1092 0000 		sts (i2cSlaveTransmit)+1,__zero_reg__
 139 0010 1092 0000 		sts i2cSlaveTransmit,__zero_reg__
 140               	.LBB40:
 141               	.LBB41:
  60:i2c.c         **** 	// set i2c bit rate to 100KHz
  61:i2c.c         **** 	i2cSetBitrate(100);
  62:i2c.c         **** 	// enable TWI (two-wire interface)
  63:i2c.c         **** 	sbi(TWCR, TWEN);
  64:i2c.c         **** 	// set state
  65:i2c.c         **** 	I2cState = I2C_IDLE;
  66:i2c.c         **** 	// enable TWI interrupt and slave address ACK
  67:i2c.c         **** 	sbi(TWCR, TWIE);
  68:i2c.c         **** 	sbi(TWCR, TWEA);
  69:i2c.c         **** 	//outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
  70:i2c.c         **** 	// enable interrupts
  71:i2c.c         **** 	sei();
  72:i2c.c         **** }
  73:i2c.c         **** 
  74:i2c.c         **** void i2cSetBitrate(u16 bitrate)
  75:i2c.c         **** {
  76:i2c.c         **** 	u08 bitrate_div;
  77:i2c.c         **** 	// set i2c bitrate
  78:i2c.c         **** 	// SCL freq = F_CPU/(16+2*TWBR))
  79:i2c.c         **** 	/*
  80:i2c.c         **** 	#ifdef TWPS0
  81:i2c.c         **** 		// for processors with additional bitrate division (mega128)
  82:i2c.c         **** 		// SCL freq = F_CPU/(16+2*TWBR*4^TWPS)
  83:i2c.c         **** 		// set TWPS to zero
  84:i2c.c         **** 		cbi(TWSR, TWPS0);
  85:i2c.c         **** 		cbi(TWSR, TWPS1);
  86:i2c.c         **** 	#endif
  87:i2c.c         **** 	*/
  88:i2c.c         **** 
  89:i2c.c         **** 	// calculate bitrate division	
  90:i2c.c         **** 	bitrate_div = (F_CPU/32)/bitrate;
  91:i2c.c         **** 	//outb(TWBR, bitrate_div);
  92:i2c.c         **** 	TWBR = 32;
 143               	.LM5:
 144 0014 80E2      		ldi r24,lo8(32)
 145 0016 8093 B800 		sts 184,r24
 146               	.LBE41:
 147               	.LBE40:
  64:i2c.c         **** 	sbi(TWCR, TWEN);
 149               	.LM6:
 150 001a ECEB      		ldi r30,lo8(188)
 151 001c F0E0      		ldi r31,hi8(188)
 152 001e 8081      		ld r24,Z
 153 0020 8460      		ori r24,lo8(4)
 154 0022 8083      		st Z,r24
  66:i2c.c         **** 	I2cState = I2C_IDLE;
 156               	.LM7:
 157 0024 1092 0000 		sts I2cState,__zero_reg__
  68:i2c.c         **** 	sbi(TWCR, TWIE);
 159               	.LM8:
 160 0028 8081      		ld r24,Z
 161 002a 8160      		ori r24,lo8(1)
 162 002c 8083      		st Z,r24
  69:i2c.c         **** 	sbi(TWCR, TWEA);
 164               	.LM9:
 165 002e 8081      		ld r24,Z
 166 0030 8064      		ori r24,lo8(64)
 167 0032 8083      		st Z,r24
  72:i2c.c         **** 	sei();
 169               	.LM10:
 170               	/* #APP */
 171               	 ;  72 "i2c.c" 1
 172 0034 7894      		sei
 173               	 ;  0 "" 2
 174               	/* epilogue start */
  73:i2c.c         **** }
 176               	.LM11:
 177               	/* #NOAPP */
 178 0036 0895      		ret
 180               	.Lscope1:
 182               		.stabd	78,0,0
 185               	.global	i2cSetBitrate
 187               	i2cSetBitrate:
 188               		.stabd	46,0,0
  76:i2c.c         **** {
 190               	.LM12:
 191               	.LFBB2:
 192               	/* prologue: function */
 193               	/* frame size = 0 */
 195               	.LM13:
 196 0038 80E2      		ldi r24,lo8(32)
 197 003a 8093 B800 		sts 184,r24
 198               	/* epilogue start */
  93:i2c.c         **** }
 200               	.LM14:
 201 003e 0895      		ret
 203               	.Lscope2:
 205               		.stabd	78,0,0
 207               	.global	i2cSendStart
 209               	i2cSendStart:
 210               		.stabd	46,0,0
  94:i2c.c         **** /*
  95:i2c.c         **** void i2cSetLocalDeviceAddr(u08 deviceAddr, u08 genCallEn)
  96:i2c.c         **** {
  97:i2c.c         **** 	// set local device address (used in slave mode only)
  98:i2c.c         **** 	outb(TWAR, ((deviceAddr&0xFE) | (genCallEn?1:0)) );
  99:i2c.c         **** }
 100:i2c.c         **** 
 101:i2c.c         **** void i2cSetSlaveReceiveHandler(void (*i2cSlaveRx_func)(u08 receiveDataLength, u08* recieveData))
 102:i2c.c         **** {
 103:i2c.c         **** 	i2cSlaveReceive = i2cSlaveRx_func;
 104:i2c.c         **** }
 105:i2c.c         **** 
 106:i2c.c         **** void i2cSetSlaveTransmitHandler(u08 (*i2cSlaveTx_func)(u08 transmitDataLengthMax, u08* transmitData
 107:i2c.c         **** {
 108:i2c.c         **** 	i2cSlaveTransmit = i2cSlaveTx_func;
 109:i2c.c         **** }*/
 110:i2c.c         **** 
 111:i2c.c         **** inline void i2cSendStart(void)
 112:i2c.c         **** {
 212               	.LM15:
 213               	.LFBB3:
 214               	/* prologue: function */
 215               	/* frame size = 0 */
 113:i2c.c         **** 	// send start condition
 114:i2c.c         **** 	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
 217               	.LM16:
 218 0040 ECEB      		ldi r30,lo8(188)
 219 0042 F0E0      		ldi r31,hi8(188)
 220 0044 8081      		ld r24,Z
 221 0046 8F70      		andi r24,lo8(15)
 222 0048 806A      		ori r24,lo8(-96)
 223 004a 8083      		st Z,r24
 224               	/* epilogue start */
 115:i2c.c         **** }
 226               	.LM17:
 227 004c 0895      		ret
 229               	.Lscope3:
 231               		.stabd	78,0,0
 233               	.global	i2cSendStop
 235               	i2cSendStop:
 236               		.stabd	46,0,0
 116:i2c.c         **** 
 117:i2c.c         **** inline void i2cSendStop(void)
 118:i2c.c         **** {
 238               	.LM18:
 239               	.LFBB4:
 240               	/* prologue: function */
 241               	/* frame size = 0 */
 119:i2c.c         **** 	// transmit stop condition
 120:i2c.c         **** 	// leave with TWEA on for slave receiving
 121:i2c.c         **** 	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
 243               	.LM19:
 244 004e ECEB      		ldi r30,lo8(188)
 245 0050 F0E0      		ldi r31,hi8(188)
 246 0052 8081      		ld r24,Z
 247 0054 8F70      		andi r24,lo8(15)
 248 0056 806D      		ori r24,lo8(-48)
 249 0058 8083      		st Z,r24
 250               	/* epilogue start */
 122:i2c.c         **** }
 252               	.LM20:
 253 005a 0895      		ret
 255               	.Lscope4:
 257               		.stabd	78,0,0
 259               	.global	i2cWaitForComplete
 261               	i2cWaitForComplete:
 262               		.stabd	46,0,0
 123:i2c.c         **** 
 124:i2c.c         **** inline void i2cWaitForComplete(void)
 125:i2c.c         **** {
 264               	.LM21:
 265               	.LFBB5:
 266               	/* prologue: function */
 267               	/* frame size = 0 */
 268               	.L10:
 126:i2c.c         **** 	// wait for i2c interface to complete operation
 127:i2c.c         **** 	while( !(inb(TWCR) & BV(TWINT)) );
 270               	.LM22:
 271 005c 8091 BC00 		lds r24,188
 272 0060 87FF      		sbrs r24,7
 273 0062 00C0      		rjmp .L10
 274               	/* epilogue start */
 128:i2c.c         **** }
 276               	.LM23:
 277 0064 0895      		ret
 279               	.Lscope5:
 281               		.stabd	78,0,0
 284               	.global	i2cSendByte
 286               	i2cSendByte:
 287               		.stabd	46,0,0
 129:i2c.c         **** 
 130:i2c.c         **** inline void i2cSendByte(u08 data)
 131:i2c.c         **** {
 289               	.LM24:
 290               	.LFBB6:
 291               	/* prologue: function */
 292               	/* frame size = 0 */
 132:i2c.c         **** 	// save data to the TWDR
 133:i2c.c         **** 	outb(TWDR, data);
 294               	.LM25:
 295 0066 8093 BB00 		sts 187,r24
 134:i2c.c         **** 	// begin send
 135:i2c.c         **** 	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
 297               	.LM26:
 298 006a ECEB      		ldi r30,lo8(188)
 299 006c F0E0      		ldi r31,hi8(188)
 300 006e 8081      		ld r24,Z
 301 0070 8F70      		andi r24,lo8(15)
 302 0072 8068      		ori r24,lo8(-128)
 303 0074 8083      		st Z,r24
 304               	/* epilogue start */
 136:i2c.c         **** }
 306               	.LM27:
 307 0076 0895      		ret
 309               	.Lscope6:
 311               		.stabd	78,0,0
 314               	.global	i2cReceiveByte
 316               	i2cReceiveByte:
 317               		.stabd	46,0,0
 137:i2c.c         **** 
 138:i2c.c         **** inline void i2cReceiveByte(u08 ackFlag)
 139:i2c.c         **** {
 319               	.LM28:
 320               	.LFBB7:
 321               	/* prologue: function */
 322               	/* frame size = 0 */
 140:i2c.c         **** 	// begin receive over i2c
 141:i2c.c         **** 	if( ackFlag )
 324               	.LM29:
 325 0078 8823      		tst r24
 326 007a 01F0      		breq .L16
 142:i2c.c         **** 	{
 143:i2c.c         **** 		// ackFlag = TRUE: ACK the recevied data
 144:i2c.c         **** 		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
 328               	.LM30:
 329 007c 8091 BC00 		lds r24,188
 330 0080 8F70      		andi r24,lo8(15)
 331 0082 806C      		ori r24,lo8(-64)
 332 0084 00C0      		rjmp .L19
 333               	.L16:
 145:i2c.c         **** 	}
 146:i2c.c         **** 	else
 147:i2c.c         **** 	{
 148:i2c.c         **** 		// ackFlag = FALSE: NACK the recevied data
 149:i2c.c         **** 		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
 335               	.LM31:
 336 0086 8091 BC00 		lds r24,188
 337 008a 8F70      		andi r24,lo8(15)
 338 008c 8068      		ori r24,lo8(-128)
 339               	.L19:
 340 008e 8093 BC00 		sts 188,r24
 341 0092 0895      		ret
 343               	.Lscope7:
 345               		.stabd	78,0,0
 347               	.global	i2cGetReceivedByte
 349               	i2cGetReceivedByte:
 350               		.stabd	46,0,0
 150:i2c.c         **** 	}
 151:i2c.c         **** }
 152:i2c.c         **** 
 153:i2c.c         **** inline u08 i2cGetReceivedByte(void)
 154:i2c.c         **** {
 352               	.LM32:
 353               	.LFBB8:
 354               	/* prologue: function */
 355               	/* frame size = 0 */
 155:i2c.c         **** 	// retieve received data byte from i2c TWDR
 156:i2c.c         **** 	return( inb(TWDR) );
 357               	.LM33:
 358 0094 8091 BB00 		lds r24,187
 359               	/* epilogue start */
 157:i2c.c         **** }
 361               	.LM34:
 362 0098 0895      		ret
 364               	.Lscope8:
 366               		.stabd	78,0,0
 368               	.global	i2cGetStatus
 370               	i2cGetStatus:
 371               		.stabd	46,0,0
 158:i2c.c         **** 
 159:i2c.c         **** inline u08 i2cGetStatus(void)
 160:i2c.c         **** {
 373               	.LM35:
 374               	.LFBB9:
 375               	/* prologue: function */
 376               	/* frame size = 0 */
 161:i2c.c         **** 	// retieve current i2c status from i2c TWSR
 162:i2c.c         **** 	return( inb(TWSR) );
 378               	.LM36:
 379 009a 8091 B900 		lds r24,185
 380               	/* epilogue start */
 163:i2c.c         **** }
 382               	.LM37:
 383 009e 0895      		ret
 385               	.Lscope9:
 387               		.stabd	78,0,0
 392               	.global	i2cMasterSendNI
 394               	i2cMasterSendNI:
 395               		.stabd	46,0,0
 164:i2c.c         **** /*
 165:i2c.c         **** void i2cMasterSend(u08 deviceAddr, u08 length, u08* data)
 166:i2c.c         **** {
 167:i2c.c         **** 	u08 i;
 168:i2c.c         **** 	// wait for interface to be ready
 169:i2c.c         **** 	while(I2cState);
 170:i2c.c         **** 	// set state
 171:i2c.c         **** 	I2cState = I2C_MASTER_TX;
 172:i2c.c         **** 	// save data
 173:i2c.c         **** 	I2cDeviceAddrRW = (deviceAddr & 0xFE);	// RW cleared: write operation
 174:i2c.c         **** 	for(i=0; i<length; i++)
 175:i2c.c         **** 		I2cSendData[i] = *data++;
 176:i2c.c         **** 	I2cSendDataIndex = 0;
 177:i2c.c         **** 	I2cSendDataLength = length;
 178:i2c.c         **** 	// send start condition
 179:i2c.c         **** 	i2cSendStart();
 180:i2c.c         **** }
 181:i2c.c         **** 
 182:i2c.c         **** void i2cMasterReceive(u08 deviceAddr, u08 length, u08* data)
 183:i2c.c         **** {
 184:i2c.c         **** 	u08 i;
 185:i2c.c         **** 	// wait for interface to be ready
 186:i2c.c         **** 	while(I2cState);
 187:i2c.c         **** 	// set state
 188:i2c.c         **** 	I2cState = I2C_MASTER_RX;
 189:i2c.c         **** 	// save data
 190:i2c.c         **** 	I2cDeviceAddrRW = (deviceAddr|0x01);	// RW set: read operation
 191:i2c.c         **** 	I2cReceiveDataIndex = 0;
 192:i2c.c         **** 	I2cReceiveDataLength = length;
 193:i2c.c         **** 	// send start condition
 194:i2c.c         **** 	i2cSendStart();
 195:i2c.c         **** 	// wait for data
 196:i2c.c         **** 	while(I2cState);
 197:i2c.c         **** 	// return data
 198:i2c.c         **** 	for(i=0; i<length; i++)
 199:i2c.c         **** 	  *data++ = I2cReceiveData[i];
 200:i2c.c         **** }*/
 201:i2c.c         **** 
 202:i2c.c         **** u08 i2cMasterSendNI(u08 deviceAddr, u08 length, u08* data)
 203:i2c.c         **** {
 397               	.LM38:
 398               	.LFBB10:
 399               	/* prologue: function */
 400               	/* frame size = 0 */
 401 00a0 982F      		mov r25,r24
 402 00a2 FA01      		movw r30,r20
 204:i2c.c         **** 	u08 retval = I2C_OK;
 205:i2c.c         **** 
 206:i2c.c         **** 	// disable TWI interrupt
 207:i2c.c         **** 	cbi(TWCR, TWIE);
 404               	.LM39:
 405 00a4 8091 BC00 		lds r24,188
 406 00a8 8E7F      		andi r24,lo8(-2)
 407 00aa 8093 BC00 		sts 188,r24
 408               	.LBB42:
 409               	.LBB43:
 115:i2c.c         **** 	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
 411               	.LM40:
 412 00ae 8091 BC00 		lds r24,188
 413 00b2 8F70      		andi r24,lo8(15)
 414 00b4 806A      		ori r24,lo8(-96)
 415 00b6 8093 BC00 		sts 188,r24
 416               	.L25:
 417               	.LBE43:
 418               	.LBE42:
 419               	.LBB44:
 420               	.LBB45:
 128:i2c.c         **** 	while( !(inb(TWCR) & BV(TWINT)) );
 422               	.LM41:
 423 00ba 8091 BC00 		lds r24,188
 424 00be 87FF      		sbrs r24,7
 425 00c0 00C0      		rjmp .L25
 426               	.LBE45:
 427               	.LBE44:
 208:i2c.c         **** 
 209:i2c.c         **** 	// send start condition
 210:i2c.c         **** 	i2cSendStart();
 211:i2c.c         **** 	i2cWaitForComplete();
 212:i2c.c         **** 
 213:i2c.c         **** 	// send device address with write
 214:i2c.c         **** 	i2cSendByte( deviceAddr & 0xFE );
 429               	.LM42:
 430 00c2 9E7F      		andi r25,lo8(-2)
 431               	.LBB46:
 432               	.LBB47:
 134:i2c.c         **** 	outb(TWDR, data);
 434               	.LM43:
 435 00c4 9093 BB00 		sts 187,r25
 136:i2c.c         **** 	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
 437               	.LM44:
 438 00c8 8091 BC00 		lds r24,188
 439 00cc 8F70      		andi r24,lo8(15)
 440 00ce 8068      		ori r24,lo8(-128)
 441 00d0 8093 BC00 		sts 188,r24
 442               	.L26:
 443               	.LBE47:
 444               	.LBE46:
 445               	.LBB48:
 446               	.LBB49:
 128:i2c.c         **** 	while( !(inb(TWCR) & BV(TWINT)) );
 448               	.LM45:
 449 00d4 8091 BC00 		lds r24,188
 450 00d8 87FF      		sbrs r24,7
 451 00da 00C0      		rjmp .L26
 452               	.LBE49:
 453               	.LBE48:
 215:i2c.c         **** 	i2cWaitForComplete();
 216:i2c.c         **** 
 217:i2c.c         **** 	// check if device is present and live
 218:i2c.c         **** 	if( inb(TWSR) == TW_MT_SLA_ACK)
 455               	.LM46:
 456 00dc 8091 B900 		lds r24,185
 457 00e0 8831      		cpi r24,lo8(24)
 458 00e2 01F0      		breq .L37
 459 00e4 91E0      		ldi r25,lo8(1)
 460 00e6 00C0      		rjmp .L28
 461               	.L30:
 219:i2c.c         **** 	{
 220:i2c.c         **** 		// send data
 221:i2c.c         **** 		while(length)
 222:i2c.c         **** 		{
 223:i2c.c         **** 			i2cSendByte( *data++ );
 463               	.LM47:
 464 00e8 8081      		ld r24,Z
 465               	.LBB50:
 466               	.LBB51:
 134:i2c.c         **** 	outb(TWDR, data);
 468               	.LM48:
 469 00ea 8093 BB00 		sts 187,r24
 136:i2c.c         **** 	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
 471               	.LM49:
 472 00ee 8091 BC00 		lds r24,188
 473 00f2 8F70      		andi r24,lo8(15)
 474 00f4 8068      		ori r24,lo8(-128)
 475 00f6 8093 BC00 		sts 188,r24
 476               	.L29:
 477               	.LBE51:
 478               	.LBE50:
 479               	.LBB52:
 480               	.LBB53:
 128:i2c.c         **** 	while( !(inb(TWCR) & BV(TWINT)) );
 482               	.LM50:
 483 00fa 8091 BC00 		lds r24,188
 484 00fe 87FF      		sbrs r24,7
 485 0100 00C0      		rjmp .L29
 486               	.LBE53:
 487               	.LBE52:
 489               	.LM51:
 490 0102 3196      		adiw r30,1
 224:i2c.c         **** 			i2cWaitForComplete();
 225:i2c.c         **** 			length--;
 492               	.LM52:
 493 0104 6150      		subi r22,lo8(-(-1))
 494               	.L37:
 222:i2c.c         **** 		while(length)
 496               	.LM53:
 497 0106 6623      		tst r22
 498 0108 01F4      		brne .L30
 499 010a 90E0      		ldi r25,lo8(0)
 500               	.L28:
 501               	.LBB54:
 502               	.LBB55:
 122:i2c.c         **** 	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
 504               	.LM54:
 505 010c 8091 BC00 		lds r24,188
 506 0110 8F70      		andi r24,lo8(15)
 507 0112 806D      		ori r24,lo8(-48)
 508 0114 8093 BC00 		sts 188,r24
 509               	.L31:
 510               	.LBE55:
 511               	.LBE54:
 226:i2c.c         **** 		}
 227:i2c.c         **** 	}
 228:i2c.c         **** 	else
 229:i2c.c         **** 	{
 230:i2c.c         **** 		// device did not ACK it's address,
 231:i2c.c         **** 		// data will not be transferred
 232:i2c.c         **** 		// return error
 233:i2c.c         **** 		retval = I2C_ERROR_NODEV;
 234:i2c.c         **** 	}
 235:i2c.c         **** 
 236:i2c.c         **** 	// transmit stop condition
 237:i2c.c         **** 	// leave with TWEA on for slave receiving
 238:i2c.c         **** 	i2cSendStop();
 239:i2c.c         **** 	while( !(inb(TWCR) & BV(TWSTO)) );
 513               	.LM55:
 514 0118 8091 BC00 		lds r24,188
 515 011c 84FF      		sbrs r24,4
 516 011e 00C0      		rjmp .L31
 240:i2c.c         **** 
 241:i2c.c         **** 	// enable TWI interrupt
 242:i2c.c         **** 	sbi(TWCR, TWIE);
 518               	.LM56:
 519 0120 8091 BC00 		lds r24,188
 520 0124 8160      		ori r24,lo8(1)
 521 0126 8093 BC00 		sts 188,r24
 243:i2c.c         **** 
 244:i2c.c         **** 	return retval;
 245:i2c.c         **** }
 523               	.LM57:
 524 012a 892F      		mov r24,r25
 525               	/* epilogue start */
 526 012c 0895      		ret
 531               	.Lscope10:
 533               		.stabd	78,0,0
 538               	.global	i2cMasterReceiveNI
 540               	i2cMasterReceiveNI:
 541               		.stabd	46,0,0
 246:i2c.c         **** 
 247:i2c.c         **** u08 i2cMasterReceiveNI(u08 deviceAddr, u08 length, u08 *data)
 248:i2c.c         **** {
 543               	.LM58:
 544               	.LFBB11:
 545               	/* prologue: function */
 546               	/* frame size = 0 */
 547 012e 982F      		mov r25,r24
 548 0130 FA01      		movw r30,r20
 249:i2c.c         **** 	u08 retval = I2C_OK;
 250:i2c.c         **** 
 251:i2c.c         **** 	// disable TWI interrupt
 252:i2c.c         **** 	cbi(TWCR, TWIE);
 550               	.LM59:
 551 0132 8091 BC00 		lds r24,188
 552 0136 8E7F      		andi r24,lo8(-2)
 553 0138 8093 BC00 		sts 188,r24
 554               	.LBB56:
 555               	.LBB57:
 115:i2c.c         **** 	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWSTA));
 557               	.LM60:
 558 013c 8091 BC00 		lds r24,188
 559 0140 8F70      		andi r24,lo8(15)
 560 0142 806A      		ori r24,lo8(-96)
 561 0144 8093 BC00 		sts 188,r24
 562               	.L39:
 563               	.LBE57:
 564               	.LBE56:
 565               	.LBB58:
 566               	.LBB59:
 128:i2c.c         **** 	while( !(inb(TWCR) & BV(TWINT)) );
 568               	.LM61:
 569 0148 8091 BC00 		lds r24,188
 570 014c 87FF      		sbrs r24,7
 571 014e 00C0      		rjmp .L39
 572               	.LBE59:
 573               	.LBE58:
 253:i2c.c         **** 
 254:i2c.c         **** 	// send start condition
 255:i2c.c         **** 	i2cSendStart();
 256:i2c.c         **** 	i2cWaitForComplete();
 257:i2c.c         **** 
 258:i2c.c         **** 	// send device address with read
 259:i2c.c         **** 	i2cSendByte( deviceAddr | 0x01 );
 575               	.LM62:
 576 0150 9160      		ori r25,lo8(1)
 577               	.LBB60:
 578               	.LBB61:
 134:i2c.c         **** 	outb(TWDR, data);
 580               	.LM63:
 581 0152 9093 BB00 		sts 187,r25
 136:i2c.c         **** 	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
 583               	.LM64:
 584 0156 8091 BC00 		lds r24,188
 585 015a 8F70      		andi r24,lo8(15)
 586 015c 8068      		ori r24,lo8(-128)
 587 015e 8093 BC00 		sts 188,r24
 588               	.L40:
 589               	.LBE61:
 590               	.LBE60:
 591               	.LBB62:
 592               	.LBB63:
 128:i2c.c         **** 	while( !(inb(TWCR) & BV(TWINT)) );
 594               	.LM65:
 595 0162 8091 BC00 		lds r24,188
 596 0166 87FF      		sbrs r24,7
 597 0168 00C0      		rjmp .L40
 598               	.LBE63:
 599               	.LBE62:
 260:i2c.c         **** 	i2cWaitForComplete();
 261:i2c.c         **** 
 262:i2c.c         **** 	// check if device is present and live
 263:i2c.c         **** 	if( inb(TWSR) == TW_MR_SLA_ACK)
 601               	.LM66:
 602 016a 8091 B900 		lds r24,185
 603 016e 8034      		cpi r24,lo8(64)
 604 0170 01F0      		breq .L51
 605 0172 91E0      		ldi r25,lo8(1)
 606 0174 00C0      		rjmp .L42
 607               	.L44:
 608               	.LBB64:
 609               	.LBB65:
 145:i2c.c         **** 		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA));
 611               	.LM67:
 612 0176 8091 BC00 		lds r24,188
 613 017a 8F70      		andi r24,lo8(15)
 614 017c 806C      		ori r24,lo8(-64)
 615 017e 8093 BC00 		sts 188,r24
 616               	.L43:
 617               	.LBE65:
 618               	.LBE64:
 619               	.LBB66:
 620               	.LBB67:
 128:i2c.c         **** 	while( !(inb(TWCR) & BV(TWINT)) );
 622               	.LM68:
 623 0182 8091 BC00 		lds r24,188
 624 0186 87FF      		sbrs r24,7
 625 0188 00C0      		rjmp .L43
 626               	.LBE67:
 627               	.LBE66:
 628               	.LBB68:
 629               	.LBB69:
 157:i2c.c         **** 	return( inb(TWDR) );
 631               	.LM69:
 632 018a 8091 BB00 		lds r24,187
 633               	.LBE69:
 634               	.LBE68:
 264:i2c.c         **** 	{
 265:i2c.c         **** 		// accept receive data and ack it
 266:i2c.c         **** 		while(length > 1)
 267:i2c.c         **** 		{
 268:i2c.c         **** 			i2cReceiveByte(TRUE);
 269:i2c.c         **** 			i2cWaitForComplete();
 270:i2c.c         **** 			*data++ = i2cGetReceivedByte();
 636               	.LM70:
 637 018e 8193      		st Z+,r24
 271:i2c.c         **** 			// decrement length
 272:i2c.c         **** 			length--;
 639               	.LM71:
 640 0190 6150      		subi r22,lo8(-(-1))
 641               	.L51:
 267:i2c.c         **** 		while(length > 1)
 643               	.LM72:
 644 0192 6230      		cpi r22,lo8(2)
 645 0194 00F4      		brsh .L44
 646               	.LBB70:
 647               	.LBB71:
 150:i2c.c         **** 		outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT));
 649               	.LM73:
 650 0196 8091 BC00 		lds r24,188
 651 019a 8F70      		andi r24,lo8(15)
 652 019c 8068      		ori r24,lo8(-128)
 653 019e 8093 BC00 		sts 188,r24
 654               	.L45:
 655               	.LBE71:
 656               	.LBE70:
 657               	.LBB72:
 658               	.LBB73:
 128:i2c.c         **** 	while( !(inb(TWCR) & BV(TWINT)) );
 660               	.LM74:
 661 01a2 8091 BC00 		lds r24,188
 662 01a6 87FF      		sbrs r24,7
 663 01a8 00C0      		rjmp .L45
 664               	.LBE73:
 665               	.LBE72:
 666               	.LBB74:
 667               	.LBB75:
 157:i2c.c         **** 	return( inb(TWDR) );
 669               	.LM75:
 670 01aa 8091 BB00 		lds r24,187
 671               	.LBE75:
 672               	.LBE74:
 273:i2c.c         **** 		}
 274:i2c.c         **** 
 275:i2c.c         **** 		// accept receive data and nack it (last-byte signal)
 276:i2c.c         **** 		i2cReceiveByte(FALSE);
 277:i2c.c         **** 		i2cWaitForComplete();
 278:i2c.c         **** 		*data++ = i2cGetReceivedByte();
 674               	.LM76:
 675 01ae 8083      		st Z,r24
 676 01b0 90E0      		ldi r25,lo8(0)
 677               	.L42:
 678               	.LBB76:
 679               	.LBB77:
 122:i2c.c         **** 	outb(TWCR, (inb(TWCR)&TWCR_CMD_MASK)|BV(TWINT)|BV(TWEA)|BV(TWSTO));
 681               	.LM77:
 682 01b2 8091 BC00 		lds r24,188
 683 01b6 8F70      		andi r24,lo8(15)
 684 01b8 806D      		ori r24,lo8(-48)
 685 01ba 8093 BC00 		sts 188,r24
 686               	.LBE77:
 687               	.LBE76:
 279:i2c.c         **** 	}
 280:i2c.c         **** 	else
 281:i2c.c         **** 	{
 282:i2c.c         **** 		// device did not ACK it's address,
 283:i2c.c         **** 		// data will not be transferred
 284:i2c.c         **** 		// return error
 285:i2c.c         **** 		retval = I2C_ERROR_NODEV;
 286:i2c.c         **** 	}
 287:i2c.c         **** 
 288:i2c.c         **** 	// transmit stop condition
 289:i2c.c         **** 	// leave with TWEA on for slave receiving
 290:i2c.c         **** 	i2cSendStop();
 291:i2c.c         **** 
 292:i2c.c         **** 	// enable TWI interrupt
 293:i2c.c         **** 	sbi(TWCR, TWIE);
 689               	.LM78:
 690 01be 8091 BC00 		lds r24,188
 691 01c2 8160      		ori r24,lo8(1)
 692 01c4 8093 BC00 		sts 188,r24
 294:i2c.c         **** 
 295:i2c.c         **** 	return retval;
 296:i2c.c         **** }
 694               	.LM79:
 695 01c8 892F      		mov r24,r25
 696               	/* epilogue start */
 697 01ca 0895      		ret
 702               	.Lscope11:
 704               		.stabd	78,0,0
 705               		.lcomm I2cState,1
 706               		.lcomm i2cSlaveReceive,2
 707               		.lcomm i2cSlaveTransmit,2
 712               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 i2c.c
     /tmp/ccbNVaWo.s:2      *ABS*:0000003f __SREG__
     /tmp/ccbNVaWo.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccbNVaWo.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccbNVaWo.s:5      *ABS*:00000034 __CCP__
     /tmp/ccbNVaWo.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccbNVaWo.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccbNVaWo.s:119    .text:00000000 i2cInit
     /tmp/ccbNVaWo.s:705    .bss:00000001 i2cSlaveReceive
     /tmp/ccbNVaWo.s:706    .bss:00000003 i2cSlaveTransmit
                             .bss:00000000 I2cState
     /tmp/ccbNVaWo.s:187    .text:00000038 i2cSetBitrate
     /tmp/ccbNVaWo.s:209    .text:00000040 i2cSendStart
     /tmp/ccbNVaWo.s:235    .text:0000004e i2cSendStop
     /tmp/ccbNVaWo.s:261    .text:0000005c i2cWaitForComplete
     /tmp/ccbNVaWo.s:286    .text:00000066 i2cSendByte
     /tmp/ccbNVaWo.s:316    .text:00000078 i2cReceiveByte
     /tmp/ccbNVaWo.s:349    .text:00000094 i2cGetReceivedByte
     /tmp/ccbNVaWo.s:370    .text:0000009a i2cGetStatus
     /tmp/ccbNVaWo.s:394    .text:000000a0 i2cMasterSendNI
     /tmp/ccbNVaWo.s:540    .text:0000012e i2cMasterReceiveNI

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
